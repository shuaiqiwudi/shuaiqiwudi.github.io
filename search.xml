<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IOStream</title>
    <url>/2022/05/18/IOStream/</url>
    <content><![CDATA[<h1 id="IO流的继承关系和分类"><a href="#IO流的继承关系和分类" class="headerlink" title="IO流的继承关系和分类"></a>IO流的继承关系和分类</h1><img src="/2022/05/18/IOStream/image-20220518162023270.png" class="" title="image-20220518162023270">

<span id="more"></span>

<img src="/2022/05/18/IOStream/image-20220518162100236.png" class="" title="image-20220518162100236">

<img src="/2022/05/18/IOStream/image-20220518162120508.png" class="" title="image-20220518162120508">

<img src="/2022/05/18/IOStream/image-20220518162134464.png" class="" title="image-20220518162134464">
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/06/07/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>另一种操作系统</p>
<p>服务器操作系统</p>
<p>针对CentOS7</p>
<h2 id="Linux文件信息位置"><a href="#Linux文件信息位置" class="headerlink" title="Linux文件信息位置"></a>Linux文件信息位置</h2><h3 id="1-网卡信息存放位置"><a href="#1-网卡信息存放位置" class="headerlink" title="1.网卡信息存放位置"></a>1.网卡信息存放位置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">/* 如果是dell的物理服务器 */</span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-em1或em2 ，em3，em4</span><br><span class="line">/* 如果是云服务器 */</span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure>

<h3 id="2-防火墙的开启和关闭"><a href="#2-防火墙的开启和关闭" class="headerlink" title="2.防火墙的开启和关闭"></a>2.防火墙的开启和关闭</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br><span class="line">或</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<p>启动防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld.service  		--启动firewall</span><br><span class="line">systemctl enable firewalld.service		--开机时启动firewall</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service    		--停止firewall</span><br><span class="line">systemctl disable firewalld.service		--禁止firewall开机启动</span><br></pre></td></tr></table></figure>

<p>重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<p>查看防火墙是否开启自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled firewalld.service;echo $?</span><br></pre></td></tr></table></figure>

<p>查看已启动的服务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files|grep enabled</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/05/16/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p><strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此</p>
<p>Java语言可以实现跨平台。</p>
<p>提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a><strong>JRE</strong></h2><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java序，计算机中只需要安装JRE即可。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h2><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以</p>
<p>安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>从包含关系来讲：JDK&gt;JRE&gt;JVM</p>
<img src="/2022/05/16/JVM/image-20220516150612535.png" class="" title="image-20220516150612535">

<span id="more"></span>

<p>既然谈到了JVM 众所周知 JVM是java语言的灵魂 那么JVM给java带来了什么？</p>
<p>1.跨平台性：所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。</p>
<p>2.实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，该系统就可以运行java程序。</p>
<p>众所周知 <strong>java文件运行的流程</strong>如下：</p>
<p>.java文件 由开发人员编写 经过编译后 生成.class文件 ——即字节码文件 该.class文件不面向任何机器 只面向虚拟机</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可 在多种不同的计算机上运行。<strong>一次编译 到处运行</strong>作为高级语言 就得有解释 编译 将语言转化为二进制 这两个步骤 Java是怎么实现的呢？</p>
<p><strong>java中的编译器和解释器：</strong></p>
<p>也可以直接看下面</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码行。在Java中，这种供虚拟机理解的代码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java源代码(.java文件)----&gt;编译器----&gt;jvm可执行的Java字节码(.class文件)----&gt;jvm----&gt;jvm中的解释器-----&gt; 机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/JVM/image-20220711165236171.png" class="" title="image-20220711165236171">

<p>接下来看一下JVM内部结构：</p>
<h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><img src="/2022/05/16/JVM/image-20220516154322660.png" class="" title="image-20220516154322660">

<p>可以分为两组件 两子系统：</p>
<h2 id="JVM总体结构"><a href="#JVM总体结构" class="headerlink" title="JVM总体结构"></a>JVM总体结构</h2><p><strong>两个子系统</strong>：1.Class loader(类装载)  </p>
<p>​					   2. Execution engine(执行引擎)</p>
<p><strong>两个组件</strong>： 1.Runtime data area(运行时数据区）</p>
<p>​					2.Native Interface(本地接口)。</p>
<blockquote>
<p>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</blockquote>
<blockquote>
<p>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。</p>
</blockquote>
<blockquote>
<p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</blockquote>
<blockquote>
<p>Execution engine（执行引擎）：执行classes中的指令。</p>
</blockquote>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>运行时数据区存在于内存 又称jvm内存模型 分别有五个部分</p>
<blockquote>
<p><strong>程序计数器</strong>:当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选<strong>取下一条需要执行的 字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>:类似虚拟机栈，是为虚拟机使用native本地方法而准备的。具体实现由虚拟机厂商来实现。HotSpot虚拟机中实现与虚拟机栈一致，同时超出大小抛StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>:每个线程私有的空间，由多个栈帧组成，一个方法对应一个栈帧，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大1M，超出跑出StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>:所有线程都可以访问修改，存放的是对象实例，是数据区中占用空间最大的部分，在HotSpot虚拟机中分为新生代和老年代，新生代又分为Eden区和Survivor0区、Survivor1区。</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>:JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。不同虚拟机有不同的实现，oracle的HotSpot在Java7中方法区放在永久代，Java8中方法区放在元空间，并通过GC机制来管理。</p>
</blockquote>
<p>在<strong>线程共享</strong>的角度来分类：</p>
<p>​									<font color=Red><em>方法区,堆 属于线程共享的 | 虚拟机栈, 本地方法栈, 程序计数器不是线程共享的</em></font></p>
<p>**而程序计数器是唯一一个不会出现OOM的区域(Out Of Memory) ** 具体error：(java.lang.OutOfMemoryError)</p>
<p>首先聊一聊<strong>堆</strong>和<strong>方法区</strong>这两个最重要的区域:</p>
<p><strong>堆</strong>:从上面的定义来讲,存放对象实例,就是java中经常操作的对象,堆的物理地址分配对对象是不连续的。</p>
<p>因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩）。 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p><strong>方法区</strong>:存放类的相关信息</p>
<ol>
<li><p>静态变量放在方法区</p>
</li>
<li><p>静态的对象还是放在堆。</p>
</li>
</ol>
<p>既然创建的实例对象都在堆中,那堆中创建的对象多了怎么办,难道堆是一个无穷无尽的空间什么时期的实例对象都收纳吗?</p>
<p>堆空间是怎么决定哪些对象应该保存,哪些对象应该消失呢?难道要java程序员自己去决定吗?这就涉及到了java的垃圾回收机制</p>
<h3 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a><strong>什么是垃圾回收机制</strong></h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h3 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a><strong>什么是GC</strong></h3><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h3 id="垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗"><a href="#垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗" class="headerlink" title="垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?"></a><strong>垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?</strong></h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<h3 id="如何判断对象是否可以被回收（两种垃圾位置分析算法）"><a href="#如何判断对象是否可以被回收（两种垃圾位置分析算法）" class="headerlink" title="如何判断对象是否可以被回收（两种垃圾位置分析算法）"></a><strong>如何判断对象是否可以被回收</strong>（两种垃圾位置分析算法）</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」</p>
<p>的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<blockquote>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，</p>
<p>当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</p>
</blockquote>
<blockquote>
<p>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC</p>
<p>Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 </p>
</blockquote>
<p>&#x2F;&#x2F;TODO 可达性算法详解</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对于堆空间,java不同版本的虚拟机会有不同的垃圾回收算法,目前最主流的有:</p>
<h4 id="1-标记-清除算法："><a href="#1-标记-清除算法：" class="headerlink" title="1.标记-清除算法："></a>1.标记-清除算法：</h4><p>标记无用对象，然后进行清除回收。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<h4 id="2-标记-复制算法："><a href="#2-标记-复制算法：" class="headerlink" title="2.标记-复制算法："></a>2.标记-复制算法：</h4><p>按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<h4 id="3-标记-整理算法："><a href="#3-标记-整理算法：" class="headerlink" title="3.标记-整理算法："></a>3.标记-整理算法：</h4><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<h4 id="4-分代算法："><a href="#4-分代算法：" class="headerlink" title="4.分代算法："></a>4.分代算法：</h4><p>根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是新生代和老年 代，新生代分为Eden区和Survior区。<img src="/2022/05/16/JVM/image-20220521095627681.png" class="" title="image-20220521095627681"></p>
<p><strong>分代算法的对象迁移</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到 老年代。</p>
<h3 id="JVM都有哪些垃圾回收器？"><a href="#JVM都有哪些垃圾回收器？" class="headerlink" title="JVM都有哪些垃圾回收器？"></a>JVM都有哪些垃圾回收器？</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种作用于不同分代的收集器，其中于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于收整个Java堆的G1收集器。不同收集器 之间的连线表示它们可以搭配使用。</p>
<img src="/2022/05/16/JVM/image-20220520140939077.png" class="" title="image-20220520140939077">



<details>
<summary>点击查看垃圾回收器详细内容</summary>
Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU
环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不 高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器
的老年代版本；<br>
<b>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</b>： 老年代并行收集 器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。<br>
<b>G1(Garbage First)收集器 (标记-整理算法)</b>： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新
收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同
于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代 或老年代。<br>
</details>

<h3 id="各垃圾回收器的使用位置"><a href="#各垃圾回收器的使用位置" class="headerlink" title="各垃圾回收器的使用位置"></a><strong>各垃圾回收器的使用位置</strong></h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<h3 id="各代适合的垃圾回收算法"><a href="#各代适合的垃圾回收算法" class="headerlink" title="各代适合的垃圾回收算法"></a><strong>各代适合的垃圾回收算法</strong></h3><p>年轻代的堆空间，因为经常生成对象，并且对象的消亡和创建都很频繁，所以该区域需要高效率，能更好利用cpu的垃圾回收算法以保证内存空间的充足，<strong>新生代常常使用标记-复制算法。</strong></p>
<p>老年代的堆空间常常存放不易回收的对象，所以该区域不需要频繁的进行GC，需要考虑的是内存空间的利用，需要足够的空间存放不易回收的老年代对象，<strong>老年代常常使用标记整理算法，CMS的标记清除算法。</strong></p>
<h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a><strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="创建对象的内存分配"><a href="#创建对象的内存分配" class="headerlink" title="创建对象的内存分配"></a>创建对象的内存分配</h3><p>多数情况下，对象都在Eden区被创建，但是当Eden区内存空间不足的时候，虚拟机会进行一次<strong>年轻代的MinorGC</strong>，</p>
<p>如果本次GC以后，依然没有足够的空间，则将启用分配担保机制，在老年代中分配内存。</p>
<h3 id="如果对象太大怎么办？"><a href="#如果对象太大怎么办？" class="headerlink" title="如果对象太大怎么办？"></a><strong>如果对象太大怎么办？</strong></h3><p>大对象是指需要大的连续的内存空间的对象，而大对象如果存放在年轻代，而年轻代使用的是标记复制算法，大对象在两个幸存区之不断复制，占用了其他对象的空间，并且影响了效率。假设大对象是“朝生夕死”的（从GC次数上来讲不会进入老年代），那它占用了年轻的空间，其他对象进入的时候因为大对象的存在会提前触发GC，而大对象在幸存区的空间占比又过大，导致新创建的对象只能添加到老年代，这就加快了老年代GC的时间，对老年代的性能进行了很大的负面影响。<strong>（毕竟老年代的GC效率大概要比年轻代的GC效率低10倍左右）</strong>。如果确定大对象是“朝生夕死”的，可以通过设置JVM对大对象的参数阈值【-XX:PretenureSizeThreshold】，使大对象相对JVM来讲是不再那么大，从而在年轻代就GC（当然会这样影响性能）。</p>
<h3 id="发生在不同区域的GC"><a href="#发生在不同区域的GC" class="headerlink" title="发生在不同区域的GC"></a>发生在不同区域的GC</h3><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</p>
<p><strong>Major GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。</p>
<p><strong>FullGC</strong> 是指发生在整个堆内存的GC ，老年代和年轻代一起GC，应该避免FullGC的发生，会影响JVM的性能。</p>
<p>触发条件：1）System.gc() 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。</p>
<p>​					2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>​					3）通过Minor GC后进入年轻代的平均大小大于老年代的可用内存</p>
<p>FullGC详解</p>
<blockquote>
<p><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC | Plumbr – User Experience &amp; Application Performance Monitoring</a></p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h4 id="方法区存放的具体内容："><a href="#方法区存放的具体内容：" class="headerlink" title="方法区存放的具体内容："></a>方法区存放的具体内容：</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等。</p>
<p><img src="https://img2020.cnblogs.com/blog/2128165/202008/2128165-20200827223659712-1825753625.png" alt="9.4.1_1"></p>
<h4 id="方法区的位置"><a href="#方法区的位置" class="headerlink" title="方法区的位置"></a>方法区的位置</h4><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或进行压缩。”但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于 Java 堆的内存空间。</strong></p>
<p>方法区在 JVM 启动的时候被创建，并且它在实际的物理内存空间中，和 Java 堆区一样都可以是不连续的。在 jdk7 及以前，习惯上把方法区称为永久代。jdk8 开始，使用元空间取代了永久代。本质上，方法区和永久代并不等价，等价仅是对 HotSpot 而言的。</p>
<p>到了 JDK8，永久代的概念被完全废除，改用了在本地内存中实现的元空间（Metaspace）来代替。</p>
<h4 id="运行时常量池和常量池"><a href="#运行时常量池和常量池" class="headerlink" title="运行时常量池和常量池"></a>运行时常量池和常量池</h4><ul>
<li>方法区内部包含了运行时常量池。</li>
<li>字节码文件包含了常量池。</li>
</ul>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p>常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用，此时不再是常量池中的符号地址了，这里换为真实地址。<ul>
<li>运行时常量池相对于 Class 文件常量池的另一重要特征是：具备动态性。</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li>
</ul>
<h4 id="字符串常量池的位置变化"><a href="#字符串常量池的位置变化" class="headerlink" title="字符串常量池的位置变化"></a>字符串常量池的位置变化</h4><p>运行时常量池存和字符串常量池的变化</p>
<p>JDK1.7之前 ：<br>运行时常量池(包含字符串常量池 )存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_1">





<p>JDK1.7 ：<br>字符串常量池被从方法区拿到了堆中；<br>运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_2">





<p>JDK1.8 ：<br>hotspot移除了永久代，用元空间(Metaspace) 取而代之。这时候，<br>字符串常量池还在堆,<br>运行时常量池还在方法区, 只不过方法区的实现从永久代变成元空间(Metaspace)。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_3">



<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><h4 id="元空间的内存大小"><a href="#元空间的内存大小" class="headerlink" title="元空间的内存大小"></a>元空间的内存大小</h4><p>元空间是方法区的在HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过<strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</strong>理论上取决于32位&#x2F;64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数，元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定。</p>
<h4 id="为什么jdk8用metaspace数据结构用来替代perm？"><a href="#为什么jdk8用metaspace数据结构用来替代perm？" class="headerlink" title="为什么jdk8用metaspace数据结构用来替代perm？"></a>为什么jdk8用metaspace数据结构用来替代perm？</h4><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
<p>这项改动是很有必要的，原因有：</p>
<ol>
<li>永久代应该设置的空间大小很难确定。</li>
</ol>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<ol start="2">
<li>对永久代的调优是很困难的。</li>
</ol>
<h4 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h4><p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发，这就就导致 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代不足。放在堆里，能及时回收内存。</p>
<img src="/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><img src="/2022/05/16/JVM/image-20220711174215771.png" class="" title="image-20220711174215771">

<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="双亲委派类加载机制"><a href="#双亲委派类加载机制" class="headerlink" title="双亲委派类加载机制"></a>双亲委派类加载机制</h3><p><img src="https://uploadfiles.nowcoder.com/images/20211118/363939340_1637165320603/761B181C5781AFC06BE53D95033688DB" alt="img"></p>
<img src="/2022/05/16/JVM/image-20220711171336881.png" class="" title="image-20220711171336881">

<img src="/2022/05/16/JVM/image-20220711173346887.png" class="" title="image-20220711173346887">



<p><strong>双亲委派机制</strong>指的是，当某个特定的类加载器在收到类加载的请求时，会遵循下面的规则顺序：</p>
<p>1.首先判断被加载的类是否已经加载过，如果是则结束，否则会将加载任务委托给自己的父亲；<br>2.父类加载器在收到类加载的请求时，也会先判断被加载的类是否已经加载过，如果是则结束，否则同样将加载任务委托给自己的父亲<br>3.不断的循环进行步骤2，直到将加载任务委托给Bootstrap ClassLoader为止。此时，Bootstrap ClassLoader会先判断被加载的类是否已经加载过，如果是则结束；<br>请注意，到这里为止，都只是在转移加载任务的请求，下面将会进行类加载。</p>
<p>4.Bootstrap ClassLoader会判断能否完成加载任务，如果能则直接加载，否则会将加载任务交给儿子类加载器；<br>5.儿子类加载器也会判断能否完成加载任务，如果能则直接加载，否则会再一次将加载任务交给儿子类加载器；<br>6.不断的循环进行步骤5，直到最后一个类加载器，如果这个类加载器仍然不能够加载这个类，就会抛出一个异常：ClassNotFoundException。</p>
<pre><code>父加载器不是父类的关系 也不是类加载器的加载器 只是一种从属关系
</code></pre>
<h3 id="为什么要设计这种机制"><a href="#为什么要设计这种机制" class="headerlink" title="为什么要设计这种机制"></a>为什么要设计这种机制</h3><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入，既保证JVM的安全。</p>
<p>其次，还能保证同一个类不会被加载多次。</p>
<h2 id="对象从创建到消亡的历史过程"><a href="#对象从创建到消亡的历史过程" class="headerlink" title="对象从创建到消亡的历史过程"></a>对象从创建到消亡的历史过程</h2><h2 id="User-user-x3D-new-User-做了什么操作，申请了哪些内存？"><a href="#User-user-x3D-new-User-做了什么操作，申请了哪些内存？" class="headerlink" title="User user &#x3D; new User()  做了什么操作，申请了哪些内存？"></a>User user &#x3D; new User()  做了什么操作，申请了哪些内存？</h2><h3 id="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"><a href="#指针碰撞和空闲列表（堆内存分配对象空间的两种方式）" class="headerlink" title="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"></a>指针碰撞和空闲列表（堆内存分配对象空间的两种方式）</h3><p>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“ <em>指针碰撞</em> ”。</p>
<p> Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<em>空闲列表</em> ”。</p>
<p>具体分配方式由Jvm堆是否规整决定，Jvm堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效；如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<p>对象创建在虚拟机中是非常频繁的行为，因而产生大量的线程并发安全问题。Jvm通常采用CAS自旋和TLAB(本地线程缓冲)方案，来处理对象创建中线程安全问题。</p>
<pre><code>    CAS机制：对分配内存空间的动作进行同步处理，虚拟机采用CAS加失败重试的方式保证更新操作的原子性。通过自旋的方式不断尝试分配内存，直到分配成功。

    TALB机制：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。TLAB只是让每个线程有私有的分配指针，但是对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。（Jvm默认使用此方案）。
</code></pre>
<h2 id="对象的内存分配位置"><a href="#对象的内存分配位置" class="headerlink" title="对象的内存分配位置"></a>对象的内存分配位置</h2><p><img src="https://img-blog.csdnimg.cn/ec9158ddefc24b9a8c638d469729c542.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOO6KGM5rC05LiKX1pI,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="JVM的性能调优"><a href="#JVM的性能调优" class="headerlink" title="JVM的性能调优"></a>JVM的性能调优</h2><h2 id="GC算法，永久代对象如何GC，GC有环怎么处理"><a href="#GC算法，永久代对象如何GC，GC有环怎么处理" class="headerlink" title="GC算法，永久代对象如何GC，GC有环怎么处理"></a><strong>GC</strong>算法，永久代对象如何GC，GC有环怎么处理</h2><h2 id="Java7到Java8关于JVM的改变"><a href="#Java7到Java8关于JVM的改变" class="headerlink" title="Java7到Java8关于JVM的改变"></a>Java7到Java8关于JVM的改变</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>在讨论深拷贝和浅拷贝之前 首先要了解一下java的赋值机制——值传递</p>
<p>什么是值传递 什么是引用传递?</p>
<p>首先要了解一下 什么是实际参数 什么是形式参数?</p>
<p>形式参数 最先想到的就是java方法中的方法参数值了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123; <span class="comment">//word就是形式参数 简称形参</span></span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际参数 就是传给这个函数的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.speak(<span class="string">&quot;hello,java&quot;</span>);<span class="comment">//hello,java是实际参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 我传给这个函数的 到底是这个”hello,java”本身 还是”hello,java”这个对象在内存中的引用呢? 于是 就有了值传递和引用传递</p>
<p><strong>值传递</strong>: 把这个参数的值给函数,调用函数的时候只对传给这个函数的值进行修改等操作(就是说 在这个函数里你怎么折腾这个值都可以 但就是不会影响这个值本身) </p>
<p>将一个变量的值传给另一个变量。不管这个变量基本数据类型还是引用数据类型。引用数据类型的话传的还是值。不过这个值是指向对象的地址。</p>
<p><strong>引用传递</strong>: 直接传给函数这个参数的内存地址,直接在这个参数上面进行修改。</p>
<p>地址传递，传的是另一个变量的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>地址。<strong>java中没有引用传递</strong>。</p>
<hr>
<p><strong>深拷贝</strong></p>
<p>是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内</p>
<p>存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p><strong>浅拷贝</strong></p>
<p>只是增加了一个指针指向已存在的内存地址。</p>
<hr>
<p>那么这两个传递类型和深拷贝浅拷贝有什么关系呢?</p>
<p>深拷贝和浅拷贝在拷贝值的时候 都是值传递 并没有使用引用传递 而深拷贝的效果之所以有时候和引用传递相同,是因为引用传递是将对象的内存地址直接传给一个函数,而深拷贝是直接复制了一个内存值 在这个复制的内存值上进行操作.</p>
<p>巨人的肩膀：</p>
<p><a href="https://blog.csdn.net/myfirstuser/article/details/98034911">(31条消息) 方法区和堆_csdn.user的博客-CSDN博客_堆和方法区</a></p>
<p><a href="https://www.cnblogs.com/pensieve/p/13574459.html">09_方法区 - 只是一名学徒 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/codeyanbao/article/details/82875064">(31条消息) 通俗易懂的双亲委派机制_IT烂笔头的博客-CSDN博客_双亲委派机制</a></p>
<p><a href="https://blog.csdn.net/weixin_39517868/article/details/111390001">(31条消息) 双亲委派机制_面试官：双亲委派机制的原理和作用是什么？_weixin_39517868的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_69650487/article/details/124202086#:~:text=jvm%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%BB,%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82">(31条消息) Jvm对象创建过程_风行水上_ZH的博客-CSDN博客_jvm初始化过程</a></p>
<p>更深入：</p>
<p><a href="https://www.cnblogs.com/duanxz/p/3520829.html">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Server</title>
    <url>/2022/05/18/Server/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>作为后端开发，数据传输到前端界面，或者浏览器运行，如果出现问题，那么就会让人崩溃，各种错误代码扑面而来，让头发焦急。</p>
<p>提到Tomcat 就必须提到Server。</p>
<p>每当一个项目开始运行（启动）那么，支撑浏览器到达指定端口的位置，并且显示界面的，显示数据的，一定是服务器的工作，在本地的项目开始运行，tomcat就充当这个服务器的角色，所以tomcat是web应用服务器,是用来处理java程序的一个应用服务器。</p>
<p>扒开Tomcat 看看真面目：</p>
<img src="/2022/05/18/Server/20160816205332380.png" class="" title="Tomcat总体架构">

<span id="more"></span>



<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>Server是Tomcat最顶层的容器，代表着整个服务器，即一个Tomcat只有一个Server，Server中包含至少一个Service组件，用于提供具体服务。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2022/05/29/Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><img src="/2022/05/29/Mybatis/1502093784622523.png" class="" title="img">

<h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis?"></a>什么是Mybatis?</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<span id="more"></span>

<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>首先在pom.xml文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 <a href="https://www.w3cschool.cn/xml/">XML</a> 中构建 SqlSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 <code>file:// URL</code> 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（<a href="https://www.w3cschool.cn/kzsow/kzsow-frbn2grj.html">mapper</a>），这些映射器的 XML 映射文件包含了 <a href="https://www.w3cschool.cn/sql/">SQL</a> 代码和映射定义信息。</p>
<h1 id="MyBatis-XML配置"><a href="#MyBatis-XML配置" class="headerlink" title="MyBatis XML配置"></a>MyBatis XML配置</h1><p>mybatis-config.xml配置文件  <configuration> 标签中 各个标签的配置顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--    此处易报错 注意错误返回的标签规则 将下面的标签顺序重新排列--&gt;</span><br><span class="line">&lt;!--    (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt;--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h2><p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h2><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
<p>属性也可以被传递到 SqlSessionBuilder.build()方法中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment, props);</span><br></pre></td></tr></table></figure>

<p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的<strong>顺序来加载</strong>：</p>
<ul>
<li>在 properties 元素体内指定的属性首先被读取。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。</li>
</ul>
<h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a>配置环境（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p>
<p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p>
<ul>
<li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment,properties);</span><br></pre></td></tr></table></figure>

<p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader,properties);</span><br></pre></td></tr></table></figure>

<p>环境元素定义了如何配置环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用的是第一个环境变量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 另一个环境 在&lt;environments default=&quot; &quot;&gt; 设置应该加载哪个--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password2&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的关键点:</p>
<ul>
<li>默认的环境 ID（比如:default&#x3D;”development”）。</li>
<li>每个 environment 元素定义的环境 ID（比如:id&#x3D;”development”）。</li>
<li>事务管理器的配置（比如:type&#x3D;”JDBC”）。</li>
<li>数据源的配置（比如:type&#x3D;”POOLED”）。</li>
</ul>
<p>默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。</p>
<h3 id="数据源（dataSource）"><a href="#数据源（dataSource）" class="headerlink" title="数据源（dataSource）"></a><strong>数据源（dataSource）</strong></h3><p>数据源<dataSource> 标签 属于  <environment> 在其中配置数据源</p>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<ul>
<li>许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</li>
</ul>
<p>有三种内建的数据源类型（也就是 type&#x3D;”[   UNPOOLED     |    POOLED    |    JNDI    ]”）：</p>
<p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p>
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
</ul>
<p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为”driver.”，例如：</p>
<ul>
<li><code>driver.encoding=UTF8</code></li>
</ul>
<p>这将通过DriverManager.getConnection(url,driverProperties)方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</p>
<p><strong>POOLED</strong>– 这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
<p>除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是”NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 <code>poolPingQuery</code> 属性（最好是一个非常快的 SQL），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
<p><strong>JNDI</strong>– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p>
<ul>
<li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。</li>
<li><code>data_source</code> – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</li>
</ul>
<h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h2><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="编写XML映射文件"><a href="#编写XML映射文件" class="headerlink" title="编写XML映射文件"></a>编写XML映射文件</h1><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p>
<ul>
<li><code>cache</code> – 给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。</p>
<p>select 标签有很多属性允许你配置，来决定每条语句的作用细节。</p>
<p><strong>Select Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">resultType</td>
<td align="left">从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td>
</tr>
<tr>
<td align="left">resultMap</td>
<td align="left">外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</td>
</tr>
<tr>
<td align="left">useCache</td>
<td align="left">将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">fetchSize</td>
<td align="left">这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">resultSetType</td>
<td align="left">FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
<tr>
<td align="left">resultOrdered</td>
<td align="left">这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td>
</tr>
<tr>
<td align="left">resultSets</td>
<td align="left">这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</td>
</tr>
</tbody></table>
<p>类似的 insert update delete 标签的属性</p>
<p><strong>Insert Update Delete Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">命名空间中的唯一标识符，可被用来代表这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="left">（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td align="left">keyProperty</td>
<td align="left">（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">keyColumn</td>
<td align="left">（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<p>&#x2F;&#x2F;TODO 一些其他的构造方法和参数</p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>根据条件进行判断：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<p>还是上面的例子，但是这次变为提供了”title”就按”title”查找，提供了”author”就按”author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><p>首先看一个动态SQL：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>乍一看没什么问题 但是当每个条件都匹配不到时,这条SQL会变成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure>

<p>如何解决这种条件不匹配的sql？MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>where 元素知道只有在一个以上的if条件有值的情况下才去插入”WHERE”子句。而且，若最后的内容是”AND”或”OR”开头的，where 元素也知道如何将他们去除。</p>
<p>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。</p>
<p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。</p>
<p>若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。</p>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p>
<h1 id="Mybatis-日志"><a href="#Mybatis-日志" class="headerlink" title="Mybatis 日志"></a>Mybatis 日志</h1><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>将用户经常查询的数据的结果的一个保存，保存到一个内存中（缓存就是内存中的一个对象），用户在查询的时候就不用到数据库文件中查询（磁盘），从而减少与数据库的交付次数提高了响应速度，解决了并发系统的性能问题。</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>MyBatis提供了一级缓存和二级缓存</p>
<ul>
<li>一级缓存：也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。</li>
<li>二级缓存：也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>在应用运行过程中，在一次数据库会话中，执行多次查询条件完全相同的SQL，会优先命中一级缓存，避免直接对数据库中直接查询。</p>
<img src="/2022/05/29/Mybatis/webp.webp" class="" title="img">

<p>每个SqlSession中都持有Excutor，每个Excutor中有一个LocalCache。当用户发起询问时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。</p>
<img src="/2022/05/29/Mybatis/webp-16538306997353.webp" class="" title="img">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>SqlSession：</strong> 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是DefaultSqlSession。<br> <strong>Executor：</strong> SqlSession向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。Executor有两个实现类，和一级缓存关联的是BaseExecutor。<br> <strong>BaseExecutor：</strong> BaseExecutor是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。<br> <strong>PerpetualCache：</strong>对Cache接口最基本实现，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。</p>
<p>SqlSession初始化时会创建Executor的实例，Mybatis默认使用的是SimpleExecutor，初始化代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如果启用二级缓存，使用CahingExecutor装饰类</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession在提交的时候会清空本地缓存，因为commit操作一般对应插入、更新或者删除操作，清空缓存防止读取脏数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Cannot commit, transaction is already closed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  flushStatements();</span><br><span class="line">  <span class="keyword">if</span> (required) &#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession的insert方法和delete方法，都会统一走update的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>update方法也是委托给了Executor执行。BaseExecutor的执行方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一级缓存失效的原因"><a href="#一级缓存失效的原因" class="headerlink" title="一级缓存失效的原因"></a>一级缓存失效的原因</h3><ul>
<li>同一个用户使用不同的SqlSession对象导致无法看到一级缓存工作。</li>
<li>在一个SqlSession中使用条件查询不同一级缓存也会失效。</li>
<li>在一个SqlSession使用相同条件，但是，此时在查询之间进行数据修改操作会导致一级缓存失效。</li>
<li>在一个SqlSession使用相同查询条件此时手动刷新缓存时导致一级缓存失败。</li>
</ul>
<h3 id="一级缓存注意"><a href="#一级缓存注意" class="headerlink" title="一级缓存注意"></a>一级缓存注意</h3><p>MyBatis一级缓存的生命周期和SqlSession一致。</p>
<p>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</p>
<p>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据。</p>
<p>mybatis和spring整合后进行mapper代理开发，不支持一级缓存。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><img src="/2022/05/29/Mybatis/webp-16538311623015.webp" class="" title="img">

<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。<br> 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="如何开启二级缓存"><a href="#如何开启二级缓存" class="headerlink" title="如何开启二级缓存"></a>如何开启二级缓存</h3><ol>
<li>需要在MyBatis核心配置文件,通过settings标签开发二级缓存。<br> <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></li>
<li>在对应的Mapper文件中添加cache标签</li>
<li>cache标签属性</li>
</ol>
<ul>
<li><p>type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。</p>
</li>
<li><p>eviction： 定义回收的策略，常见的有FIFO，LRU。</p>
</li>
<li><p>flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</p>
</li>
<li><p>size： 最多缓存对象的个数。</p>
</li>
<li><p>readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</p>
</li>
<li><p>blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存4</p>
<p>4.cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
</li>
</ul>
<p> <code>&lt;cache-ref namespace=&quot;mapper.StudentMapper&quot;/&gt;</code></p>
<h3 id="核心接口和实现类"><a href="#核心接口和实现类" class="headerlink" title="核心接口和实现类"></a>核心接口和实现类</h3><img src="/2022/05/29/Mybatis/webp-16538313584837.webp" class="" title="img">

<p>CachingExecutor的query方法，首先会从MappedStatement中获得在配置初始化时赋予的Cache。</p>
<p>以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。</p>
<ul>
<li>SynchronizedCache： 同步Cache，实现比较简单，直接使用synchronized修饰方法。</li>
<li>LoggingCache： 日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。</li>
<li>SerializedCache： 序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li>LruCache： 采用了Lru算法的Cache实现，移除最近最少使用的key&#x2F;value。</li>
<li>PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<p>可以为每条Mapper语句设置是否要刷新缓存,可以指定select语句是否使用缓存,如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>判断是否刷新缓存</p>
<p> <code>flushCacheIfRequired(ms);</code></p>
<p> 在默认的设置的select语句是不会刷新缓存的，insert&#x2F;update&#x2F;delte会刷新缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>&#x2F;&#x2F;TODO</p>
<h3 id="二级缓存失效的原因"><a href="#二级缓存失效的原因" class="headerlink" title="二级缓存失效的原因"></a>二级缓存失效的原因</h3><ul>
<li>flushCache属性在查询中作用针对二级缓存导致失效</li>
<li>flushCache属性在查询中作用针对一级缓存导致失效</li>
<li>flushCache属性在更新中作用导致两次查询结果完全一样</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</p>
<p>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p>
<p>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis,Memcached等分布式缓存可能成本更低，安全性也更高。</p>
<p>原文链接：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制 - 美团技术团队 (meituan.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/b4522c9212fb">https://www.jianshu.com/p/b4522c9212fb</a></p>
<p>原文链接：<a href="https://www.w3cschool.cn/mybatis/mybatis-dyr53b5w.html">MyBatis 入门_w3cschool</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Cloud Alibaba</title>
    <url>/2022/07/01/Spring-Cloud-Alibaba/</url>
    <content><![CDATA[<p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html">Spring Cloud Alibaba 参考文档 (spring-cloud-alibaba-group.github.io)</a></p>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba">alibaba&#x2F;spring-cloud-alibaba: Spring Cloud Alibaba provides a one-stop solution for application development for the distributed solutions of Alibaba middleware. (github.com)</a></p>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><img src="https://mrhelloworld.com/resources/articles/articles_header/2020/06/03/header.jpg" alt="https://mrhelloworld.com/resources/articles/articles_header/2020/06/03/header.jpg" style="zoom:80%;" />

<span id="more"></span>

<h2 id="Nacos-x3D-eureka-config-bus-！！！"><a href="#Nacos-x3D-eureka-config-bus-！！！" class="headerlink" title="Nacos &#x3D; eureka + config + bus ！！！"></a><strong>Nacos &#x3D; eureka + config + bus ！！！</strong></h2><p>Quick Start</p>
<p>首先打开下载好的nacos，进入bin目录启动start.cmd 就开启了本地的nacos服务</p>
<h2 id="作为注册中心"><a href="#作为注册中心" class="headerlink" title="作为注册中心"></a>作为注册中心</h2><p>开启nacos服务后,相当与配置了一个完整的eureka服务并开启,nacos的本地地址为<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p>
<p>接下来姐可以开启服务模块和客服模块了.</p>
<p>服务模块:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日常通用jar包配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>主启动类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nacos和其他注册中心比较"><a href="#Nacos和其他注册中心比较" class="headerlink" title="Nacos和其他注册中心比较"></a>Nacos和其他注册中心比较</h2><p>Nacos自动支持CP和AP</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706154546368.png" class="" title="image-20220706154546368">

<p>Nacos如何切换AP和CP?</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#x27;$NACOS_SERVER:<span class="number">8848</span>/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="作为配置中心Config"><a href="#作为配置中心Config" class="headerlink" title="作为配置中心Config"></a>作为配置中心Config</h2><p>在nacos的配置文件的命名规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个微服务，cloudalibaba-config-nacos-client3377</p>
<p>需要 <strong>application.yaml 和 bootstrap.yaml</strong> 两个配置文件 (为了能和SpringCloud平滑过渡）</p>
<blockquote>
<p> <em><strong>bootstrap.yaml的优先级高于application.yaml</strong></em></p>
</blockquote>
<p>1.application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line"><span class="comment">#    active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bootstrap.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"><span class="comment">#        group: DEV_GROUP # 指定分组</span></span><br><span class="line"><span class="comment">#        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4 # 指定命名空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>



<p>因为nacos集成了bus+config+eureka 所以当nacos的配置文件进行修改了之后 其config客户端自动就会进行动态刷新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用@Value注解自动填充配置文件里的信息。</p>
<p>于是就可以获取的到文件了。</p>
<h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><p><strong>之后想要不同的配置文件则切换环境就可以了。首先可以再 bootstrap.yaml指定命名空间namespace 然后 Group 最后在 application.yaml 通过命名规则指定 DataID。</strong></p>
<h2 id="Group和Data-ID"><a href="#Group和Data-ID" class="headerlink" title="Group和Data ID"></a>Group和Data ID</h2><img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220701200647822.png" class="" title="image-20220701200647822">

<p>所以，当我们需要制定某个配置文件的时候，就需要Group和Data Id配合使用 所以就需要application.yaml和bootstrap.yaml两个配置文件配合使用。</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220707105954569.png" class="" title="image-20220707105954569">



<h2 id="Nacos集群配置"><a href="#Nacos集群配置" class="headerlink" title="Nacos集群配置"></a>Nacos集群配置</h2><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">集群部署说明 (nacos.io)</a></p>
<p>作为服务注册中心，为了保证其可用性以及出现宕机的意外情况，应该配置nacos集群以保证线上环境的稳定。</p>
<p><img src="https://nacos.io/img/deployDnsVipMode.jpg" alt="deployDnsVipMode.jpg"></p>
<p>SLB代表的是负载均衡的集群配置，此处使用的是nginx的一个集群配置。<a href="https://developer.aliyun.com/article/1803">SLB技术原理浅析-阿里云开发者社区 (aliyun.com)</a></p>
<p>关于nacos的数据源使用高可用数据库，类似以下情况架构</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220702100327727.png" class="" title="image-20220702100327727">

<p>从github上的源码中查看nacos的pom依赖文件，<strong>derby是nacos自带的内置数据库</strong>，所以我们的配置文件才得以保存在nacos中，而当我们需要一个稳定的数据源的使用，就需要将这个<strong>derby数据库切换为mysql数据库</strong>（集群）</p>
<p>切换步骤：（本机电脑未切换）</p>
<p>nacos-server-1.1.3\nacos\conf\nacos-mysql.sql </p>
<p>复制该sql脚本到本地数据库中，创建对应配置文件表。</p>
<p>nacos-server-1.1.3\nacos\conf\application.properties</p>
<p>修改该配置文件，在最后添加一段配置，指向本地mysql</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">介绍 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>
<img src="https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png" alt="Sentinel Logo" style="zoom: 50%;" />

<p>Sentinel单独组件，直接界面化的细粒度统一配置。</p>
<p>Sentinel 是什么？<br>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性</p>
<p>Sentinel的官方标题是：分布式系统的流量防卫兵。从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。</p>
<p>在官网下载jar包后，使用java -jar命令运行该项目，访问localhost:8080 即可进入（通常情况下同时配合Nacos使用，Sentinel与Nacos进行具体服务的操作和配置）</p>
<h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><p>Sentinel 不需要Hystrix一样自己进行服务的搭建，而是直接运行jar包启动服务。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard-<span class="number">1</span>.<span class="number">7</span>.<span class="number">0</span>.jar</span><br></pre></td></tr></table></figure>

<p>运行具体版本jar包。</p>
<p>支付端：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"><span class="comment">#      datasource:</span></span><br><span class="line"><span class="comment">#        ds1:</span></span><br><span class="line"><span class="comment">#          nacos:</span></span><br><span class="line"><span class="comment">#            server-addr: localhost:8848</span></span><br><span class="line"><span class="comment">#            dataId: cloudalibaba-sentinel-service</span></span><br><span class="line"><span class="comment">#            groupId: DEFAULT_GROUP</span></span><br><span class="line"><span class="comment">#            data-type: json</span></span><br><span class="line"><span class="comment">#            rule-type: flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#feign:</span></span><br><span class="line"><span class="comment">#  sentinel:</span></span><br><span class="line"><span class="comment">#    enabled: true # 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure>



<h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><h3 id="流控规则的规则意义"><a href="#流控规则的规则意义" class="headerlink" title="流控规则的规则意义"></a>流控规则的规则意义</h3><p>Sentinel 作为一种轻量级高可用流量控制组件，流量控制是它最主要的工作之一。</p>
<p>我们可以针对资源定义流控规则，Sentinel 会根据这些规则对流量相关的各项指标进行监控。当这些指标当达到或超过流控规则规定的阈值时，Sentinel 会对请求的流量进行限制（即“限流”），以避免系统被瞬时的流量高峰冲垮，保障系统的高可用性。</p>
<p><strong>同一个资源可以创建多条流控规则，Sentinel 会遍历这些规则，直到有规则触发限流或者所有规则遍历完毕为止。</strong></p>
<h3 id="流控规则的具体实现"><a href="#流控规则的具体实现" class="headerlink" title="流控规则的具体实现"></a>流控规则的具体实现</h3><img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706153537108.jpg" class="" title="image-20220706153537108">



<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220703105117104.png" class="" title="image-20220703105117104">

<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220703105210793.png" class="" title="image-20220703105210793">



<p>添加流控规则添加：簇点链路 ——&gt;列表视图 ——&gt;选择具体资源名  就可以继续进行流控限制。</p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel <strong>熔断降级</strong>会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 <code>DegradeException</code>）。</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/10252343H-15.png" class="" title="Sentinel 熔断状态转换">

<h3 id="Sentinel-熔断策略"><a href="#Sentinel-熔断策略" class="headerlink" title="Sentinel 熔断策略"></a>Sentinel 熔断策略</h3><ol>
<li><strong>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)<strong>：当 1s 内持续进入 5 个请求（大于等于5），对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口期（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，</strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li>
<li>**异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)**：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li>**异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)**：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li>
</ol>
<p><strong>需要注意的是</strong>：</p>
<p>RT和异常比例分别需要满足的条件不只是处理时间和异常的所占比率，而且<strong>都需要满足每秒的请求数 &gt;&#x3D;5</strong>，如果请求数目不满足的话，只会进入RunTimeException然后返回常见的报错界面。</p>
<p>Sentinel 1.8.0 版本对熔断降级特性进行了全新的改进升级，以下熔断策略针对的是 Sentinel 1.8.0 及以上版本。</p>
<h4 id="Sentinel-1-8-0-以上熔断策略"><a href="#Sentinel-1-8-0-以上熔断策略" class="headerlink" title="Sentinel 1.8.0 以上熔断策略"></a>Sentinel 1.8.0 以上熔断策略</h4><p>Sentinel 提供了 3 种熔断策略，如下表所示。</p>
<table>
<thead>
<tr>
<th>熔断策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>慢调用比例 (SLOW_REQUEST_RATIO）</td>
<td>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大响应时间），若请求的响应时间大于该值则统计为慢调用。  当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则再次被熔断。</td>
</tr>
<tr>
<td>异常比例 (ERROR_RATIO)</td>
<td>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目且异常的比例大于阈值，则在接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</td>
</tr>
<tr>
<td>异常数 (ERROR_COUNT)</td>
<td>当单位统计时长内的异常数目超过阈值之后会自动进行熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</td>
</tr>
</tbody></table>
<h3 id="和Hystrix的熔断降级对比"><a href="#和Hystrix的熔断降级对比" class="headerlink" title="和Hystrix的熔断降级对比"></a>和Hystrix的熔断降级对比</h3><p>Sentinel 和 Hystrix 的熔断降级功能本质上都是基于熔断器模式（Circuit Breaker Pattern）。Sentinel 与 Hystrix 都支持基于失败比率（异常比率）的熔断降级，在调用达到一定量级并且失败比率达到设定的阈值时自动进行熔断，此时所有对该资源的调用都会被 block，直到过了指定的时间窗口后才启发性地恢复。Sentinel 还支持基于平均响应时间的熔断降级，可以在服务响应时间持续飙高的时候自动熔断，拒绝掉更多的请求，直到一段时间后才恢复。这样可以防止调用非常慢造成级联阻塞的情况。</p>
<p>Hystrix存在半开规则，判断是否可以恢复服务，而<strong>Sentinel的熔断器是没有半开状态</strong>的，取而代之的是时间窗口期内的<strong>探测恢复状态</strong>。</p>
<h2 id="热点Key"><a href="#热点Key" class="headerlink" title="热点Key"></a>热点Key</h2><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<ul>
<li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li>
<li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li>
</ul>
<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。<br> Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新增热点规则：</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706104040702.png" class="" title="image-20220706104040702">

<p>限流规则：仅支持QPS（线程数）</p>
<p>参数索引：指定限制的热点参数的索引位置</p>
<p>单机阈值：流量个数</p>
<p>统计时长：休息的窗口期 </p>
<p>如果使用了热点规则，强烈建议**@SentinelResource注解添加blockHandler参数**，否则返回正常的错误界面，不友好。</p>
<h3 id="参数例外项："><a href="#参数例外项：" class="headerlink" title="参数例外项："></a>参数例外项：</h3><p>选择高级选项，具体到某一参数的具体值进行限流控制。仅支持八大数据类型。</p>
<h2 id="系统自适应限流"><a href="#系统自适应限流" class="headerlink" title="系统自适应限流"></a>系统自适应限流</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">系统自适应限流 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>
<p>Sentinel 系统<strong>自适应限流从整体维度对应用入口流量进行控制</strong>，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个<strong>平衡</strong>，让系统尽可能跑在最大吞吐量的同时保证系统整体的<strong>稳定性</strong>。</p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h2 id="SentinelResource注解配置"><a href="#SentinelResource注解配置" class="headerlink" title="@SentinelResource注解配置"></a>@SentinelResource注解配置</h2><p>以上使用@SentinelResource的规则 我们要面临以下几个问题。</p>
<ol>
<li>系统默认的，没有体现我们自己的业务逻辑</li>
<li>依照现有条件，我们自定义的处理方法又和业务模块耦合在一起，耦合度高。</li>
<li>每个业务方法都添加一个blockhandler兜底方法，代发过于冗余。</li>
<li>没有全局统一的处理方法。</li>
</ol>
<p>对于很多的方法类，如果都需要一个降级的blockHandler兜底方法，不能挨个配置，可以定义一个公共的降级方法提供给这些方法使用。</p>
<p>所以我们可以解锁 @SentinelResource 的更多姿势：写一个公共类（本例中为CustomerBlockHandler），可以定义不同的静态blockHandler方法提供给其他方法，在具体方法上添加@SentinelResource注解，然后（blockHandlerClass ）指定处理异常的类，（blockHandler）再具体到这个类中的某个方法。</p>
<p>配置参数和具体方法的对应位置：</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706151534201.png" class="" title="image-20220706151534201">





<h1 id="Sentinel-整合Ribbon-OpenFeign-Fallback"><a href="#Sentinel-整合Ribbon-OpenFeign-Fallback" class="headerlink" title="Sentinel 整合Ribbon+OpenFeign+Fallback"></a>Sentinel 整合Ribbon+OpenFeign+Fallback</h1><blockquote>
<p> 本地三个微服务：提供者cloudalibaba-provider-payment9003 cloudalibaba-provider-payment9004 								</p>
<p>​								消费者 cloudalibaba-consumer-nacos-order84	</p>
</blockquote>
<p>巨人的肩膀：</p>
<p><a href="https://developer.aliyun.com/article/623424">Sentinel 与 Hystrix 的对比-阿里云开发者社区 (aliyun.com)</a></p>
<p><a href="http://c.biancheng.net/springcloud/sentinel.html">Sentinel：Spring Cloud Alibaba高可用流量控制组件（非常详细） (biancheng.net)</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud一站式微服务解决方案</title>
    <url>/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="微服务生态"><a href="#微服务生态" class="headerlink" title="微服务生态"></a>微服务生态</h1><p><a href="https://martinfowler.com/microservices/">Microservices Guide (martinfowler.com)</a></p>
<p><img src="https://pic1.zhimg.com/v2-411c496a803862df08e8ac16f9fe5039_1440w.jpg?source=172ae18b" alt="一篇文章搞懂 Spring Cloud 是什么"></p>
<span id="more"></span>

<h2 id="SpringCloud模块的搭建"><a href="#SpringCloud模块的搭建" class="headerlink" title="SpringCloud模块的搭建"></a>SpringCloud模块的搭建</h2><p>1.在父项目下创建module模块 选择Maven模式</p>
<p>2.修改pom.xml文件 将其需要从父类继承的依赖添加进本模块的pom文件中</p>
<p>3.写application.yml文件 关于模块的资源配置</p>
<p>4.创建模块的主启动类 添加注解</p>
<p>5.开始写业务</p>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h2><h2 id="ribbon和nginx的区别"><a href="#ribbon和nginx的区别" class="headerlink" title="ribbon和nginx的区别"></a>ribbon和nginx的区别</h2><h2 id="Ribbon-如何使用？"><a href="#Ribbon-如何使用？" class="headerlink" title="Ribbon 如何使用？"></a>Ribbon 如何使用？</h2><h2 id="Ribbon使用场景"><a href="#Ribbon使用场景" class="headerlink" title="Ribbon使用场景"></a>Ribbon使用场景</h2><h2 id="Ribbon轮询算法及其实现原理"><a href="#Ribbon轮询算法及其实现原理" class="headerlink" title="Ribbon轮询算法及其实现原理"></a>Ribbon轮询算法及其实现原理</h2><h2 id="手写Ribbon负载均衡算法"><a href="#手写Ribbon负载均衡算法" class="headerlink" title="手写Ribbon负载均衡算法"></a>手写Ribbon负载均衡算法</h2><p>Ribbon是负载均衡算法</p>
<h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><p><a href="https://spring.io/projects/spring-cloud-openfeign">Spring Cloud OpenFeign</a></p>
<p><strong>消费端</strong>的负载均衡和路由转发 即自动集成了Ribbon+RestTemplate </p>
<p>就是对外的一个提供负载均衡的微服务使用中间件。</p>
<h2 id="使用OpenFeign"><a href="#使用OpenFeign" class="headerlink" title="使用OpenFeign"></a>使用OpenFeign</h2><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注册到服务中心</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<p>首先创建主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableFeignClients标识该微服务为Feign的消费端</p>
<p>接着创建service包 并创建与服务端接口interface 即其中的提供服务的方法与服务端提供的对外@RequestMapping（@GettingMapping或@PostMapping）方法相同。</p>
<p>在Feign的这个接口添加两个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.@Component 给Spring扫描</p>
<p>2.@FeignClient(value &#x3D; “CLOUD-PAYMENT-SERVICE”) 指定哪个服务名称的服务端提供给服务 如果是集群 则进行负载均衡（默认轮询）</p>
<p><strong>代表的是 这个接口中 在@FeignClient的value值所指向的集群中 寻找以下接口中的对外Request方法。</strong></p>
<p>接着创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br></pre></td></tr></table></figure>

<p>然后就可以在其中调用接口中的方法了 调用的的实际上是服务端的对外接口。</p>
<h2 id="Feign超时预警"><a href="#Feign超时预警" class="headerlink" title="Feign超时预警"></a>Feign超时预警</h2><img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220626150939581.png" class="" title="image-20220626150939581">

<p>当设置服务端的controller 的对外方法为超过1秒的时候 Feign消费端调用这个方法便会出现以上错误。</p>
<p>但是有些服务的运行时间就是大于一秒 ，为了避免这种情况， 需要设置Feign客户端的超时控制。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment">#读取超时时间 指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#连接超时时间 指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="什么是Hystrix？"><a href="#什么是Hystrix？" class="headerlink" title="什么是Hystrix？"></a>什么是Hystrix？</h2><p><a href="https://github.com/Netflix/Hystrix">GitHub - Netflix&#x2F;Hystrix: Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">How it Works · Netflix&#x2F;Hystrix Wiki · GitHub</a></p>
<h2 id="服务降级：系统有限的资源的合理协调"><a href="#服务降级：系统有限的资源的合理协调" class="headerlink" title="服务降级：系统有限的资源的合理协调"></a>服务降级：<strong>系统有限的资源的合理协调</strong></h2><ul>
<li><p>概念：服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而<strong>释放服务器资源的资源以保证核心业务的正常高效运行。</strong></p>
</li>
<li><p>原因： 服务器的资源是有限的，而请求是无限的。在用户使用即并发高峰期，会影响整体服务的性能，严重的话会导致宕机，以至于某些重要服务不可用。故高峰期为了保证核心功能服务的可用性，就需要对某些服务降级处理。可以理解为舍小保大</p>
</li>
<li><p>应用场景： 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时（比如双11、6.18等活动或者秒杀活动）</p>
</li>
<li><p>服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。</p>
</li>
<li><p>需要考虑的问题：</p>
</li>
<li><ul>
<li>区分那些服务为核心？那些非核心</li>
<li>降级策略（处理方式，一般指如何给用户友好的提示或者操作）</li>
<li>自动降级还是手动降</li>
</ul>
</li>
</ul>
<h2 id="服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况"><a href="#服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况" class="headerlink" title="服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况"></a>服务熔断<strong>：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况</strong></h2><ul>
<li>概念：应对微服务雪崩效应的一种链路保护机制，类似股市、保险丝</li>
<li>原因： 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应</li>
<li>服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</li>
<li>服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</li>
</ul>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p>
<ul>
<li>应用场景：微服务架构中，多个微服务相互调用出使用</li>
<li>需要考虑问题：</li>
<li><ul>
<li>如何所依赖的服务对象不稳定</li>
<li>失败之后如何快速恢复依赖对象，如何探知依赖对象是否恢复</li>
</ul>
</li>
</ul>
<h2 id="服务降级和服务熔断区别"><a href="#服务降级和服务熔断区别" class="headerlink" title="服务降级和服务熔断区别"></a><strong>服务降级和服务熔断区别</strong></h2><ul>
<li><p>触发原因不一样，服务熔断由链路上某个服务引起的，服务降级是从整体的负载考虑</p>
</li>
<li><p>管理目标层次不一样，服务熔断是一个框架层次的处理，服务降级是业务层次的处理</p>
</li>
<li><p>实现方式不一样，服务熔断一般是自我熔断恢复，服务降级相当于人工控制</p>
</li>
<li><p>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</p>
</li>
</ul>
<p>一句话：</p>
<p>服务熔断是应对系统服务雪崩的一种保险措施，给出的一种特殊降级措施。而服务降级则是更加宽泛的概念，主要是对系统整体资源的合理分配以应对压力。</p>
<p>服务熔断是服务降级的一种特殊情况，他是防止服务雪崩而采取的措施。系统发生异常或者延迟或者流量太大，都会触发该服务的服务熔断措施，链路熔断，返回兜底方法。这是对局部的一种保险措施。</p>
<p>服务降级是对系统整体资源的合理分配。区分核心服务和非核心服务。对某个服务的访问延迟时间、异常等情况做出预估并给出兜底方法。这是一种全局性的考量，对系统整体负荷进行管理。</p>
<p>限流：限制并发的请求访问量，超过阈值则拒绝；</p>
<p>降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；</p>
<p>熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复</p>
<h2 id="服务服务限流"><a href="#服务服务限流" class="headerlink" title="服务服务限流"></a>服务服务限流</h2><p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。</p>
<h2 id="关于JMeter的使用和测试"><a href="#关于JMeter的使用和测试" class="headerlink" title="关于JMeter的使用和测试"></a>关于JMeter的使用和测试</h2><h3 id="压测的使用"><a href="#压测的使用" class="headerlink" title="压测的使用"></a>压测的使用</h3><h2 id="Springboot自己集成的Tomcat服务器的默认线程数目"><a href="#Springboot自己集成的Tomcat服务器的默认线程数目" class="headerlink" title="Springboot自己集成的Tomcat服务器的默认线程数目"></a>Springboot自己集成的Tomcat服务器的默认线程数目</h2><p>因为默认只有是个线程数，所以当多个请求打到一个对外服务的接口的时候，就会有很多的资源分配到这个接口上，其他的对外接口的资源分配就不会很平均。所以一个微服务会将更多的资源分配到需要资源的位置上，这样的话，就会导致这个微服务的所有对外接口都会多少变慢，而假如此时消费者访问这个微服务那么就不会得到满意的反馈。</p>
<p>springboot继承的tomcat的线程数和调优。	</p>
<p><a href="https://blog.csdn.net/qq_31086797/article/details/110523079">(40条消息) springboot内置tomcat调优并发线程数_CRUD的W的博客-CSDN博客_springboot tomcat线程池</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>首先再pom.xml引入</p>
<p>然后application.yaml设置支持Hystrix</p>
<p>主启动类添加@EnableHystrix</p>
<h2 id="Hystrix的抽象类-HystrixCommandProperties-为属性集合"><a href="#Hystrix的抽象类-HystrixCommandProperties-为属性集合" class="headerlink" title="Hystrix的抽象类 HystrixCommandProperties 为属性集合"></a>Hystrix的抽象类 HystrixCommandProperties 为属性集合</h2><h2 id="服务降级："><a href="#服务降级：" class="headerlink" title="服务降级："></a>服务降级：</h2><p><strong>出现服务降级的几种情况：</strong></p>
<p>1）<strong>超时降级</strong>：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</p>
<p>2）<strong>失败次数降级</strong>：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</p>
<p>3）<strong>故障降级</strong>：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</p>
<p>4）<strong>限流降级</strong>：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<h3 id="局部降级"><a href="#局部降级" class="headerlink" title="局部降级"></a>局部降级</h3><p>首先对于以上可能出现问题的单个服务，我们在提供服务的接口上进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//在Mapping的下面进行指定fallbackMethod 既有哪个方法提供降级的服务 commandProperties可以进行线程超时时间等的设置 更多设置请参考代码下方文档</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处是提供服务降级的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/acmman/article/details/100595666">(40条消息) 【Spring Cloud总结】18.Hystrix的commandProperties配置_光仔December的博客-CSDN博客</a></p>
<p>既然在业务层这样设置了 那么在主启动类就应该添加支持其的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure>

<p>关于@EnableHystrix注解与@EnableCircuitBreaker的区别：需要在服务启动类加入@EnableHystrix注解即可，无须增加@EnableCircuitBreaker注解，本身**@EnableHystrix注解已经涵盖了EnableCircuitBreaker的功能。**</p>
<h3 id="全局降级"><a href="#全局降级" class="headerlink" title="全局降级"></a>全局降级</h3><p>1.如果都使用以上的方法，将所有提供服务的接口都进行服务降级保护,那未免太过于冗余和臃肿以及繁琐，我们就可以设置全局的服务降级的方法。</p>
<p>在业务类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span></span><br></pre></td></tr></table></figure>

<p>再将其中可能出现问题的接口添加@HystrixCommand注解</p>
<p>其中注解指定的方法就是在这个业务接口实现方法出现问题的时候，指定的默认的一个业务类中的处理方法。</p>
<p>把具体的实现举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">payment_Global_FallbackMethod</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是当服务端整个宕机后，我们应该在客户端就进行处理。</p>
<p>2.因为在客户端，我们经常的使用的是将服务端的对外方法创建一个接口，然后将这个接口添加Feign的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-provider-hystrix-payment&quot;,fallback = PaymentFallbackService.class)</span></span><br></pre></td></tr></table></figure>

<p>代表着在客户端这个接口中定义的方法应该在哪个集群中寻找@RequestMapping()接口地址相同的服务方法，既绝大多数的客户端的业务实现都来自于这个接口的定义的方法，所以我们实现这个接口的所有方法，将其实现方法使用@Componet注解添加到SpringBoot中，之后在接口处添加，fallback &#x3D; 实现类类名.class，再依次实现其中的方法，便是当服务端宕机后的实现了。</p>
<h2 id="服务熔断："><a href="#服务熔断：" class="headerlink" title="服务熔断："></a>服务熔断：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNumber</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> + id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于@HystrixCommand注解内的配置 除了第一个外 总体意味着：再在某个固定的时间段（时间窗口期）内，当请求次数为10的时候，失败的请求次数（失败率）占比高达60%的时候，进行服务的熔断。</p>
<h3 id="服务熔断的三种状态"><a href="#服务熔断的三种状态" class="headerlink" title="服务熔断的三种状态"></a>服务熔断的三种状态</h3><img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628172737991.png" class="" title="image-20220628172737991">

<p>熔断打开：</p>
<p>熔断关闭：不会对微服务进行熔断</p>
<p>熔断半开：</p>
<h2 id="搭建服务监控"><a href="#搭建服务监控" class="headerlink" title="搭建服务监控"></a>搭建服务监控</h2><p> 创建一个新的微服务，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>被监控的服务应该添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>被监控的主启动类添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>启动，输入需要被监控的地址参数：</p>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628182404648.png" class="" title="image-20220628182404648">

<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628182532190.png" class="" title="image-20220628182532190">

<h1 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h1><p><a href="https://spring.io/projects/spring-cloud-gateway">Spring Cloud Gateway</a></p>
<p>服务网关方面 我们有zull和gateway两种选择 选择gateway </p>
<p>内部组件：Spring WebFlux+netty  &#x2F;&#x2F;TODO</p>
<p>Gateway实现了负载均衡<a href="https://blog.csdn.net/qq_25861361/article/details/89875942">(42条消息) GateWay负载均衡_神绮H亚里亚的博客-CSDN博客_gateway负载均衡</a></p>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220629090424236.png" class="" title="image-20220629090424236">

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加该依赖后 应该移除以下两个依赖，否则报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p><strong>application.yaml的路由相关配置：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,zzyy</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br></pre></td></tr></table></figure>



<h2 id="路由routes"><a href="#路由routes" class="headerlink" title="路由routes:"></a>路由routes:</h2><h2 id="断言predicate"><a href="#断言predicate" class="headerlink" title="断言predicate"></a>断言predicate</h2><p>是一个针对http协议的封装使用 		</p>
<h3 id="测试的curl命令"><a href="#测试的curl命令" class="headerlink" title="测试的curl命令"></a>测试的curl命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9527/payment/lb --cookie &quot;username=zzyy&quot;//本次测试使用语句</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/07c4dddae43a">curl 命令详解 - 简书 (jianshu.com)</a></p>
<p>如果不满足断言条件：返回编码404</p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>虽然SpringCould提供了很多过滤器 但是通常我们都自己定义过滤器的业务逻辑</p>
<p>创建filter业务类 实现GlobalFilter,Ordered接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***********come in MyLogGateWayFilter:  &quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//      判断http请求是否带有uname的一个key 既是否带有这样的一个参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;</span>);</span><br><span class="line"><span class="comment">//            设置为不可接受的http状态码</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代表优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多过滤条件通过ServerWebExchange的API获取&#x2F;&#x2F;TODO</p>
<h1 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h1><p>在分布式微服务系统中，几乎所有服务的运行都离不开配置文件的支持，这些配置文件通常由各个服务自行管理，以 properties 或 yml 格式保存在各个微服务的类路径下，例如 application.properties 或 application.yml 等。</p>
<p>这种将配置文件散落在各个服务中的管理方式，存在以下问题：</p>
<ul>
<li><strong>管理难度大</strong>：配置文件散落在各个微服务中，难以管理。</li>
<li><strong>安全性低</strong>：配置跟随源代码保存在代码库中，容易造成配置泄漏。</li>
<li><strong>时效性差</strong>：微服务中的配置修改后，必须重启服务，否则无法生效。</li>
<li><strong>局限性明显</strong>：无法支持动态调整，例如日志开关、功能开关。</li>
</ul>
<p>简单点说就是，Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</p>
<p>Spring Cloud <strong>Config 包含服务端和客户端</strong>以下两个部分：</p>
<ul>
<li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li>
<li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li>
</ul>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220630092926542.png" class="" title="image-20220630092926542">

<h3 id="通过Config客户端访问Config服务端"><a href="#通过Config客户端访问Config服务端" class="headerlink" title="通过Config客户端访问Config服务端"></a>通过Config客户端访问Config服务端</h3><p>Pom文件：</p>
<p>1.服务端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        图形化监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.客户端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        图形化监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/shuaiqiwudi/springcloud-config</span>  <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">####读取分支 如果url不指定分支进行配置的访问 浏览器默认使用master</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>此时如果单独启动3344服务端，尝试访问端口号，会获取到仓库里配置文件的端口号。</p>
<p>访问的url：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:3344/main/config-dev.yaml</span><br><span class="line">		端口号/分支名称/name/profile</span><br></pre></td></tr></table></figure>

<p>当然，<strong>不指定分支的时候，默认是master分支，但现在的github上默认是main分支</strong>					</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过服务调用仓库进行查看 既为config的服务端</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigCenterMain3344</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Config客户端</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3355</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意的是，Config的客户端的配置文件不再是application.yaml,而是<strong>bootstrap.yml</strong></p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>当修改仓库的配置信息的时候 ，服务端相关配置的获取是随着仓库的文件而修改的，但客户端通过服务端获取到的配置不再是更新的了，所以我们需要将客户端的配置信息设置为动态获取的。</p>
<p>1、首先在pom文件修改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点 客户端动态获取</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.在业务逻辑的类上添加注解@RefreshScope</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/serverPort&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServerPort</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时仍然不能完成客户端的动态刷新 需要发送一个post请求到3355客户端</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://localhost:<span class="number">3355</span>/actuator/refresh&quot;</span><br></pre></td></tr></table></figure>

<p>然后再次通过客户端获取成功。（idea的例子是获取到本地bootstrap.yaml的端口号)</p>
<p>这样获取就不再需要重启客户端。</p>
<p>需要仔细再次阅读的：</p>
<p><a href="https://blog.csdn.net/li1669852599/article/details/120665809">(40条消息) 微服务架构 | Hystrix的资源隔离策略该如何选择？_码农架构的博客-CSDN博客</a></p>
<p>巨人的肩膀：</p>
<p>[服务降级与服务熔断区别 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/341939685#:~:text=%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E6%98%AF%E5%BA%94%E5%AF%B9%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E3%80%82">https://zhuanlan.zhihu.com/p/341939685#:~:text=服务熔断是应对雪崩效应的一种微服务链路保护机制。</a> 例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。 同样，在微服务架构中，熔断机制也是起着类似的作用。 当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。,当检测到该节点微服务调用响应正常后，恢复调用链路。 服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。 在Spring Cloud框架里，熔断机制通过Hystrix实现。 Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。)</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/05/28/SpringBoot/</url>
    <content><![CDATA[<p>官网：<a href="https://spring.io/projects/spring-boot">Spring Boot</a></p>
<img src="/2022/05/28/SpringBoot/v2-704d04346a5e35b9bd3a4923732a589d_180x120.jpg" class="" title="查看源图像">

<h1 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h1><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<p>Spring Boot 集成了大量常用的第三方库配置，Spring Boot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p>
<span id="more"></span>

<h1 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h1><p>Spring Boot 项目创建完成后，即使不进行任何的配置，也能够顺利地运行，这都要归功于 Spring Boot 的自动化配置。</p>
<p>Spring Boot 默认使用 application.properties 或 application.yml 作为其全局配置文件，我们可以在该配置文件中对各种自动配置属性（server.port、logging.level.* 、spring.config.active.no-profile 等等）进行修改，并使之生效，那么您有没有想过这些属性是否有据可依呢？答案是肯定的。</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#application-properties">Spring Boot 官方文档：常见应用属性</a>中对所有的配置属性都进行了列举和解释，我们可以根据官方文档对 Spring Boot 进行配置，但 Spring Boot 中的配置属性数量庞大，仅仅依靠官方文档进行配置也十分麻烦。我们只有了解了 Spring Boot 自动配置的原理，才能更加轻松熟练地对 Spirng Boot 进行配置。</p>
<h2 id="Spring-Factories-机制"><a href="#Spring-Factories-机制" class="headerlink" title="Spring Factories 机制"></a>Spring Factories 机制</h2><p>Spring Boot 的自动配置是基于 Spring Factories 机制实现的。</p>
<p>Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。</p>
<p><a href="https://www.jianshu.com/p/00e49c607fa1">Spring Factories - 简书 (jianshu.com)</a></p>
<h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key&#x3D;vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Factories-实现原理"><a href="#Spring-Factories-实现原理" class="headerlink" title="Spring Factories 实现原理"></a>Spring Factories 实现原理</h3><p>spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF&#x2F;spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><T> List<T></td>
<td>loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)</td>
<td>静态方法； 根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。</td>
</tr>
<tr>
<td>List<String></td>
<td>loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</td>
<td>公共静态方法； 根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表</td>
</tr>
</tbody></table>
<p>以上两个方法的关键都是从指定的 ClassLoader 中获取 spring.factories 文件，并解析得到类名列表。</p>
<p>loadFactories() 方法能够获取指定接口的实现类对象</p>
<p>loadFactoryNames() 方法能够根据接口获取其实现类类名的集合。</p>
<h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h3><p>所有 Spring Boot 项目的主启动程序类上都使用了一个 @SpringBootApplication 注解，该注解是 Spring Boot 中最重要的注解之一 ，也是 Spring Boot 实现自动化配置的关键。 </p>
<p>@SpringBootApplication 是一个组合元注解，其主要包含两个注解：@SpringBootConfiguration 和 @EnableAutoConfiguration，其中 @EnableAutoConfiguration 注解是 SpringBoot 自动化配置的核心所在。</p>
<img src="/2022/05/28/SpringBoot/image-20220529152015019.png" class="" title="image-20220529152015019">

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@<strong>ComponentScan</strong></h3><p>@ComponentScan主要就是定义<strong>扫描的路径</strong>从中找出标识了<strong>需要装配</strong>的类自动装配到spring的bean容器中</p>
<p>@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个<strong>共同的注解@Component</strong></p>
<img src="/2022/05/28/SpringBoot/image-20220529153202827.png" class="" title="image-20220529153202827">



<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>@ConfigurationProperties 注解的作用，是将这个类的所有属性与配置文件中相关的配置进行绑定，以便于获取或修改配置，但是 @ConfigurationProperties 功能是由容器提供的，被它注解的类必须是容器中的一个组件，否则该功能就无法使用。而 @EnableConfigurationProperties 注解的作用正是将指定的类以组件的形式注入到 IOC 容器中，并开启其 @ConfigurationProperties 功能。因此，@ConfigurationProperties + @EnableConfigurationProperties 组合使用，便可以为 XxxProperties 类实现配置绑定功能。</p>
<h2 id="自动配置的生效和修改"><a href="#自动配置的生效和修改" class="headerlink" title="自动配置的生效和修改"></a>自动配置的生效和修改</h2><p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 Spring Boot 中以 @Conditional 派生注解的形式体现，如下表。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>生效条件</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>应用使用指定的 Java 版本时生效</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足指定的 SpEL 表达式时生效</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>不存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定属性存在指定的值时生效</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下存在指定的资源文件时生效</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前应用是 web 应用时生效</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前应用不是 web 应用生效</td>
</tr>
</tbody></table>
<p><a href="http://c.biancheng.net/spring_boot/auto-config.html">Spring Boot自动配置原理 (biancheng.net)</a></p>
<h1 id="Spring-boot-starter-web（Web启动器）"><a href="#Spring-boot-starter-web（Web启动器）" class="headerlink" title="Spring-boot-starter-web（Web启动器）"></a>Spring-boot-starter-web（Web启动器）</h1><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。</p>
<p>Spring Boot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 Spring MVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。</p>
<p>只要我们在 Spring Boot 项目中的 pom.xml 中引入了 spring-boot-starter-web ，即使不进行任何配置，也可以直接使用 Spring MVC 进行 Web 开发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Spring-Boot拦截器"><a href="#Spring-Boot拦截器" class="headerlink" title="Spring Boot拦截器"></a>Spring Boot拦截器</h1><p><a href="https://www.cnblogs.com/ye-hcj/p/9614109.html">springboot成神之——监视器 - qz奔跑的马 - 博客园 (cnblogs.com)</a></p>
<h1 id="Spring-Boot-中的监视器"><a href="#Spring-Boot-中的监视器" class="headerlink" title="Spring Boot 中的监视器"></a><strong>Spring Boot</strong> <strong>中的监视器</strong></h1><p><strong>Spring Boot中的监视器是什么？</strong></p>
<p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>
<h1 id="Spring-Boot-热加载"><a href="#Spring-Boot-热加载" class="headerlink" title="Spring Boot 热加载"></a><strong>Spring Boot</strong> 热加载</h1><p>修改代码后不需要重启服务， 自动加载修改的内容。  修改内容后restart加载器加载会变动的资源。 那些第三方的包不会被重新加载， 所以可以提高重启速度</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是JavaConfig？"><a href="#什么是JavaConfig？" class="headerlink" title="什么是JavaConfig？"></a><strong>什么是JavaConfig？</strong></h2><p>Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：</p>
<p>面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。</p>
<p>减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。</p>
<p>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/05/28/SpringMVC/</url>
    <content><![CDATA[<img src="/2022/05/28/SpringMVC/image-20220528102032212.png" class="" title="image-20220528102032212">

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><span id="more"></span>

<h2 id="什么是SpringMVC？"><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h2><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>SpringMVC属于Spring 的一部分</p>
<p><img src="https://img-blog.csdnimg.cn/20190328153606755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="SpringMVC的核心架构："><a href="#SpringMVC的核心架构：" class="headerlink" title="SpringMVC的核心架构："></a>SpringMVC的核心架构：</h2><p><img src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>具体流程：</p>
<p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
<p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p>
<p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>
<p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>
<p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p>
<p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p>
<p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>
<img src="/2022/05/28/SpringMVC/wps1.jpg" class="" title="img">

<h2 id="组件分析"><a href="#组件分析" class="headerlink" title="组件分析"></a>组件分析</h2><ol>
<li><p><strong>前端控制器：DispatcherServlet</strong></p>
<p> 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
</li>
<li><p><strong>处理器映射器：HandlerMapping HandlerMapping</strong></p>
<p>负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。        </p>
</li>
<li><p><strong>处理器适配器：HandlerAdapter</strong>     </p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。        </p>
</li>
<li><p><strong>处理器：Handler</strong>     </p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。        </p>
</li>
<li><p><strong>视图解析器：View Resolver</strong>     </p>
<p> View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即 具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>视图：View</strong><br>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最 常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程 序员根据业务需求开发具体的页面</p>
</li>
</ol>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p> Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。将拦截器按一定的顺序联结成<strong>一条链</strong>，这条链称为<strong>拦截器链（Interceptor Chain）</strong>。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前<strong>定义的顺序被调用</strong>。拦截器也是AOP思想的具体实现。</p>
<p>拦截器的方法声明：</p>
<p><img src="https://img-blog.csdnimg.cn/4561be39258343c3acf60145af40f4dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="自定义拦截器进行资源拦截"><a href="#自定义拦截器进行资源拦截" class="headerlink" title="自定义拦截器进行资源拦截"></a>自定义拦截器进行资源拦截</h3><p>​        <em>① 创建拦截器类实现HandlerInterceptor接口</em></p>
<p>​        <em>② 配置拦截器</em></p>
<p>​        <em>③ 测试拦截器的拦截效果</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在目标方法执行之后 视图对象返回之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">         <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">         <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h2><h3 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h3><p>​        系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后 者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<pre><code>    系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交 由异常处理器进行异常处理，如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/d4d82dfe8933400d99919f904d5d56bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h3><p>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver<br>实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p>
<h3 id="简单异常处理器SimpleMappingExceptionResolver"><a href="#简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="简单异常处理器SimpleMappingExceptionResolver"></a>简单异常处理器SimpleMappingExceptionResolver</h3><p>  SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p>
<p><img src="https://img-blog.csdnimg.cn/b61441bc5b3a4d12933d910d07bc3de9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<img src="/2022/05/28/SpringMVC/70.png" class="" title="img">

<p><a href="https://blog.csdn.net/litianxiang_kaola/article/details/79169148">(32条消息) SpringMVC框架理解_椰子Tyshawn的博客-CSDN博客_springmvc</a></p>
<p><a href="https://blog.csdn.net/qq_58168493/article/details/122634493">(32条消息) 黑马程序员–SpringMVC详细教程_JAVA成神的博客-CSDN博客_springmvc教程</a></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>equals()与HashCode()的爱恨情仇</title>
    <url>/2022/05/12/equals-%E4%B8%8EHashCode%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
    <content><![CDATA[<h4 id="‘-x3D-x3D-’和equals"><a href="#‘-x3D-x3D-’和equals" class="headerlink" title="‘&#x3D;&#x3D;’和equals"></a>‘&#x3D;&#x3D;’和equals</h4><p>“&#x3D;&#x3D;”运算符用来比较两个变量的值是否相等。也就是说，该运算符用于比较变量对应的内存中所存储的数值是否相同。</p>
<p>对于基本数据类而言，可以直接使用“&#x3D;&#x3D;”运算符来比较其对应的值是否相等。但是对于引用类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure>

<p>此时的两个引用变量所对应内存中存储的数值就是对象占用的那块内存的首地址。如果要比较两个对象的是否是同一个对象，</p>
<p>则可以使用”&#x3D;&#x3D;“，如果要比较两个对象的内容是否相同，则不可以使用”&#x3D;&#x3D;“实现了。</p>
<p>equals是Object类提供的方法之一。每一个Java类都集成自Object类，所以每一个对象都具有equals这个方法。</p>
<p>相比“&#x3D;&#x3D;”运算符，equals(Object)方法的特殊之处就在于它可以被覆盖，所以可以通过覆盖的方法让它不是比较引用而是比较数据内容。</p>
<p>那么equals()是如何比较引用类型的内容的？</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//		generate生成的equals和hashcode</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (Human) o;</span><br><span class="line">            <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= human.age &amp;&amp;</span><br><span class="line">                    Objects.equals(name, human.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashCode和equals"><a href="#HashCode和equals" class="headerlink" title="HashCode和equals"></a>HashCode和equals</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数.</p>
<h4 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals() 的相关规定"></a><strong>hashCode()<strong>与</strong>equals()</strong> <strong>的相关规定</strong></h4><p>如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的</p>
<h4 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h4><p>第一种 不会创建“类对应的散列表”<br> 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”没有关系。<br> 这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p>
<p>第二种 会创建“类对应的散列表”<br> 这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：<br> 1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br> 这里的相等是指，通过equals()比较两个对象时返回true。<br> 2)、如果两个对象hashCode()相等，它们并不一定相等。<br> 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。<br> 此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/05/16/git/</url>
    <content><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><img src="/2022/05/16/git/image-20220516150930144.png" class="" title="image-20220516150930144">

<ul>
<li><p>workspace：工作区</p>
</li>
<li><p>staging area：暂存区&#x2F;缓存区</p>
</li>
<li><p>local repository：版本库或本地仓库</p>
</li>
<li><p>remote repository：远程仓库</p>
<span id="more"></span></li>
</ul>
<p>合作开发第一个项目的时候 就感觉到git的强大 同时也被git上了一课 多版本的来回混合 以及多个操作 搞得有点乱 从空间和操作命令上来结合了解以下git到底如何使用 执行命令后哪里的代码跑到哪里了？</p>
<p>首先要初始化一个仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git add .    </span><br><span class="line">$ git commit  </span><br></pre></td></tr></table></figure>

<p>创建分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch (branchname) //不加名字 为查看分支</span><br></pre></td></tr></table></figure>

<p>切换分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure>

<p>合并分支：</p>
<p>需要先切换到主分支下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge (想要合并的分支)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Write blog using markdown01</title>
    <url>/2022/05/07/Write-blog-using-markdown01/</url>
    <content><![CDATA[<h4 id="预览界面"><a href="#预览界面" class="headerlink" title="预览界面"></a>预览界面</h4><p><strong>hexo g</strong><br><strong>hexo s</strong></p>
<h4 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h4><p><em>hexo clean</em><br><em>hexo g</em><br><em>hexo d</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[md文档教程]<a href="https://www.imooc.com/wiki/markdownlesson/markdownlink.html">14 Markdown 超链接丨慕课网教程 (imooc.com)</a></p>
<p><a href="https://www.githubs.cloud/#/trend">github中文社区 (githubs.cloud)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2022/05/26/Spring/</url>
    <content><![CDATA[<p>[Spring官网]<a href="https://spring.io/">Spring | Home</a></p>
<img src="/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg" class="" title="v2-f35943a6d87c5f9f10f45eee4941deb3_720w">

<h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h1><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的大小。	然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>​	<strong>简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。</strong></p>
<span id="more"></span>

<h1 id="Spring的核心组件"><a href="#Spring的核心组件" class="headerlink" title="Spring的核心组件"></a>Spring的核心组件</h1><img src="/2022/05/26/Spring/image-20220526175028291-16536637559683.png" class="" title="image-20220526175028291">

<h1 id="Spring大致加载流程"><a href="#Spring大致加载流程" class="headerlink" title="Spring大致加载流程"></a>Spring大致加载流程</h1><p><img src="file:///C:\Users\张淞瑞\AppData\Local\Temp\ksohtml6968\wps1.jpg" alt="img"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Spring是一个生态圈，需要的是新的拓展功能不停的进行完善，所以我们可以通过BeanFactoryPostProcesser和BeanPostProcesser进行Spring功能的拓展。所以 Spring最核心的一个思想就是<strong>拓展</strong>。</p>
<h2 id="BeanFactoryPostProcesser："><a href="#BeanFactoryPostProcesser：" class="headerlink" title="BeanFactoryPostProcesser："></a>BeanFactoryPostProcesser：</h2><p><strong>功能：允许自定义对ApplicationContext的 bean definitions 进行修饰，扩展功能。</strong> </p>
<p>BeanFactoryPostProcessor是实现spring容器功能扩展的重要接口，例如修改bean属性值，实现bean动态代理等。很多框架都是通过此接口实现对spring容器的扩展，例如mybatis与spring集成时，只定义了mapper接口，无实现类，但spring却可以完成自动注入。</p>
<p>BeanFactoryPostProcessor的主体是BeanFactory，并且该接口中只定义了一个方法，其将会在ApplicationContext内部的BeanFactory加载完bean的定义后，但是在对应的bean实例化之前进行回调。所以通常我们可以通过实现该接口来对实例化之前的bean定义进行修改。</p>
<p>BeanFactoryPostProcessor可以对bean的定义（<strong>配置元数据</strong>）进行处理。也就是说，<strong>Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其它的bean之前读取配置元数据，并有可能修改它</strong>。如果你愿意，你可以配置多个BeanFactoryPostProcessor。你还能通过设置’order’属性来控制BeanFactoryPostProcessor的<strong>执行次序</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是BeanFactoryPostProcessor接口的定义，其中只定义了一个方法。接下来我们来定义一个自己的BeanFactoryPostProcessor，用以输出当前bean容器中bean定义的基本信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">			ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">//获取所有的beanName</span></span><br><span class="line">		String beanNames[] = beanFactory.getBeanDefinitionNames();</span><br><span class="line">		<span class="keyword">if</span> (beanNames != <span class="literal">null</span> &amp;&amp; beanNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">				<span class="comment">//获取对应的bean定义</span></span><br><span class="line">				beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">				<span class="built_in">this</span>.printBeanDef(beanName, beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印bean定义的基本信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDef</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printBeanDef</span><span class="params">(String beanName, BeanDefinition beanDef)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">defStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;beanName: &quot;</span>).append(beanName);</span><br><span class="line">		defStr.append(<span class="string">&quot;, className: &quot;</span>).append(beanDef.getBeanClassName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, scope: &quot;</span>).append(beanDef.getScope());</span><br><span class="line">		defStr.append(<span class="string">&quot;, parent: &quot;</span>).append(beanDef.getParentName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryBean: &quot;</span>).append(beanDef.getFactoryBeanName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryMethod: &quot;</span>).append(beanDef.getFactoryMethodName());</span><br><span class="line">		System.out.println(defStr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<strong>BeanFactoryPostProcessor是针对于bean容器的</strong>，在调用它时，BeanFactory只加载了bean的定义，<strong>还没有对它们进行实例化</strong>，所以我们可以通过对BeanFactory的处理来达到影响之后实例化bean的效果。跟BeanPostProcessor一样，ApplicationContext也能自动检测和调用容器中的BeanFactoryPostProcessor。 </p>
<h2 id="BeanPostProcesser："><a href="#BeanPostProcesser：" class="headerlink" title="BeanPostProcesser："></a>BeanPostProcesser：</h2><p>BeanPostProcessor 可以在 spring 容器实例化 bean 之后，在执行 bean 的初始化方法前后，添加一些自己的处理逻辑。 这里说的初始化方法，指的是以下两种：</p>
<ol>
<li>bean 实现 了 InitializingBean 接口，对应的方法为 afterPropertiesSet 。</li>
<li>在 XML 文件中定义 bean 的时候，<bean>标签有个属性叫做 init-method，来指定初始化方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125; </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.    </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务  </span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125;   </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.       </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入、初始化完毕时执行  </span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个接口的某个实现类被注册到某个容器，<strong>那么该容器的每个受管Bean在调用初始化方法的前后，都会获得该接口实现类的一个回调</strong>。容器调用接口定义的方法时会将该受管Bean的实例和名字通过参数传入方法，经过处理后通过方法的返回值返回给容器。</p>
<p>要使用BeanPostProcessor回调，就必须先在容器中注册实现该接口的类，那么如何注册呢？BeanFactory和ApplicationContext容器的注册方式不大一样：</p>
<ul>
<li>若使用BeanFactory，则必须要显示的调用其addBeanPostProcessor()方法进行注册，参数为BeanPostProcessor实现类的实例；</li>
<li>如果是使用ApplicationContext，那么容器会在配置文件在中自动寻找实现了BeanPostProcessor接口的Bean，然后自动注册，我们要做的只是配置一个BeanPostProcessor实现类的Bean就可以了。</li>
</ul>
<p>假如我们使用了多个的BeanPostProcessor的实现类，那么如何确定处理顺序呢？其实只要实现Ordered接口，设置order属性就可以很轻松的确定不同实现类的处理顺序了。</p>
<h2 id="BeanFactoryPostProcessor和BeanPostProcessor"><a href="#BeanFactoryPostProcessor和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcessor和BeanPostProcessor"></a>BeanFactoryPostProcessor和BeanPostProcessor</h2><p>相同点：</p>
<p>1.eanFactoryPostProcessor和BeanPostProcessor都是<strong>spring初始化bean的扩展点</strong>。两个接口非常相似。</p>
<p>2.二者都可以被ApplicationContext自动检测到。</p>
<p>不同点：</p>
<p><strong>BeanFactoryPostProcessor 作用于 bean 实例化之前，读取配置元数据，并且可以修改；而 BeanPostProcessor 作用于 bean 的实例化过程中，然后可以改变 bean 实例（例如从配置元数据创建的对象）。</strong></p>
<h2 id="执行的过程如下"><a href="#执行的过程如下" class="headerlink" title="执行的过程如下:"></a><strong>执行的过程如下:</strong></h2><p>1.ResouceLoader加载配置信息<br>2.解析配置信息，生成一个一个的BeanDefintion<br>3.BeanDefintion由BeanDefintionRegistry管理起来<br>4.BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)<br>5.实例化Bean<br>6.如果该Bean配置&#x2F;实现了InstantiationAwareBean，则调用对应的方法<br>7.使用BeanWarpper来完成对象之间的属性配置(依赖)<br>8.如果该Bean配置&#x2F;实现了Aware接口，则调用对应的方法<br>9.如果该Bean配置了BeanPostProcessor的before方法，则调用<br>10.如果该Bean配置了init-method或者实现InstantiationBean，则调用对应的方法<br>11.如果该Bean配置了BeanPostProcessor的after方法，则调用<br>12.将对象放入到HashMap中<br>13.最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</p>
<h1 id="Spring浅看"><a href="#Spring浅看" class="headerlink" title="Spring浅看"></a>Spring浅看</h1><img src="/2022/05/26/Spring/image-20220526175017424-16536637765225-16536638098216.png" class="" title="image-20220526175017424-16536637765225">

<img src="/2022/05/26/Spring/image-20220526174932412-16536638610858.png" class="" title="image-20220526174932412">

<img src="/2022/05/26/Spring/image-20220526175457607-16536638760849.png" class="" title="image-20220526175457607">

<p>bean注入与装配的的方式有很多种，可以通过xml，get, set方式，构造函数或者注解等。简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式，让项目阅读和开发起来更加方便。</p>
<img src="/2022/05/26/Spring/image-20220526175600355-165366388819310.png" class="" title="image-20220526175600355">

<img src="/2022/05/26/Spring/image-20220526175612242-165366391229911.png" class="" title="image-20220526175612242">

<p>它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。</p>
<p>Spring框架的开发不是为了替代现有的优秀第三方框架，而是通过集成的方式把它们都连接起来。下面总结了一些常集成的优秀框架。</p>
<img src="/2022/05/26/Spring/image-20220526175650919-165366393348713.png" class="" title="image-20220526175650919">

<h1 id="SpringIOC-和-Spring-AOP"><a href="#SpringIOC-和-Spring-AOP" class="headerlink" title="SpringIOC 和 Spring AOP"></a>SpringIOC 和 Spring AOP</h1><p>作为Spring框架最核心的两个“功能” ，需要完全理解IOC和AOP，才能真正灵活正确的使用Spring框架 ，而Spring框架作为Spring全家桶系列的最基础的使用框架，它的最核心功能就是—拓展， 让这个框架的功能越来越丰富，在基石上创建最实用的功能。</p>
<p>spring的IoC容器是spring的核心，spring AOP是spring框架的重要组成部分。</p>
<h2 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h2><p>在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此被称作控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。</p>
<p>IOC:控制反转也叫依赖注入。利用了工厂模式<br>将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p>
<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p>面向切面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使IoC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。</p>
<p>AOP:面向切面编程。（Aspect-Oriented Programming）<br>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br><strong>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面</strong>，然后注入到目标对象（具体业务逻辑）中去。</p>
<h2 id="Spring中beanFactory和ApplicationContext的联系和区别"><a href="#Spring中beanFactory和ApplicationContext的联系和区别" class="headerlink" title="Spring中beanFactory和ApplicationContext的联系和区别"></a><strong>Spring中beanFactory和ApplicationContext的联系和区别</strong></h2><p>声明二者之间的关系：</p>
<p>早期的电脑性能低，内存小，所以spring容器的容量不足，不能讲所以的对象全部创建好放入容器，所以使用的是BeanFactory，需要某个对象时，再进行创建，随着电脑硬件的发展，内存越来越大，所以spring框架引入了ApplicationContext，将所有的对象都创建好，放入容器，使用哪个对象，从容器中取得即可。</p>
<p><strong>一、 BeanFactory</strong></p>
<p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。也是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>
<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。</p>
<p>BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。来看一下BeanFactory的基本类体系结构（接口为主）：</p>
<img src="/2022/05/26/Spring/image-20220528103213112.png" class="" title="image-20220528103213112">

<p>1、BeanFactory作为一个主接口不继承任何接口，暂且称为<strong>一级接口</strong>。<br>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为<strong>二级接口</strong>。<br>3、ConfigurableBeanFactory可以被称为<strong>三级接口</strong>，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为<strong>四级接口</strong>。<br>　　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。</p>
<p>BeanFactory接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111158974.png" class="" title="image-20220528111158974">

<details> 
    <summary><font color=blue>点击查看BeanFactory接口源码</font></summary> 
    <pre><code>   
/**
 *The root interface for accessing a Spring bean container.
 * This is the basic client view of a bean container;
 * further interfaces such as &#123;@link ListableBeanFactory&#125; and
 * &#123;@link org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;
 * are available for specific purposes.
 *
 * This interface is implemented by objects that hold a number of bean definitions,
 * each uniquely identified by a String name. Depending on the bean definition,
 * the factory will return either an independent instance of a contained object
 * (the Prototype design pattern), or a single shared instance (a superior
 * alternative to the Singleton design pattern, in which the instance is a
 * singleton in the scope of the factory). Which type of instance will be returned
 * depends on the bean factory configuration: the API is the same. Since Spring
 * 2.0, further scopes are available depending on the concrete application
 * context (e.g. "request" and "session" scopes in a web environment).
 *
 * Bean factory implementations should support the standard bean lifecycle interfaces
 * as far as possible. The full set of initialization methods and their standard order is:
 * <ol>
 * <li>BeanNameAware's &#123;@code setBeanName&#125;
 * <li>BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;
 * <li>BeanFactoryAware's &#123;@code setBeanFactory&#125;
 * <li>EnvironmentAware's &#123;@code setEnvironment&#125;
 * <li>EmbeddedValueResolverAware's &#123;@code setEmbeddedValueResolver&#125;
 * <li>ResourceLoaderAware's &#123;@code setResourceLoader&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125;
 * (only applicable when running in an application context)
 * <li>MessageSourceAware's &#123;@code setMessageSource&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationContextAware's &#123;@code setApplicationContext&#125;
 * (only applicable when running in an application context)
 * <li>ServletContextAware's &#123;@code setServletContext&#125;
 * (only applicable when running in a web application context)
 * <li>&#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors
 * <li>InitializingBean's &#123;@code afterPropertiesSet&#125;
 * <li>a custom init-method definition
 * <li>&#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors
 * </ol>
 *
 * On shutdown of a bean factory, the following lifecycle methods apply:
 * <ol>
 * <li>&#123;@code postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors
 * <li>DisposableBean's &#123;@code destroy&#125;
 * <li>a custom destroy-method definition
 * </ol>
 */
public interface BeanFactory &#123;
   /**
    * Used to dereference a &#123;@link FactoryBean&#125; instance and distinguish it from
        * beans <i>created</i> by the FactoryBean. For example, if the bean named
        * &#123;@code myJndiObject&#125; is a FactoryBean, getting &#123;@code &myJndiObject&#125;
        * will return the factory, not the instance returned by the factory.
        */
      String FACTORY_BEAN_PREFIX = "&";
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
        * This method allows a Spring BeanFactory to be used as a replacement for the
        * Singleton or Prototype design pattern. Callers may retain references to
        * returned objects in the case of Singleton beans.
        * Translates aliases back to the corresponding canonical bean name.
        * Will ask the parent factory if the bean cannot be found in this factory instance.
        * @param name the name of the bean to retrieve
        * @return an instance of the bean
        * @throws NoSuchBeanDefinitionException if there is no bean definition
        * with the specified name
        * @throws BeansException if the bean could not be obtained
        */
      Object getBean(String name) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Behaves the same as &#123;@link #getBean(String)&#125;, but provides a measure of type
    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the
    * required type. This means that ClassCastException can't be thrown on casting
    * the result correctly, as can happen with &#123;@link #getBean(String)&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to retrieve
    * @param requiredType type the bean must match. Can be an interface or superclass
    * of the actual class, or &#123;@code null&#125; for any match. For example, if the value
    * is &#123;@code Object.class&#125;, this method will succeed whatever the class of the
    * returned instance.
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanNotOfRequiredTypeException if the bean is not of the required type
    * @throws BeansException if the bean could not be created
    */
   <T> T getBean(String name, Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * @param name the name of the bean to retrieve
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 2.5
    */
   Object getBean(String name, Object... args) throws BeansException;
   /**
    * Return the bean instance that uniquely matches the given object type, if any.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @return an instance of the single bean matching the required type
    * @throws NoSuchBeanDefinitionException if no bean of the given type was found
    * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
    * @throws BeansException if the bean could not be created
    * @since 3.0
    * @see ListableBeanFactory
    */
   <T> T getBean(Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 4.1
    */
   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
   /**
    * Does this bean factory contain a bean definition or externally registered singleton
    * instance with the given name?
    * If the given name is an alias, it will be translated back to the corresponding
    * canonical bean name.
    * If this factory is hierarchical, will ask any parent factory if the bean cannot
    * be found in this factory instance.
    * If a bean definition or singleton instance matching the given name is found,
    * this method will return &#123;@code true&#125; whether the named bean definition is concrete
    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;@code true&#125;
    * return value from this method does not necessarily indicate that &#123;@link #getBean&#125;
    * will be able to obtain an instance for the same name.
    * @param name the name of the bean to query
    * @return whether a bean with the given name is present
    */
   boolean containsBean(String name);
   /**
    * Is this bean a shared singleton? That is, will &#123;@link #getBean&#125; always
    * return the same instance?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * independent instances. It indicates non-singleton instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isPrototype&#125; operation to explicitly
    * check for independent instances.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean corresponds to a singleton instance
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @see #getBean
    * @see #isPrototype
    */
   boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
   /**
    * Is this bean a prototype? That is, will &#123;@link #getBean&#125; always return
    * independent instances?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * a singleton object. It indicates non-independent instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isSingleton&#125; operation to explicitly
    * check for a shared singleton instance.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean will always deliver independent instances
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.3
    * @see #getBean
    * @see #isSingleton
    */
   boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code ResolvableType&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 4.2
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code Class&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.1
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Determine the type of the bean with the given name. More specifically,
    * determine the type of object that &#123;@link #getBean&#125; would return for the given name.
    * For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates,
    * as exposed by &#123;@link FactoryBean#getObjectType()&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return the type of the bean, or &#123;@code null&#125; if not determinable
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 1.1.2
    * @see #getBean
    * @see #isTypeMatch
    */
   Class<?> getType(String name) throws NoSuchBeanDefinitionException;
   /**
    * Return the aliases for the given bean name, if any.
    * All of those aliases point to the same bean when used in a &#123;@link #getBean&#125; call.
    * If the given name is an alias, the corresponding original bean name
    * and other aliases (if any) will be returned, with the original bean name
    * being the first element in the array.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the bean name to check for aliases
    * @return the aliases, or an empty array if none
    * @see #getBean
    */
   String[] getAliases(String name);
&#125;
    </code></pre> 
</details>

<p>总结：</p>
<p>1、4个获取实例的方法。getBean的重载方法。<br>2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<p>BeanFactory最常见的实现类为XmlBeanFactory，可以从classpath或文件系统等获取资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;classpath.xml&quot;</span>); </span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>



<p><strong>二、 ApplicationContext</strong></p>
<p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</p>
<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>
<p>（1）MessageSource, 提供国际化的消息访问<br>（2）资源访问，如URL和文件<br>（3）事件传播特性，即支持aop特性<br>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </p>
<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。</p>
<p><strong>ApplicationContext的继承关系图:</strong></p>
<img src="/2022/05/26/Spring/70.png" class="" title="img">

<p>ApplicationContext接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111124796.png" class="" title="image-20220528111124796">

<details> 
    <summary>
        <font color=blue>点击查看ApplicationContext源码</font>
    </summary> 
    <pre><code>  
 /**
 * Central interface to provide configuration for an application.
 * This is read-only while the application is running, but may be
 * reloaded if the implementation supports this.
 *
 *  An ApplicationContext provides:
 * <ul>
 * <li>Bean factory methods for accessing application components.
 * Inherited from &#123;@link org.springframework.beans.factory.ListableBeanFactory&#125;.
 * <li>The ability to load file resources in a generic fashion.
 * Inherited from the &#123;@link org.springframework.core.io.ResourceLoader&#125; interface.
 * <li>The ability to publish events to registered listeners.
 * Inherited from the &#123;@link ApplicationEventPublisher&#125; interface.
 * <li>The ability to resolve messages, supporting internationalization.
 * Inherited from the &#123;@link MessageSource&#125; interface.
 * <li>Inheritance from a parent context. Definitions in a descendant context
 * will always take priority. This means, for example, that a single parent
 * context can be used by an entire web application, while each servlet has
 * its own child context that is independent of that of any other servlet.
 * </ul>
 *
 *  In addition to standard &#123;@link org.springframework.beans.factory.BeanFactory&#125;
 * lifecycle capabilities, ApplicationContext implementations detect and invoke
 * &#123;@link ApplicationContextAware&#125; beans as well as &#123;@link ResourceLoaderAware&#125;,
 * &#123;@link ApplicationEventPublisherAware&#125; and &#123;@link MessageSourceAware&#125; beans.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see ConfigurableApplicationContext
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.core.io.ResourceLoader
 */
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;
/**
     * Return the unique id of this application context.
     * @return the unique id of the context, or &#123;@code null&#125; if none
     */
    String getId();
    /**
     * Return a name for the deployed application that this context belongs to.
     * @return a name for the deployed application, or the empty String by default
     */
    String getApplicationName();
    /**
     * Return a friendly name for this context.
     * @return a display name for this context (never &#123;@code null&#125;)
     */
    String getDisplayName();
    /**
     * Return the timestamp when this context was first loaded.
     * @return the timestamp (ms) when this context was first loaded
     */
    long getStartupDate();
    /**
     * Return the parent context, or &#123;@code null&#125; if there is no parent
     * and this is the root of the context hierarchy.
     * @return the parent context, or &#123;@code null&#125; if there is no parent
     */
    ApplicationContext getParent();
    /**
     * Expose AutowireCapableBeanFactory functionality for this context.
     *  This is not typically used by application code, except for the purpose of
     * initializing bean instances that live outside of the application context,
     * applying the Spring bean lifecycle (fully or partly) to them.
     *  Alternatively, the internal BeanFactory exposed by the
     * &#123;@link ConfigurableApplicationContext&#125; interface offers access to the
     * &#123;@link AutowireCapableBeanFactory&#125; interface too. The present method mainly
     * serves as a convenient, specific facility on the ApplicationContext interface.
     *  <b>NOTE: As of 4.2, this method will consistently throw IllegalStateException
     * after the application context has been closed.</b> In current Spring Framework
     * versions, only refreshable application contexts behave that way; as of 4.2,
     * all application context implementations will be required to comply.
     * @return the AutowireCapableBeanFactory for this context
     * @throws IllegalStateException if the context does not support the
     * &#123;@link AutowireCapableBeanFactory&#125; interface, or does not hold an
     * autowire-capable bean factory yet (e.g. if &#123;@code refresh()&#125; has
     * never been called), or if the context has been closed already
     * @see ConfigurableApplicationContext#refresh()
     * @see ConfigurableApplicationContext#getBeanFactory()
     */
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
&#125;
    </code></pre> 
</details>

<p><strong>三、二者区别</strong></p>
<p>不同点：Bean的加载时机</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身时检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。<br>应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相同点：</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）</p>
<h2 id="Spring用到的设计模式"><a href="#Spring用到的设计模式" class="headerlink" title="Spring用到的设计模式"></a>Spring用到的设计模式</h2><p>Spring作为一款及其优秀的框架，其代码的编写非常优秀，里面采用了大量的设计模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 这两个接口 来创建 bean 对象。<br>两者对比：</p>
<ul>
<li><p>BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li><p>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 由 BeanFactory 派生而来 ，提供了更多面向实际应用的功能 ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</p>
</li>
</ul>
<h5 id="设置延迟加载的方式："><a href="#设置延迟加载的方式：" class="headerlink" title="设置延迟加载的方式："></a>设置延迟加载的方式：</h5><p>方式1：对单个Bean对象进行延迟加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例如连接池的延时加载设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  通过数据库连接池给我们提供的init方法和 close方法进行设置 指定初始化（类似构造器）到销毁的具体方法。</span><br></pre></td></tr></table></figure>
<p>方式2：对Bean标签集中的所有bean对象都进行延迟加载设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h5 id="Bean对象的作用域"><a href="#Bean对象的作用域" class="headerlink" title="Bean对象的作用域"></a>Bean对象的作用域</h5><p>Spring中bean对象的默认作用域就是singleton ，创建以后一直存在，除了singleton的作用域，还有其他的作用域。</p>
<ul>
<li>singleton：对于延迟加载，只有在第一次获取bean的时候才会加载这个bean对象，否则直接生成，但都是IOC容器的唯一对象</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>globalSession 用于分布式web开发中，创建的实例绑定全局session对象</li>
</ul>
<p>对于<strong>prototype作用域的bean对象</strong>：</p>
<p>作用域为 prototype 的 bean ，其destroy方法并没有被调用。如果 bean 的 scope 设为prototype时，<strong>当容器关闭时，destroy 方法不会被调用</strong>。对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring不能对一个 prototype bean 的整个生命周期负责：<strong>容器在初&#x2F;始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。</strong> 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。<strong>清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责</strong>（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。<br>谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由<strong>客户端</strong>来处理。<br>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，<strong>Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<p>​																<strong>（Spring容器对prototype作用域的bean对象 ——只管生，不管养）</strong></p>
<p>Spring通过<strong>ConcurrentHashMap</strong>实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;  </span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例    </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。  </span></span><br><span class="line">                addSingleton(beanName, singletonObject);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将对象添加到单例注册表  </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Spring的注册表</p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Spring中策略模式的应用</p>
<p>当bean需要访问资源配置文件时，Spring有两种方式</p>
<p>1.代码中获取Rescource实例<br>2.依赖注入<br>第一种方式需要获取rescource资源的位置，代码中耦合性太高，而今我们一直使用注解，依赖注入的方式去获取。这样的话就无需修改程序，只改配置文件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Test&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- 注入资源 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tmp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:book.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>在依赖注入的过程中，<strong>Spring会调用ApplicationContext 来获取Resource的实例</strong>。然而，Resource 接口封装了各种可能的资源类型，包括了：UrlResource，ClassPathResource，FileSystemResource等，Spring需要针对不同的资源采取不同的访问策略。在这里，Spring让ApplicationContext成为了资源访问策略的“决策者”。<strong>在资源访问策略的选择上，Spring采用了策略模式。</strong>当 Spring 应用需要进行资源访问时，它并不需要直接使用 Resource 实现类，而是<strong>调用 ApplicationContext 实例的 getResource() 方法来获得资ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略</strong>，从而将应用程序和具体的资源访问策略分离开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> PathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;book.xml&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>上面的代码中，Spring 将采用和 ApplicationContext 相同的策略来访问资源。即： ApplicationContext 是ClassPathXmlApplicationContext，则res 就是 ClassPathResource 实例。若将代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>通过使用修饰模式，可以在运行时扩充一个类的功能。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//根据指定的bean使用对应的侧脸创建新的实例，如工厂方法，构造函数自动注入，简单初始化</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。如下图所示：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYW84MjE=,size_16,color_FFFFFF,t_70.jpeg" class="" title="img">

<p>当然你也可以使用AspectJ，Spring AOP已经继承了AspectJ,AspectJ应该算的上是java生态系统中最完整的AOP框架了。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。<br>动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。</p>
<p>jdk动态代理，必须有接口，目标类必须实现接口， 没有接口时，需要使用<a href="https://so.csdn.net/so/search?q=cglib&spm=1001.2101.3001.7020">cglib</a>动态代理。</p>
<p><strong>动态代理能做什么？</strong></p>
<p>可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。</p>
<p>举例：</p>
<p>在开发中也会有这样的情况， 你有a类， 本来是调用c类的方法， 完成某个功能。 但是c不让a调用。</p>
<p>a —–不能调用 c的方法。<br>在a 和 c 直接 创建一个 b 代理， c让b访问。<br>a –访问b—访问c</p>
<p>实际的例子： 登录，注册有验证码， 验证码是手机短信。<br>中国移动， 联通能发短信。<br>中国移动， 联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能<br>张三项目发送短信—-子公司，或者关联公司—–中国移动， 联通</p>
<p><strong>使用代理模式的作用</strong></p>
<ol>
<li>功能增强： 在你原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强。</li>
<li>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。</li>
</ol>
<p><strong>实现代理的方式：</strong></p>
<ol>
<li><p>静态代理</p>
<p>代理类是自己手工实现的，自己创建一个java类，表示代理类。<br>同时你所要代理的目标类是确定的。</p>
<p>特点：</p>
<p>1）实现简单 2）容易理解。<br>缺点：当你的项目中，目标类和代理类很多时候，有以下的缺点<br>1）当目标类增加了， 代理类可能也需要成倍的增加。 代理类数量过多。<br>2）当你的接口中功能增加了， 或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。jdk动态代理实现</p>
</li>
<li><p>动态代理</p>
<p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。<br>1）代理类数量可以很少，<br>2）当你修改了接口中的方法时，不会影响代理类。</p>
<p>动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理类对象， 并动态的指定要代理目标类。换句话说， 动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。</p>
<hr>
<p>在java中，要想创建对象：</p>
<p>创建类文件， java文件编译为class<br>使用构造方法，创建类的对象。</p>
<hr>
<p>而<strong>动态代理的实现</strong>：<br>反射包 java.lang.reflect , 包含 一个接口 ： InvocationHandler </p>
<p>​													 两个类	： Method, Proxy</p>
<p>(1)InvocationHandler 接口（调用处理器）：</p>
<p>只有一个方法invoke（）：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>(2) Method类：表示方法的， 确切的说就是目标类中的方法。</p>
<p>作用：通过Method可以执行某个目标类的方法，Method.invoke();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(目标对象，方法的参数)</span><br><span class="line"><span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(service2, “李四”);</span><br><span class="line"><span class="comment">// method.invoke（）就是用来执行目标方法的，等同于静态代理中的</span></span><br><span class="line"><span class="comment">//向厂家发送订单，告诉厂家，我买了u盘，厂家发货</span></span><br><span class="line"><span class="comment">//float price = factory.sell(amount); //厂家的价格。</span></span><br></pre></td></tr></table></figure>

<p>(3) Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法(),现在我们是使用Proxy类的方法，代替new的使用。</p>
<p>方法： 静态方法 newProxyInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                         Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                         InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>作用： 创建代理对象， 等同于静态代理中的TaoBao taoBao &#x3D; new TaoBao();<br>参数：<br>ClassLoader loader 类加载器，负责向内存中加载对象的。 使用反射获取对象的ClassLoader类a , a.getCalss().getClassLoader(), 目标对象的类加载器<br>Class&lt;?&gt;[] interfaces： 接口， 目标对象实现的接口，也是反射获取的。<br>InvocationHandler h : 我们自己写的，代理类执行invoke()方法，实现要完成的功能。</p>
<p>这样我们就完成了JDK的动态代理流程。</p>
</li>
</ol>
<h4 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h4><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p>
<p>cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。</p>
<p>CGLIB的核心类：<br>    net.sf.cglib.proxy.Enhancer – 主要的增强类<br>    net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>    net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>    Object o &#x3D; methodProxy.invokeSuper(proxy, args);&#x2F;&#x2F;虽然第一个参数是被代理对象，也不会出现死循环的问题。</p>
<p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, java.lang.reflect.Method method,Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(cglibProxy);</span><br><span class="line"> </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">o</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">        o.getName(<span class="number">1</span>);</span><br><span class="line">        o.getAge(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>++++++before CGLIB$getName$0++++++<br>getName<br>——getName——<br>++++++before CGLIB$getName$0++++++<br>++++++before CGLIB$getAge$1++++++<br>getAge<br>——getAge——</p>
<p>++++++before CGLIB$getAge$1++++++</p>
<h4 id="Spring-AOP和AspectJ-AOP有什么区别？"><a href="#Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别？"></a>Spring AOP和AspectJ AOP有什么区别？</h4><p>Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作。</p>
<p>Spring AOP已经集成了AspectJ，AsectJ应该算的上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单，如果我们的切面比较少，那么两者的性能差异不大。但是当切面太多的话，最好选择AspectJ，它比Spring AOP快很多。</p>
<p><a href="https://blog.csdn.net/u012285269/article/details/122022182?spm=1001.2101.3001.6650.16&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&utm_relevant_index=18">(20条消息) 关于Jdk的Proxy与CGLib的理解_臧馆长的博客-CSDN博客_jdk proxy 和cglib</a></p>
<p><a href="https://www.cnblogs.com/resentment/p/5742661.html">CGLib与JDKProxy的区别 - resentment - 博客园 (cnblogs.com)</a></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变一个算法的结构即可重定义该算法的默写特定步骤的实现方式。</p>
<p>还有很多设计模式 就不详细写了 下面解析源码的时候将设计模式和spring的加载流程串联到一起。</p>
<h1 id="Bean对象的生命周期"><a href="#Bean对象的生命周期" class="headerlink" title="Bean对象的生命周期"></a>Bean对象的生命周期</h1><p>上面我们已经提到过Bean对象的作用域了，现在我们谈一谈Bean对象从被创建到消亡的过程。（就像一个人的一生一样，更应该着重看人的一生的意义，而不是出生和死亡。）</p>
<p>该位置也是从进入容器开始实例化 到bean对象被销毁的对应位置：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI0NjUxOA==,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p>再通过调用的方法名来进行区域的划分：</p>
<img src="/2022/05/26/Spring/bean%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16537349916045.png" class="" title="bean对象生命周期">

<p>主要分为四大阶段：</p>
<ul>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ul>
<p><strong>生命周期执行的过程如下:</strong></p>
<ol>
<li>spring对bean进行实例化,默认bean是单例<strong>singleton</strong>作用域</li>
<li>spring对bean进行依赖注入</li>
<li>如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来</li>
<li>如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入</li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法</li>
<li>如果bean实现了<strong>InitializingBean</strong>接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,该方法也会被调用</li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法</li>
<li>此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁</li>
<li>若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用</li>
</ol>
<p><strong>关于initializingbean</strong></p>
<p><a href="https://juejin.cn/post/6964604073223913509">Spring InitializingBean 接口都不知道，源码你还是缓缓吧… - 掘金 (juejin.cn)</a></p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h3><p>spring依赖注入有三种方式</p>
<h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><h2 id="Spring事务分类"><a href="#Spring事务分类" class="headerlink" title="Spring事务分类"></a>Spring事务分类</h2><p><strong>编程式事务</strong>:允许用户在实现代码中使用显式的方式调用beginTransaction()开启事务、commit()提交事务、rollback()回滚事务，从而可以达到精确定义事务的边界。</p>
<p><strong>声明式事务管理</strong>:底层是建立在Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。声明式事务的最大优点就是不需要编程，将事务管理从复杂业务逻辑中抽离，只需要在配置文件中配置并在目标方法上添加**@Transactional**注解即可实现。</p>
<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager,关系图如下</p>
<img src="/2022/05/26/Spring/webp.webp" class="" title="img">

<h2 id="Spring事务的传播属性"><a href="#Spring事务的传播属性" class="headerlink" title="Spring事务的传播属性"></a>Spring事务的传播属性</h2><ol>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRED)</strong></p>
<p>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)</strong></p>
<p>容器不为这个方法开启事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)</strong></p>
<p>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行旧的事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.MANDATORY)</strong></p>
<p>必须在一个已有的事务中执行,否则抛出异常</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NEVER)</strong></p>
<p>必须在一个没有的事务执行,否则抛出异常(与Propagation.MANDATORY相反)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.SUPPORTS)</strong></p>
<p>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他  bean没有声明事务,那就不用事务.</p>
</li>
</ol>
<h2 id="Spring事务注意事项"><a href="#Spring事务注意事项" class="headerlink" title="Spring事务注意事项"></a>Spring事务注意事项</h2><ol>
<li>在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。</li>
<li>@Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</li>
<li>注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。</li>
<li>通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。</li>
<li>Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</li>
<li>@Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</li>
</ol>
<h2 id="Spring事务超时时间"><a href="#Spring事务超时时间" class="headerlink" title="Spring事务超时时间"></a>Spring事务超时时间</h2><ol>
<li>TransactionDefinition 接口中定义了1个表示超时时间的常量**TIMEOUT_DEFAULT **，使用getTimeout()方法可以获取到超时时间，单位是秒。Spring事务超时时间，是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在Spring程序中超时时间设置的注解方式是设置timeout的值表示这个事务，true只读取数据但不更新数据，false表示可正常读写数据</li>
<li>**@Transactional(timeout&#x3D;30)**默认是-1，不超时</li>
</ol>
<p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/5846416.html">Spring系列之beanFactory与ApplicationContext - 平凡希 - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/9a5acbf54b91">Spring-事务机制 - 简书 (jianshu.com)</a></p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_38246518/article/details/106131083">https://blog.csdn.net/weixin_38246518/article/details/106131083</a></p>
<p>原文链接：<a href="https://blog.csdn.net/chao821/article/details/92400186">https://blog.csdn.net/chao821/article/details/92400186</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/139f813fca80">Spring源码(七)-IOC中的那些设计模式 - 简书 (jianshu.com)</a></p>
<p><a href="https://www.cnblogs.com/duanxz/p/3750725.html">spring扩展点之一：BeanFactoryPostProcessor和BeanPostProcessor - duanxz - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_43973404/article/details/113094312">https://blog.csdn.net/weixin_43973404/article/details/113094312</a></p>
<p><a href="https://blog.csdn.net/heyutao007/article/details/49738887">(36条消息) Java动态代理的两种实现方法_和大黄的博客-CSDN博客_java动态代理的两种方式</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>乐观锁和悲观锁</title>
    <url>/2022/05/17/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p><a href="https://zhuanlan.zhihu.com/p/95296289">摘自文章1</a></p>
<p>[摘自文章2](<a href="https://zhuanlan.zhihu.com/p/34556594">面试必问的CAS，你懂了吗？ - 知乎 (zhihu.com)</a>)</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<span id="more"></span>

<p><strong>乐观锁测试</strong></p>
<p>不使用乐观锁的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个例子很简单：我们定义了一个变量a，初始值是0，然后使用5个线程去增加，每个线程增加10，</span></span><br><span class="line"><span class="comment">    按道理来说5个线程一共增加了50，但是运行一下就知道答案不到50，原因就在于里面那个加一操作：</span></span><br><span class="line"><span class="comment">    a++;</span></span><br><span class="line"><span class="comment">    对于a++的操作，其实可以分解为3个步骤。</span></span><br><span class="line"><span class="comment">    （1）从主存中读取a的值</span></span><br><span class="line"><span class="comment">    （2）对a进行加1操作</span></span><br><span class="line"><span class="comment">    （3）把a重新刷新到主存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//一个变量a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//定义5个线程，每个线程加10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(a++);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。<br>​    AtomicInteger的作用就是为了保证原子性。如何保证原子性呢？我们使用案例说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="comment">//使用AtomicInteger定义a</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//使用getAndIncrement函数进行自增操作</span></span><br><span class="line">                        System.out.println(a.incrementAndGet());</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="comment">//CAS</span></span><br><span class="line">    <span class="comment">//getAndIncrement()实现的自增操作是自旋CAS操作：在循环中进行compareAndSet，如果执行成功则退出，否则一直执行。</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；</p>
<p>除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类。</p>
<p>下面看一下AtomicInteger的源码，了解下它的自增操作getAndIncrement()是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe是用来帮助Java访问操作系统底层资源的类（如可以分配内存、释放内存,在netty中大量用到它,属于C++层面的native方法,我们一般使用反射获取），通过Unsafe，Java具有了底层操作能力，可以提升运行效率；</p>
<p>valueOffset可以理解为value在内存中的偏移量，对应了CAS三个操作数(V&#x2F;A&#x2F;B)中的V；偏移量的获得也是通过Unsafe实现的。</p>
<h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><p>CAS操作包括了3个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)</li>
</ul>
<p>CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p>
<p>这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？</p>
<p>答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p>
<p>但是虽然保证将A值比较 然后转化为B值这一系列操作是原子性的 但是不能确定这个A值就是预期的A值 这就是ABA问题</p>
<p>ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</p>
<p>这时候就需要一个版本号来进行限制。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，</p>
<p>它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>其实大多是的乐观锁是由CAS+版本号进行实现的 但是通过版本号也可以实现乐观锁</p>
<p>和CAS大致思想相同 将想要更改的信息添加一个版本号 在对数据进行修改的时候 首先查询版本号 如果版本号相同 则继续操作修改数据 之后再将版本号加1（或者加其他数值，总之是修改版本号）</p>
<p><strong>乐观锁加锁了吗？</strong></p>
<p>1.乐观锁本身是不加锁的，只是在修改数据的时候，判断一下是不是已经被其他线程更新了。</p>
<p>2.有一些乐观锁是加锁合作的，为了保证整个查看版本修改数据然后修改版本的原子性操作，</p>
<p>但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。</p>
<p><strong>乐观锁带来的问题</strong></p>
<p>1.首当其冲的是性能问题，当CAS操作自旋访问的时候，执行getAndAddInt方法时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<p>2.安全问题，就是上述的ABA问题，”你以为身边的那么她还是她，其实她早变心了，已经不是以前的那个她了“。</p>
<p>3.共享，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修</p>
<p>改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲</p>
<p>观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观</p>
<p>锁，如 RetreenLock。</p>
<p>数据库中就经常使用悲观锁以保证数据的安全，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h3 id="悲观锁和乐观锁的使用场景"><a href="#悲观锁和乐观锁的使用场景" class="headerlink" title="悲观锁和乐观锁的使用场景"></a>悲观锁和乐观锁的使用场景</h3><p>乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。</p>
<ul>
<li><strong>功能限制 与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</strong></li>
</ul>
<p>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。</p>
<p>再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p>
<ul>
<li><strong>竞争激烈程度 如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</strong></li>
</ul>
<p>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</p>
<p>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>双重检验锁</title>
    <url>/2022/05/08/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81/</url>
    <content><![CDATA[<h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> TheClass theclass;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TheClass</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Track <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(TheClass.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">                    theclass=<span class="keyword">new</span> <span class="title class_">TheClass</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theclass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>中间件及容器管理</title>
    <url>/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv7rlicu.png" alt="img"></p>
<p><a href="https://docs.docker.com/get-started/overview/">Docker overview | Docker Documentation</a></p>
<h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><p>镜像</p>
<p>容器:容器是具体镜像文件的运行环境</p>
<p>仓库:集中存放镜像的地方</p>
<span id="more"></span>

<p>Docker 中 docker run命令到底干了什么？</p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220711204926292.png" class="" title="image-20220711204926292">

<h3 id="docker-的客户端-服务端"><a href="#docker-的客户端-服务端" class="headerlink" title="docker 的客户端 服务端"></a>docker 的客户端 服务端</h3><h3 id="为什么docker比Vmware快"><a href="#为什么docker比Vmware快" class="headerlink" title="为什么docker比Vmware快"></a>为什么docker比Vmware快</h3><p>docker时服用了宿主机操作系统的内核，而Vmware是宿主机的 </p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>docker 全部帮助命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">help</span> </span><br></pre></td></tr></table></figure>

<p>dokcer 加上指定命令 帮助提示参数</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>docker 所有本地镜像文件的信息 ()</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220713204827510.png" class="" title="image-20220713204827510">

<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220713204754241.png" class="" title="image-20220713204754241">

<p>如果不指定tag（版本号） 则自动拉去最新版镜像</p>
<p>拉取镜像</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker pull name</span><br></pre></td></tr></table></figure>



<p>查找远程hub仓库的镜像文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker search name</span><br></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>端口映射</p>
<p>从docker外部的端口 映射到docker内部的容器内部镜像的端口</p>
<p>启动交互式容器</p>
<p>docker的镜像pull到宿主机后 可以运行这个镜像并进行交互式操作</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it 镜像名称 /bin/bash</span><br></pre></td></tr></table></figure>

<p>也可以给镜像指定容器名称进行运行 不指定则直接碎金分配一个容器中运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --name=容器名 镜像名称 /bin/bash</span><br></pre></td></tr></table></figure>

<p>退出交互界面</p>
<p>① 退出镜像 容器停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<p>② 退出但是 容器不停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ctrl+q+p</span><br></pre></td></tr></table></figure>



<p>批量操作</p>
<p>批量删除容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure>



<p>停止容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>



<p>启动守护式容器</p>
<p>大部分场景下 我们希望docker容器在后台运行 可以通过-d指定容器的后台模式</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu </span><br></pre></td></tr></table></figure>

<p>docker容器后台运行 就必须要有一个前台进程</p>
<p>容器运行的命令如果不是那些一直挂起的命令（比如top，tail） 就会自动退出</p>
<p>查看容器内部进程</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<p>重新进入正在运行的容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>

<p>使用attach 退出的时候 会导致容器停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>



<h3 id="docker-分层原理"><a href="#docker-分层原理" class="headerlink" title="docker 分层原理"></a>docker 分层原理</h3><h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><p>将整个容器进行备份</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker export 容器id &gt; 文件名.tar</span><br></pre></td></tr></table></figure>

<p>这个tar包就会在宿主机的内部存放</p>
<p>再将tar包转化为docker的镜像文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat 文件名.tar | docker import - 镜像文件包名/镜像名:镜像版本号</span><br></pre></td></tr></table></figure>

<p>docker内部就会存在这个镜像文件 就可以运行了</p>
<p>查看容器日志</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker logs 容器id </span><br></pre></td></tr></table></figure>



<p>Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层容器被加载到镜像的顶部，这一层通常被称为容器层 容器层之下的都是镜像层。</p>
<h4 id="制作本地镜像并将镜像进行提交"><a href="#制作本地镜像并将镜像进行提交" class="headerlink" title="制作本地镜像并将镜像进行提交"></a>制作本地镜像并将镜像进行提交</h4><p>docker commit 提交容器副本使之成为一个新的镜像</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者信息&quot; 容器ID 包名:标签名</span><br><span class="line">docker commit -m=&quot;带有vim的ubuntu&quot; -a=&quot;zsr&quot; 容器ID zsr:ubuntuTEST</span><br></pre></td></tr></table></figure>

<h3 id="docker-仓库"><a href="#docker-仓库" class="headerlink" title="docker 仓库"></a>docker 仓库</h3><p>开源则选择阿里云仓库 闭源可以选自私服仓库</p>
<h4 id="将镜像提交到阿里云以及操作总结"><a href="#将镜像提交到阿里云以及操作总结" class="headerlink" title="将镜像提交到阿里云以及操作总结"></a>将镜像提交到阿里云以及操作总结</h4><img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220715101912679.png" class="" title="image-20220715101912679">

<p>在阿里云开通个人镜像仓库 然后通过阿里云的脚本命令进行pull和push操作</p>
<p><a href="https://cr.console.aliyun.com/repository/cn-hangzhou/zsr_namespace_01/myubuntu1.3/details">容器镜像服务 (aliyun.com)</a></p>
<h5 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=悲伤豆角南瓜汤 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>您可以在访问凭证页面修改凭证密码。</p>
<h5 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h5 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=悲伤豆角南瓜汤 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]$ docker push registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<h4 id="将镜像添加到私服仓库"><a href="#将镜像添加到私服仓库" class="headerlink" title="将镜像添加到私服仓库"></a>将镜像添加到私服仓库</h4><p>首先将 镜像文件——registry pull到docker本地镜像 并在后台启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /shuaiqiwudi/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>



<p>然后将镜像放到私人仓库中</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker tag 镜像名称:版本号 开启registry机器的ip:对应端口号/存放该镜像的镜像名:设置版本</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p>当我们在docker上运行容器的时候 ，以防意外情况（容器小时，容器停止等）我们需要将容器的数据进行备份和管理。存储这些数据的介质就是所谓的<strong>容器数据卷</strong>，容器内的数据 <strong>备份+持久化—&gt;宿主机</strong> 的目录内。 </p>
<p><strong>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</strong></p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220718102537537.png" class="" title="image-20220718102537537">

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>



<p>在容器内部进行数据的更改或添加 宿主机磁盘内部也会随之更改 是实时的</p>
<p>在宿主机磁盘进行更改 在重新启动docker容器 其容器回自动加载新的磁盘文件</p>
<p>设置参数以 <strong>限制docker容器</strong> 在 宿主机的容器数据卷的 读写权限</p>
<p>读写均可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rm 镜像名</span><br></pre></td></tr></table></figure>

<p>只读不写</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>



<p>查看docker容器的详细信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h3 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes from 父类 --name 新名字 镜像名</span><br></pre></td></tr></table></figure>

<p>父类的容器进行更改的时候 在其挂载的子类下面也会随之更改。</p>
<h2 id="Docker-集群的搭建"><a href="#Docker-集群的搭建" class="headerlink" title="Docker 集群的搭建"></a>Docker 集群的搭建</h2><p>redis集群：哈希算法支持redis的信息存储</p>
<p>查看结点之间的关系和集群各个节点的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<h3 id="Docker-FIle"><a href="#Docker-FIle" class="headerlink" title="Docker FIle"></a>Docker FIle</h3><p>是用来构建镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本</p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220720131638459.png" class="" title="image-20220720131638459">

<p>构建的三个步骤：</p>
<ol>
<li><p>编写Dockefile文件</p>
</li>
<li><p>docker build命令构建镜像</p>
</li>
<li><p>docke run 镜像</p>
</li>
</ol>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220720132425854.png" class="" title="image-20220720132425854">

<h3 id="CentOS添加功能搭建步骤"><a href="#CentOS添加功能搭建步骤" class="headerlink" title="CentOS添加功能搭建步骤"></a>CentOS添加功能搭建步骤</h3><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>docker compose是堆docker容器的管理项目，类似于spring容器对bean对象的管理，docker-compose.yml文件定义了所有docker容器的加载顺序等等，所以比如有业务需求的时候，需要固定的容器启动顺序，就是使用docker compose。</p>
<p>只需要</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker compose up</span><br></pre></td></tr></table></figure>

<p> 就可以运行docker-compose.yml定义好的所有docker容器，也简化了我们的操作内容。</p>
<p>使用docker compose也是让我们可以不指定固定ip地址 就可以访问服务。在jar包里的项目配置文件的固定ip地址写成容器的名称。</p>
<p>使用 Dockerfile 创建镜像。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像名称 .</span><br></pre></td></tr></table></figure>

<p>创建docker-compose.yml文件(案例)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">microService:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zzyy_docker:1.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6001:6001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/microService:/data</span></span><br><span class="line">    <span class="string">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="string">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0.8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span></span><br><span class="line">    <span class="string">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"> </span><br><span class="line"><span class="string">networks:</span> </span><br><span class="line">   <span class="string">atguigu_net:</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>docker-compose.yml 和 jar包在同一个文件夹</p>
<p>在docker-compose.yml 所在文件夹运行该命令<strong>查看编排文件是否正确</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker-compose config -q</span><br></pre></td></tr></table></figure>

<p>然后执行docker-compose 项目就会启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目环境搭建及中间件</category>
      </categories>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/05/20/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库逻辑架构"><a href="#数据库逻辑架构" class="headerlink" title="数据库逻辑架构"></a>数据库逻辑架构</h2><img src="/2022/05/20/mysql/image-20220522131409069.png" class="" title="image-20220522140130072">

<h3 id="连接层-Connection-Pool"><a href="#连接层-Connection-Pool" class="headerlink" title="连接层 Connection Pool"></a>连接层 Connection Pool</h3><p>系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证</p>
<p><strong>TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池</strong></p>
<h4 id="连接池（线程池）"><a href="#连接池（线程池）" class="headerlink" title="连接池（线程池）"></a>连接池（线程池）</h4><p>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。</p>
<span id="more"></span>

<details>
<summary>点击查看线程池详细内容</summary>
<b>为什么使用连接池？</b><br>
对于数据库建立连接对象，对应一个实际的物理连接，每次使用都打开一个连接，再关闭一个连接，这样会造成书库的性能低下。解决方案是，应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池**(简单说：在一个“池”里放了好多半成品的数据库联接对象)**，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。这样一来，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率。<br>
<b>不使用连接池 执行一条sql的过程：</b><br><br>
<img src="/2022/05/20/mysql/image-20220522133151857.png" class="" title="image-20220522133151857">
<br>
1. TCP建立连接的三次握手<br>
2. MySQL认证的三次握手<br>
3. 真正的SQL执行<br>
4. MySQL的关闭<br>
5. TCP的四次握手关闭<br>
<b>使用连接池 执行一条sql的过程：</b><br>
<img src="/2022/05/20/mysql/image-20220522133456976.png" class="" title="image-20220522133456976"><br>
第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。<br>
<b>线程池工作的原理</b><br>
建立连接 管理链接 删除连接 <br>
第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。<br>
第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：<br>
当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>
当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。<br>
第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。
<b>主流的几个连接池</b>
数据库连接池有三种：</b>
1、DBCP:</b>
DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。</b>
2、C3P0:</b>
c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。</b>
3、Druid:</b>
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个 SQL Parser。</b>
支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。</b>
Druid针对Oracle和MySql做了特别优化，比如Oracle的PS Cache内存占用优化，MySql的ping检测优化。</b>
Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。</b>
简单SQL语句用时10微秒以内，复杂SQL用时30微秒。通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。</b>
Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析语义实现的。</b>
<img src="/2022/05/20/mysql/image-20220522134845235.png" class="" title="image-20220522134845235"></b>
参考链接
原文链接：https://blog.csdn.net/weixin_43871678/article/details/116571499</b>
原文链接：https://blog.csdn.net/CrankZ/article/details/82874158</b>
</details>



<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p><strong>SQL Interface: SQL</strong> <strong>接口</strong></p>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface . MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
<p><strong>Parser:</strong> <strong>解析器</strong></p>
<p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 </p>
<p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。<strong>这个执行计划表明应该 使用哪些索引 进行查询</strong>（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真的执行查询，并将查询结果返回给用户。</p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
<p><strong>Caches &amp; Buffers</strong> <strong>： 查询缓存组件</strong></p>
<p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。这个查询缓存可以在 不同客户端之间共享 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </p>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了</strong> <strong>MySQL</strong> <strong>中数据的存储和提取，对物理服务器级别</strong> <strong>维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<img src="/2022/05/20/mysql/image-20220522140130072.png" class="" title="image-20220522140130072">

<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>作为数据真正的物理存储位置，所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。</p>
<p><strong>MyISAM</strong>存储文件后缀为—– <strong>.myd(数据) 和.myi (索引)</strong> </p>
<p><strong>Innodb</strong>的索引和数据是集中存储的 —– <strong>.ibd</strong></p>
<h3 id="整个执行流程"><a href="#整个执行流程" class="headerlink" title="整个执行流程"></a><strong>整个执行流程</strong></h3><img src="/2022/05/20/mysql/image-20220522141658938.png" class="" title="image-20220522141658938">

<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a><strong>数据库三大范式</strong></h2><p><strong>第一范式</strong>：每个列都不可以再拆分。</p>
<p><strong>第二范式</strong>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p><strong>第三范式</strong>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="两大存储引擎"><a href="#两大存储引擎" class="headerlink" title="两大存储引擎"></a>两大存储引擎</h2><img src="/2022/05/20/mysql/image-20220520170817159.png" class="" title="image-20220520170817159">

<img src="/2022/05/20/mysql/image-20220520170840162.png" class="" title="image-20220520170840162">

<p>InnoDB的B+树索引的注意事项</p>
<p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>
<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<h3 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h3><p>索引的存在 就是为了<strong>减少磁盘的IO次数</strong> 增加读取的效率 </p>
<p><strong>什么是索引</strong>：MySQL官方对索引的定义为：<strong>索引（</strong>Index<strong>）是帮助</strong>MySQL<strong>高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<p><strong>优点</strong>：1 ）提高数据检索的效率，降低 数据库的IO成本</p>
<p>​			2 ）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</p>
<p>​			3）在实现数据的参考完整性方面，可以 加速表和表之间的连接 。</p>
<p>​			4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</p>
<p><strong>缺点</strong>：</p>
<p>1）<strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<p>2）<strong>时间上的代价</strong></p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h3 id="设计索引和数据的存储形式"><a href="#设计索引和数据的存储形式" class="headerlink" title="设计索引和数据的存储形式"></a>设计索引和数据的存储形式</h3><p>当我们使用命令创建一个表的时候 数据会以特定的形式存在于表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test(</span><br><span class="line">	number int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">)ROW_FORMAT = Compact;//指定行格式</span><br></pre></td></tr></table></figure>

<p>行数据究竟怎么存储的？Compact的行格式:</p>
<img src="/2022/05/20/mysql/1097754-20210719234605417-2013635397.png" class="" title="img">

<p>DB_ROW_ID(row_id)：如果表中没有显式定义主键列，mysql会默认生成一个row_id作为隐式主键，且row_id是全局概念，每一次有一行新数据insert，都会获取Max Row ID再加1就形成了一个新的row_id<br>DB_TRX_ID： 事务有关，跟回滚指针有关，6个字节<br>DB_ROLL_PTR ：事务有关，跟回滚指针有关， 7个字节</p>
<p>delete mask : 标记为是否被delete语句commit，也就是mysql不会真正物理删除一行记录，在页面上重新组装一个新链表，称为垃圾链表，如果垃圾链表占用空间可重用的话就会重用。</p>
<p>record type：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过。</p>
<p>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>
<img src="/2022/05/20/mysql/image-20220523095656639.jpg" class="" title="image-20220523095656639">

<p>从数据的连接角度来简略展示行数据 每一行数据如此 那么把多数的数据连接起来呢？</p>
<img src="/2022/05/20/mysql/image-20220523095757181.jpg" class="" title="image-20220523095757181">

<p>多行数据进行连接 形成一个页 每一页存放多行数据 页的第一个位置和最后一个位置不存放数据 用来表示该页的最小记录和最大记录。</p>
<p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<img src="/2022/05/20/mysql/image-20220523100525991.jpg" class="" title="image-20220523100525991">

<p>在根据该页的最小记录和最大记录 将每一页的位置进行定位</p>
<p><strong>InnoDB中的索引方案</strong> </p>
<p><strong>① 迭代1次：目录项记录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101301936.jpg" class="" title="image-20220523101301936">



<p><strong>② 迭代2次：多个目录项记录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101831703.jpg" class="" title="image-20220523101831703">



<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101951740.jpg" class="" title="image-20220523101951740">

<p><strong>④</strong> <strong>B+Tree</strong></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：</p>
<ul>
<li><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</p>
</li>
<li><p>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</p>
</li>
<li><p>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</p>
</li>
<li><p>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！！！</p>
</li>
</ul>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</p>
<h3 id="索引的类型和特点"><a href="#索引的类型和特点" class="headerlink" title="索引的类型和特点"></a>索引的类型和特点</h3><p><strong>1.聚簇索引</strong></p>
<p>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据；<strong>主键索引是聚簇索引的一种</strong>。通常情况下 我们使用主键作为自增的唯一id 但是如果没有主键 那么会默认使用row_id作为主键 </p>
<p>1）使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<p><strong>页内的记录</strong>是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</p>
<p>各个 <strong>存放用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个<strong>双向链表</strong> 。</p>
<p><strong>存放目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。 </p>
<p>2）B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p><strong>2.非聚簇索引</strong></p>
<p>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。简单理解：在聚簇索引上建立的索引就是非聚簇索引。对于主键索引和非主键索引，使用的数据结构都是 B+Tree，唯一的区别在于叶子结点中存储的内容不同：</p>
<ul>
<li>主键索引的叶子结点存储的是一行完整的数据。</li>
<li>非主键索引的叶子结点存储的则是主键值。</li>
</ul>
<p>在innodb中，在聚簇索引上建立的都是辅助索引，即非聚簇索引也叫辅助索引。一张表中只能有一个聚簇索引。其余索引都是非聚簇索引。辅助索引叶子节点存储的是主键值，访问数据总是要先查到主键值，再通过主键值访问到数据。即辅助索引访问数据总是需要二次查找 通常也成为回表</p>
<p><strong>回表：</strong></p>
<p>我们根据某个列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据该列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据非聚簇索引列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方想让books的书籍编号字段和价格字段索引联合创建索引的索引：首先按照书籍编号进行排序 然后在书籍编号的基础上按照价格进行排序。</p>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p><strong>1.最左前缀匹配原则</strong></p>
<p>非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p><strong>2.&#x3D;和in可以乱序</strong></p>
<p>比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p><strong>3.尽量选择区分度高的列作为索引</strong></p>
<p><strong>4.索引列不能参与计算</strong></p>
<p>保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</p>
<p><strong>5.尽量的扩展索引，不要新建索引。</strong></p>
<p>比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
<p><strong>6．选择唯一性索引</strong></p>
<p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
<p><strong>7．为经常需要排序、分组和联合操作的字段建立索引</strong></p>
<p>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p>
<p><strong>8．为常作为查询条件的字段建立索引</strong></p>
<p><strong>9．限制索引的数目</strong></p>
<p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p>
<p><strong>10．尽量使用数据量少的索引</strong></p>
<p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</p>
<p><strong>11．删除不再使用或者很少使用的索引</strong></p>
<p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
<h4 id="哪些字段适合创建索引"><a href="#哪些字段适合创建索引" class="headerlink" title="哪些字段适合创建索引"></a>哪些字段适合创建索引</h4><p><strong>1.字段的数值具有唯一性的限制</strong></p>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
<p><strong>2.频繁作为Where查询字段的字段</strong></p>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p><strong>3.经常GroupBy和Order BY的字段</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。 </p>
<p><strong>4.UPDATE,DELETE 的WHERE条件列</strong></p>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。在实际情况中 还有多种情景适合创建索引 凡是需要重复在聚簇索引中查找某一个列的字段 都可以创建索引</strong></p>
<h4 id="哪些字段不适合创建索引"><a href="#哪些字段不适合创建索引" class="headerlink" title="哪些字段不适合创建索引"></a>哪些字段不适合创建索引</h4><ol>
<li><p>在where中使用不到的字段，不要设置索引</p>
</li>
<li><p>数据量小的表最好不要使用索引</p>
</li>
<li><p>有大量重复数据的列上不要建立索引  比如男性女性这种很高几率重复的字段</p>
</li>
<li><p>避免对经常更新的表进行索引的创建</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
</li>
<li><p>不要定义重复和冗余的索引</p>
</li>
</ol>
<h2 id="数据库的调优策略"><a href="#数据库的调优策略" class="headerlink" title="数据库的调优策略"></a>数据库的调优策略</h2><h3 id="SQL进行优化"><a href="#SQL进行优化" class="headerlink" title="SQL进行优化"></a>SQL进行优化</h3><p>首先查看慢查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like &#x27;%slow%&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后使用explain 这个sql语句进行查看这个sql的具体情况 具体走了哪个索引等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from test1;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220720202620445.png" class="" title="image-20220720202620445">



<h3 id="进行数据库的优化"><a href="#进行数据库的优化" class="headerlink" title="进行数据库的优化"></a>进行数据库的优化</h3><p>分库分表</p>
<p><a href="https://www.cnblogs.com/peng19920430/p/10231864.html#:~:text=%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B0%B1%E6%98%AF%E6%8C%89%E7%85%A7,%E5%AD%98%E5%82%A8%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%A1%A8%E4%B8%8A%E3%80%82">数据库分库分表 - 树_先_森 - 博客园 (cnblogs.com)</a></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在数据库中事务是什么</p>
<p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务处理原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><strong>原子性（atomicity）：</strong></p>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
<p><strong>一致性（</strong>consistency<strong>）：</strong></p>
<p>事务前后数据的完整性必须保持一致。</p>
<p><strong>隔离型（</strong>isolation<strong>）：</strong>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p><strong>持久性（</strong>durability<strong>）：</strong>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h4 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h4><p>显示事务：手动开启事务 begin 或 start transaction</p>
<p>隐式事务：MySql中有一个系统变量autocommit </p>
<img src="/2022/05/20/mysql/image-20220523195028484.jpg" class="" title="image-20220523195028484">

<p>该变量设置数据库执行语句是否自动提交 可以将该变量设置为不自动提交 </p>
<img src="/2022/05/20/mysql/image-20220523195555772.png" class="" title="image-20220523195555772">

<h4 id="数据库并发和隔离级别"><a href="#数据库并发和隔离级别" class="headerlink" title="数据库并发和隔离级别"></a>数据库并发和隔离级别</h4><p>事务的四种并发问题：</p>
<p><strong>1.脏写（ Dirty Write ）</strong>：</p>
<p>对于SessionA和SessionB 如果SessionA修改了另一个未提交事务SessionB修改过的数据 ，那就意味着脏写</p>
<p><strong>2.脏读（ Dirty Read）：</strong></p>
<p>SessionA已经读取了SessionB更新但还没有被提交到的字段，之后若SessionB回滚，SessionA读到的数据并不是真实数据，该数据就是临时且无效的脏读数据。</p>
<p><strong>3.不可重复读（Non</strong>-<strong>Repeatable Read）：</strong></p>
<p>SessionA开启事务并读取数据，但是此时SessionB将数据修改并提交，SessionA再查看数据值不同了，就意味着出现了不可重复读。</p>
<p><strong>4.幻读（Phantom）</strong>：</p>
<p>两个事务SessionA，SessionB SessionA从表中读取了一个字段后，SessionB向表中插入了一些新的行，之后，如果SessionA再次读取同一个表，就会出现几条新的数据（幻影记录），我们称之为幻读。</p>
<p>对于这四种现象 按照严重程度：</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>分别对应<strong>四种隔离级别</strong>：</p>
<p><strong>1.READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</p>
<p>不能避免脏读、不可重复读、幻读。</p>
<p><strong>2.READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>3.REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，</p>
<p>读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</p>
<p>4.<strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、</p>
<p>更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
<p>一张图：</p>
<img src="/2022/05/20/mysql/image-20220523201143065.jpg" class="" title="image-20220523201143065">

<p>5.7.36的隔离级别</p>
<img src="/2022/05/20/mysql/image-20220720204837621.png" class="" title="image-20220720204837621">

<p>8.0.29的隔离级别</p>
<img src="/2022/05/20/mysql/image-20220523201736656.jpg" class="" title="image-20220523201736656">

<h3 id="数据库事务日志"><a href="#数据库事务日志" class="headerlink" title="数据库事务日志"></a>数据库事务日志</h3><p>事务的四种特性是基于什么实现的？ </p>
<p><strong>隔离性</strong>根据<strong>锁机制</strong>实现事务的<strong>原子性，一致性和持久性</strong>由事务的<strong>redo日志和undo日志</strong>保证</p>
<p><strong>REDO LOG</strong> 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</p>
<p><strong>UNDO LOG</strong> 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</p>
<h4 id="为什么使用日志？"><a href="#为什么使用日志？" class="headerlink" title="为什么使用日志？"></a>为什么使用日志？</h4><h4 id="REDO日志"><a href="#REDO日志" class="headerlink" title="REDO日志"></a>REDO日志</h4><p>一方面 缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面 由于数据库具有持久性的特点 就是说 对于一个已经提交的事务，再提交事务后即使发生了宕机或其他突发意外而奔溃，这个数据库所修改的数据也不会丢失。就使用到了日志，因为在每次提交事务的时候，我们都没必要去刷新一下磁盘，只需要记录一下哪些数据修改了就好。这就是redo日志。</p>
<img src="/2022/05/20/mysql/image-20220524201029477.jpg" class="" title="image-20220524201029477">

<h4 id="REDO日志的优点和特点"><a href="#REDO日志的优点和特点" class="headerlink" title="REDO日志的优点和特点"></a>REDO日志的优点和特点</h4><p>优点																											特点</p>
<p>降低了磁盘的刷新次数																			redo日志是顺序写入磁盘的			</p>
<p>redo日志占用空间小																				事务执行的过程中 redo log 不断记录</p>
<p>redolog分为以下两个部分</p>
<p>1.重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</p>
<p>2.重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p>redo log buffer 和 redo log file</p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<img src="/2022/05/20/mysql/image-20220524212211626.png" class="" title="image-20220524212211626">

<h4 id="REDO日志的刷盘策略"><a href="#REDO日志的刷盘策略" class="headerlink" title="REDO日志的刷盘策略"></a>REDO日志的刷盘策略</h4><p>redolog不是直接写入到磁盘当中的 而是先写入到redologbuffer  然后再以一定频率 写入到redologfile 这里的频率就涉及到了刷盘策略：</p>
<p>redologbuffer 刷盘到 redologfile 中并不是真正的写入到磁盘 只是刷入到 文件系统缓存（page cache） 中 （操作系统对写入文件的一个优化策略）真正的写入时机会交给系统去操作 这里就涉及到了如果系统出现宕机等问题 那么数据库则没有保证持久性 。此处可以设置刷盘策略的参数 innodb_flush_log_at_trx_commit ：</p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p>
<h4 id="UNDO日志"><a href="#UNDO日志" class="headerlink" title="UNDO日志"></a>UNDO日志</h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log 。 </p>
<h5 id="UNDO日志的理解"><a href="#UNDO日志的理解" class="headerlink" title="UNDO日志的理解"></a>UNDO日志的理解</h5><p>为了保证数据可以回滚到出现问题或执行事务失败之前的数据状态 使用undo日志记录事务开始前的一个数据状态</p>
<h5 id="UNDO日志的作用"><a href="#UNDO日志的作用" class="headerlink" title="UNDO日志的作用"></a>UNDO日志的作用</h5><p> 1.回滚 2.MVCC</p>
<h5 id="回滚段和undo页"><a href="#回滚段和undo页" class="headerlink" title="回滚段和undo页"></a>回滚段和undo页</h5><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。</p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 。</p>
<p>回滚段中的数据分类：</p>
<ol>
<li><p>未提交的回滚数据(uncommitted undo information) </p>
</li>
<li><p>已经提交但未过期的回滚数据(committed undo information) </p>
</li>
<li><p>事务已经提交并过期的数据(expired undo information)</p>
</li>
</ol>
<p>查看undo日志参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_undo%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525100351318.png" class="" title="image-20220525100351318">

<p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<p>1.将undo log放入列表中，以供之后的purge操作</p>
<p>2.判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
<p><strong>undo日志的类型</strong></p>
<p>1.insert undo log</p>
<p>2.update undo log</p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</p>
<img src="/2022/05/20/mysql/image-20220525101151835.png" class="" title="image-20220525101151835">



<p>undolog 回滚或回复数据库状态 并不是根据一开始的状态 把新数据进行update覆盖操作 而是生成一个undolog链表</p>
<p><strong>undo日志从对数据进行修改到回滚到事务执行之前的状态的过程：</strong></p>
<p>看一下compact数据行格式</p>
<img src="/2022/05/20/mysql/image-20220525101954686.png" class="" title="image-20220525101954686">

<ol>
<li><p>row_id:如果没有主键,unique的列,那么就会自动添加一个row_id行号.</p>
</li>
<li><p>trx_id:谁对该条记录最近一次修改就会记录某个事务的ID.</p>
</li>
<li><p>roll_pointer:一个指向该条记录修改对应的undo日志的指针.</p>
<p>开始修改事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into user(name) values (&#x27;tom&#x27;);</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102303992.jpg" class="" title="image-20220525102303992">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set name=&#x27;Sun&#x27; where id=1;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102439823.jpg" class="" title="image-20220525102439823"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set id=2 where id=1;//设置删除参数deletemark</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102725176.png" class="" title="image-20220525102725176">

<p>对于这个例子 如果回滚则rollback的流程如下:</p>
<ol>
<li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p>
</li>
<li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p>
</li>
<li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p>
</li>
<li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p>
</li>
</ol>
<p>针对于insert undo log：</p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>针对于update undo log ：</p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>事物的隔离性 通过锁来进行体现</p>
<h3 id="多用户访问数据操作"><a href="#多用户访问数据操作" class="headerlink" title="多用户访问数据操作"></a>多用户访问数据操作</h3><p>1.读-读操作</p>
<p>即并发事务相继读取相同位置数据内容，读数据本身对数据库不会有什么影响</p>
<p>2.写-写操作</p>
<p>在这种情况下可能会出现<strong>脏写</strong>的情况，任何隔离级别都不允许脏写的发生，所以在多个未提交事务相继对一条数据进行改动的时候，</p>
<p>首先会看看内存中有没有与这条记录相关联的锁结构，当没有的时候，就会在内存中生成一个锁结构与之关联。即一个事务对应一个锁结构。</p>
<p>事务T1对这条记录进行修改</p>
<img src="/2022/05/20/mysql/image-20220525144131876.png" class="" title="image-20220525144131876">

<p>事务T2同时想要修改这条记录</p>
<img src="/2022/05/20/mysql/image-20220525144355014.png" class="" title="image-20220525144355014">

<p>3.读-写 或 写-读</p>
<p>当一个事务进行数据读取操作，另一个事务进行改动操作，这种情况下可能发生<strong>脏读，不可重复读，幻读</strong>等问题</p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>1.MVCC 性能更高</p>
<p>2.读写都进行加锁的方式 性能较低</p>
<h3 id="Mysql中锁的不同种类"><a href="#Mysql中锁的不同种类" class="headerlink" title="Mysql中锁的不同种类"></a>Mysql中锁的不同种类</h3><img src="/2022/05/20/mysql/image-20220525145305850.png" class="" title="image-20220525145305850">

<h3 id="从操作类型分-读锁和写锁"><a href="#从操作类型分-读锁和写锁" class="headerlink" title="从操作类型分 读锁和写锁"></a>从操作类型分 读锁和写锁</h3><p>读锁：又称为共享锁，使用S表示，针对一份数据，多个事务同时进行不会进行阻塞，互相之间不会影响。</p>
<p>写锁：又称为排他锁，使用X表示，当前写操作没有完成之前，会阻断其他事务的读取和写入，这样只要会由一个事务进行操作。</p>
<h3 id="从操作数据的粒度上划分-表级锁，页级锁，行锁"><a href="#从操作数据的粒度上划分-表级锁，页级锁，行锁" class="headerlink" title="从操作数据的粒度上划分 表级锁，页级锁，行锁"></a>从操作数据的粒度上划分 表级锁，页级锁，行锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>1.表级别的X，S锁 </p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。</p>
<p>在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、</p>
<p>DELETE、UPDATE的语句会生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中</p>
<p>对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通在 server层 使用一种称之为 元数据锁 （英文名： Metadata Locks ，简称 MDL ）结构来实现的。</p>
<p>表锁的并发度太低 也分为表的写锁和读锁	：表共享读锁（Table Read Lock）                    表独占写锁（Table Write Lock） </p>
<img src="/2022/05/20/mysql/image-20220525151404962.png" class="" title="image-20220525151404962">

<p>2.意向锁</p>
<p>InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁 与 表级锁 共存，而<strong>意向锁</strong>就是其中的一种 表锁 。</p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 </span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>EX：开启一个事务 并向其中添加一条数据，在事务中查看意向锁：</p>
<img src="/2022/05/20/mysql/image-20220525152611363.png" class="" title="image-20220525152611363">



<p>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p>3.自增锁</p>
<p>4.元数据锁</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>1.记录锁（Record Locks）</p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。</p>
<p>仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<img src="/2022/05/20/mysql/image-20220525153413146.png" class="" title="image-20220525153413146">

<img src="/2022/05/20/mysql/image-20220525154333587.png" class="" title="image-20220525154333587">

<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。</p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</p>
</li>
</ul>
<p>2.<strong>间隙锁（Locks）</strong> </p>
<p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。</p>
<img src="/2022/05/20/mysql/image-20220525155754456.png" class="" title="image-20220525155754456">

<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<ul>
<li><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><img src="/2022/05/20/mysql/image-20220525160130933.png" class="" title="image-20220525160130933">

<ol>
<li>锁所在的事务信息 ：</li>
</ol>
<p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个</p>
<p>事务的信息。</p>
<p>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比</p>
<p>方说事务id等。</p>
<ol start="2">
<li>索引信息 ：</li>
</ol>
<p>对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<ol start="3">
<li>表锁／行锁信息 ：</li>
</ol>
<p>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
<p>行锁：</p>
<p>记载了三个重要的信息：</p>
<p>Space ID ：记录所在表空间。</p>
<p>Page Number ：记录所在页号。</p>
<p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
<ol start="4">
<li>type_mode ：</li>
</ol>
<p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</p>
<img src="/2022/05/20/mysql/image-20220525160724571.png" class="" title="image-20220525160724571">

<p><strong>锁的模式（ lock_mode ）</strong>，占用低4位，可选的值如下：</p>
<p>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </p>
<p>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。 </p>
<p>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </p>
<p>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </p>
<p>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。 </p>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<p><strong>锁的类型（ lock_type ）</strong>，占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<p>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</p>
<p>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</p>
<p><strong>行锁的具体类型（ rec_lock_type ）</strong>，使用其余的位来表示。只有在 lock_type 的值为</p>
<p>   LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p>
<ul>
<li><p>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</p>
</li>
<li><p>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </p>
</li>
<li><p>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。</p>
</li>
<li><p>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。</p>
</li>
</ul>
<p>​      其他的类型：还有一些不常用的类型我们就不多说了。</p>
<p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：</p>
<p>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也就是当前事务尚未获取到锁，处在等待状态；</p>
<p>当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</p>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题</p>
<h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>mvcc（Multiversion Concurrency Control）是多版本并发控制，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<p><strong>普通的SELECT语句</strong>在READ COMMITTED和REPEATABLE READ隔离级别下会使用到<strong>MVCC读取记录</strong>：</p>
<ol>
<li><p>在 <strong>READ COMMITTED</strong> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就是避免了脏读现象；</p>
</li>
<li><p>在 <strong>REPEATABLE READ</strong> 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。</p>
</li>
</ol>
<h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ，非阻塞并发读 ，而这个读指的就是 <strong>快照读</strong> , 而非 <strong>当前读</strong> 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)</p>
<h2 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h2><h3 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h3><p>跳过密码验证： 在mysql的my.cnf配置文件中的  [mysql Id]  下面添加这么一句话 就可以跳过密码验证 </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>

<p>直接登录</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure>

<p>登陆mysql后就可以修改密码了（针对mysql5.7）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> authentication_string=PASSWORD(&#x27;<span class="number">123456</span>&#x27;) where User=&#x27;root&#x27;; </span><br></pre></td></tr></table></figure>

<p>重新刷一下磁盘内容</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">flush privileges; </span><br></pre></td></tr></table></figure>


<p>然后改回my.cnf的 skip-grant-tables 是其变为注释或删除</p>
<p>然后重启mysql。</p>
<hr>
<p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<hr>
<p>查看引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<hr>
<p>查看默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<hr>
<p>创建表时指定存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改表的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<hr>
<p>查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名 \G;</span><br></pre></td></tr></table></figure>

<hr>
<p>开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">#或</span><br><span class="line">START transaction 添加的修饰符;（ READ ONLY） （ READ WRITE）</span><br></pre></td></tr></table></figure>

<hr>
<p>查看数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<hr>
<p>查看正在等待的锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<hr>
<p>根据查询到的锁 进行详情的查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br></pre></td></tr></table></figure>

<p>原文链接：</p>
<p><a href="https://blog.csdn.net/xfcy1990/article/details/90026089">(35条消息) 建索引的几大原则_烂笔头.的博客-CSDN博客_索引创建原则</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2022/07/11/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最懒的人就是整天忙得没时间学习、反思、成长的人。"><a href="#最懒的人就是整天忙得没时间学习、反思、成长的人。" class="headerlink" title="最懒的人就是整天忙得没时间学习、反思、成长的人。"></a><strong>最懒的人就是整天忙得没时间学习、反思、成长的人。</strong></h1><span id="more"></span>



<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>三个遍历</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>先根节点      再左子节点     最后右子节点</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>先左子节点    再根节点       最后右子节点</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先左子节点     再右子节点   最后根节点</p>
<p>前中后遍历的<strong>顺序都是相当于根节点</strong>来说的 前中后的顺序就是遍历的根节点的顺序 但无论是哪个遍历方式 左右子节点的顺序都是先左后右。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>左子节点&lt;根节点&lt;右子节点</p>
<p>题目：</p>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java的多线程和并发"><a href="#Java的多线程和并发" class="headerlink" title="Java的多线程和并发"></a>Java的多线程和并发</h1><p>java的尽头是服务端开发，既然是服务端开发，就需要为多个用户同时进行服务，那么如何保证资源的正常分配或每个用户正常的体验呢？</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>程序（program）</strong></p>
<p>程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码（还没有运行起来），静态对象</p>
<p><strong>进程（process）</strong></p>
<p>进程是程序的一次执行过程，也就是说程序运行起来了，加载到了内存中，并占用了cpu的资源。这是一个动态的过程：有自身的产生、存在和消亡的过程，这也是进程的生命周期。</p>
<p>进程是系统资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</p>
<p><strong>线程（thread）</strong></p>
<p>进程可进一步细化为线程，是一个程序内部的执行路径。</p>
<p>若一个进程同一时间并行执行多个线程，那么这个进程就是支持多线程的。</p>
<p>线程是cpu调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。</p>
<p>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间——&gt; 他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得相互间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全隐患（隐患为到底哪个线程操作这个数据，可能一个线程正在操作这个数据，有一个线程也来操作了这个数据）。</p>
<p><strong>CPU单核和多核的理解</strong></p>
<p><strong>单核</strong>的CPU是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。同时间段内有多个线程需要CPU去运行时，CPU也只能交替去执行多个线程中的一个线程，但是由于其执行速度特别快，因此感觉不出来。</p>
<p><strong>多核</strong>的CPU才能更好的发挥多线程的效率。</p>
<p>对于<strong>Java</strong>应用程序java.exe来讲，至少会存在三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。如过发生异常时会影响主线程。</p>
<p><strong>并行</strong>：多个cpu同时执行多个任务。比如，多个人做不同的事。</p>
<p><strong>并发</strong>：一个cpu（采用时间片）同时执行多个任务。比如，多个人做同一件事。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220530172524328.png" class="" title="image-20220530172524328">

<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220517082401082.png" class="" title="img">

<h1 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h1><h2 id="1-多线程实现的原理"><a href="#1-多线程实现的原理" class="headerlink" title="1. 多线程实现的原理"></a>1. 多线程实现的原理</h2><ul>
<li>Java语言的JVM允许程序运行多个线程，多线程可以通过Java中的java.lang.Thread类来体现。</li>
<li>Thread类的特性<ul>
<li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。</li>
<li>通过Thread方法的start()方法来启动这个线程，而非直接调用run()。</li>
</ul>
</li>
</ul>
<h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h2><p>​		线程的创建有很多种方式：</p>
<p>1.继承Thread类 重写run()方法</p>
<p>2.实现Runnable接口 重写run()方法</p>
<p>3.使用Callable和Future创建线程</p>
<p>4.使用线程池例如用Executor框架</p>
<h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1) 继承Thread类"></a>1) 继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">//继承Thread类 重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何开启</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread1</span>.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在方法中定义一个匿名线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;<span class="comment">//调用该方法即可启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="2）实现Runnable接口"><a href="#2）实现Runnable接口" class="headerlink" title="2）实现Runnable接口"></a>2）实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现接口 实现run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3) 线程池"></a>3) 线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        指定创建的线程池数</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//代表线程总个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//代表线程执行次数</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的本质：</p>
<p>通过调用方法，实际上调用线程工厂，实际上也是使用第一种方式创建线程，指定创建的线程数，这里首先在方法中设定静态属性值，然后 Executors.defaultThreadFactory()创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//核心池大小</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,//最大池大小 ；两者相等</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">       DefaultThreadFactory() &#123;</span><br><span class="line">           <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">           group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                 Thread.currentThread().getThreadGroup();</span><br><span class="line">           namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                         poolNumber.getAndIncrement() +</span><br><span class="line">                        <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                 namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                 <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">               t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">               t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过源码发现，我们通过 <code>DefaultThreadFactory</code> 线程工厂来创建的。它可以设置线程的一些属性，比如：是否守护线程、优先级、线程名、等等，而创建线程使用newThread()方法，实际上也是new Thread()构造方法创建线程。</p>
<h3 id="4）实现Callable-接口"><a href="#4）实现Callable-接口" class="headerlink" title="4）实现Callable 接口"></a>4）实现Callable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这是就需要用到 Callable 接口。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Thread4</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//重写call()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">        <span class="comment">//方法一：使用线程池</span></span><br><span class="line">        <span class="comment">//1.创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    	<span class="comment">// 2、提交任务，并用 Future提交返回结果</span></span><br><span class="line">    	Future&lt; Integer &gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法二：使用FutureTask 实现类的支持</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Thread4</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread4</span>();</span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(td);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();  <span class="comment">//FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Callable和Runnable类似，区别在于Runnable是没有返回值的，<strong>它们的本质都是定义线程要做的任务（call 或 run 方法里面的逻辑），而不是说他们本身就是线程</strong>。但无论有无返回值，它们都是需要被线程执行。</p>
<p>Callable可以提交到线程池执行，通过 sumbit 方法提交。</p>
<h3 id="创建线程方式总结："><a href="#创建线程方式总结：" class="headerlink" title="创建线程方式总结："></a>创建线程方式总结：</h3><p>Thread类的run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么多创建线程方式，实际上的创建线程只有一种方式，就是继承Thread类，而<strong>Runnable接口，实际上是定义了一个线程的任务阶段的执行内容，并不是创建了一个完整的线程的生命周期（从新建到死亡）</strong>，而run()方法，就是执行的内容，可Runnable方式，它启动线程还是需要调用 start 方法（因为是 Native 方法我们看不到具体逻辑）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(Runnable target).start()</span><br></pre></td></tr></table></figure>

<p>所以，当我们使用Thread类去重写run()方法的时候，才是创建一个线程的完整生命周期。</p>
<h1 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h1><p>当多个线程进行并发执行时，为了资源相互之间的抢占和确保资源分配的可靠，就衍生出了很多解决问题的办法。那么如果想解决问题，就得知道问题是如何出现的，这样问题就解决了一半，那么并发问题是如何产生的呢？下面一个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadStudy01</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TestThreadStudy01</span> <span class="variable">testThreadStudy01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThreadStudy01</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Th1</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Th1</span>();</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="type">Th2</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Th2</span>();</span><br><span class="line">        th2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Th1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (TestThreadStudy01.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TestThreadStudy01.count--;</span><br><span class="line">                System.out.println(TestThreadStudy01.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Th2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//模拟并发</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TestThreadStudy01.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TestThreadStudy01.count--;</span><br><span class="line">                System.out.println(TestThreadStudy01.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个静态变量为count，然后两个线程去共享消耗，然后模拟并发的场景，我们发现，会出现操作同一变量的情况。</p>
<details>   
    <summary>查看运行结果</summary>   
    <pre>
    <code>
结束
count=100
99
98
97
96
95
94
93
93
92
91
90
90
89
88
87
86
85
85
84
84
83
83
82
82
80
81
79
79
78
77
76
76
75
74
73
73
72
71
70
69
68
67
66
65
64
63
61
61
59
60
58
58
57
56
54
55
53
52
51
51
50
50
49
49
48
47
46
45
44
43
42
42
41
41
40
39
38
37
36
36
35
34
33
32
31
31
30
29
28
27
26
26
25
24
23
22
21
21
20
20
19
19
18
18
17
16
15
14
13
12
11
11
10
9
8
7
6
6
5
4
3
3
1
2
0
0  
    </code>
    </pre> 
</details>

<p>出现这样的问题是绝对不允许的，那么我们该如何解决呢？</p>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全 - 如果线程执行过程中不会产生共享资源的冲突，则线程安全。</p>
<p>线程不安全 - 如果有多个线程同时在操作主内存中的变量，则线程不安全。</p>
<h2 id="实现线程安全的几种方式"><a href="#实现线程安全的几种方式" class="headerlink" title="实现线程安全的几种方式"></a>实现线程安全的几种方式</h2><p><strong>1.互斥同步锁（悲观锁）</strong></p>
<p>1）Synchorized</p>
<p>2）ReentrantLock</p>
<p>互斥同步锁也叫做阻塞同步锁，特征是会对没有获取锁的线程进行阻塞。要理解互斥同步锁，首选要明白什么是互斥什么是同步。简单的说互斥就是非你即我，同步就是顺序访问。互斥同步锁就是以互斥的手段达到顺序访问的目的。操作系统提供了很多互斥机制比如信号量，互斥量，临界区资源等来控制在某一个时刻只能有一个或者一组线程访问同一个资源。Java里面的互斥同步锁就是Synchorized和ReentrantLock，前者是由语言级别实现的互斥同步锁，理解和写法简单但是机制笨拙，在JDK6之后性能优化大幅提升，即使在竞争激烈的情况下也能保持一个和ReentrantLock相差不多的性能，所以JDK6之后的程序选择不应该再因为性能问题而放弃synchorized。</p>
<p>ReentrantLock是API层面的互斥同步锁，需要程序自己打开并在finally中关闭锁，和synchorized相比更加的灵活，体现在三个方面：等待可中断，公平锁以及绑定多个条件。但是如果程序猿对ReentrantLock理解不够深刻，或者忘记释放lock，那么不仅不会提升性能反而会带来额外的问题。另外synchorized是JVM实现的，可以通过监控工具来监控锁的状态，遇到异常JVM会自动释放掉锁。而ReentrantLock必须由程序主动的释放锁。</p>
<p>互斥同步锁都是可重入锁，好处是可以保证不会死锁。但是因为涉及到核心态和用户态的切换，因此比较消耗性能。JVM开发团队在JDK5-JDK6升级过程中采用很多锁优化机制来优化同步无竞争情况下锁的性能。比如：<strong>自旋锁和适应性自旋锁，轻量级锁，偏向锁，锁粗化和锁消除。</strong></p>
<p><strong>2.非阻塞同步锁（乐观锁）</strong></p>
<ol>
<li>原子类（CAS）</li>
</ol>
<p>非阻塞同步锁也叫乐观锁，相比悲观锁来说，它会先进行资源在工作内存中的更新，然后根据与主存中旧值的对比来确定在此期间是否有其他线程对共享资源进行了更新，如果旧值与期望值相同，就认为没有更新，可以把新值写回内存，否则就一直重试直到成功。它的实现方式依赖于处理器的机器指令：</p>
<p>CAS（Compare And Swap）</p>
<p>JUC中提供了几个Automic类以及每个类上的原子操作就是乐观锁机制不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p>
<p>非阻塞锁是不可重入的，否则会造成死锁。</p>
<p><strong>3.无同步方案</strong></p>
<p>1）可重入代码</p>
<p>在执行的任何时刻都可以中断-重入执行而不会产生冲突。特点就是不会依赖堆上的共享资源</p>
<p>2）ThreadLocal&#x2F;Volaitile</p>
<p>线程本地的变量，每个线程获取一份共享变量的拷贝，单独进行处理。</p>
<p>3）线程本地存储</p>
<p>如果一个共享资源一定要被多线程共享，可以尽量让一个线程完成所有的处理操作，比如生产者消费者模式中，一般会让一个消费者完成对队列上资源的消费。典型的应用是基于请求-应答模式的web服务器的设计。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><h1 id="ReentrantLock不可打断模式与可打断模式"><a href="#ReentrantLock不可打断模式与可打断模式" class="headerlink" title="ReentrantLock不可打断模式与可打断模式"></a>ReentrantLock不可打断模式与可打断模式</h1><h1 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h1><h2 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a>相似点</h2><p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
<h2 id="功能区别："><a href="#功能区别：" class="headerlink" title="功能区别："></a>功能区别：</h2><p>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p>
<p>ReentrantLock类提供了一些高级功能，主要有以下3项：</p>
<p>①等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。</p>
<p>②公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p>
<p>③锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>
<h2 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h2><p>很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<h2 id="性能的区别："><a href="#性能的区别：" class="headerlink" title="性能的区别："></a>性能的区别：</h2><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>Synchorized和ReentrantLock的性能比较</p>
<p>无可置疑，synchronized的性能确实要比ReentrantLock差个20%-30%</p>
<p>Synchronized适合于并发竞争低的情况，因为Synchronized的锁升级如果最终升级为重量级锁在使用的过程中是没有办法消除的，意味着每次都要和cpu去请求锁资源，而ReentrantLock主要是提供了阻塞的能力，<strong>通过在高并发下线程的挂起，来减少竞争，提高并发能力</strong></p>
<h2 id="是否可手动释放："><a href="#是否可手动释放：" class="headerlink" title="是否可手动释放："></a><strong>是否可手动释放：</strong></h2><p>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。</p>
<h2 id="锁是否可以被中断："><a href="#锁是否可以被中断：" class="headerlink" title="锁是否可以被中断："></a><strong>锁是否可以被中断：</strong></h2><p>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
<h2 id="上锁的内容："><a href="#上锁的内容：" class="headerlink" title="上锁的内容："></a><strong>上锁的内容：</strong></h2><p>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢。</p>
<h2 id="二者原理："><a href="#二者原理：" class="headerlink" title="二者原理："></a>二者原理：</h2><h3 id="1-Synchronized上锁过程"><a href="#1-Synchronized上锁过程" class="headerlink" title="1.Synchronized上锁过程"></a>1.Synchronized上锁过程</h3><p><img src="https://pic3.zhimg.com/80/v2-e411138c62b82128f475e3e999c30632_1440w.jpg" alt="img"><br>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h3><p><strong>ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁，并且使用了AQS队列。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态</strong>。</p>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>的缩写，这个是个内部实现了两个队列的抽象类，分别是<strong>同步队列</strong>和<strong>条件队列</strong>。其中<strong>同步队列</strong>是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而<strong>条件队列</strong>是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，<code>AQS</code>所做的就是管理这两个队列里面线程之间的<strong>等待状态-唤醒</strong>的工作。</p>
<p>ReentrantLock通过设置参数调整是否为公平锁和非公平锁</p>
<p>内部结构：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aa1836d0ac5b0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中<code>Sync</code>内部类继承自<code>AQS</code>，另外的两个内部类继承自<code>Sync</code>，这两个类分别是用来<strong>公平锁和非公平锁</strong>的。<br> 通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，**<code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁**。</p>
<p>ReentrantLock的lock() 和 unlock() 方法的流程：</p>
<h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol>
<li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li>
<li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>这是<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aab7befb2e5de~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol>
<li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li>
<li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li>
<li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li>
<li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aad4a8e578933~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>公平锁的实现原理：</p>
<h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol>
<li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li>
<li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li>
<li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li>
</ol>
<p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/23/169aaf5a27ee58d5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>对比表：</p>
<table>
<thead>
<tr>
<th></th>
<th>ReentrantLock</th>
<th>Synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>通过<code>AQS</code>实现</td>
<td>通过<code>JVM</code>实现，其中<code>synchronized</code>又有多个类型的锁，除了重量级锁是通过<code>monitor</code>对象(操作系统mutex互斥原语)实现外，其它类型的通过对象头实现。</td>
</tr>
<tr>
<td>是否可重入</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>公平锁</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>非公平锁</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>锁的类型</td>
<td>悲观锁、显式锁</td>
<td>悲观锁、隐式锁(内置锁)</td>
</tr>
<tr>
<td>是否支持中断</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否支持超时等待</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否自动获取&#x2F;释放锁</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="volatile、ThreadLocal的使用场景和原理"><a href="#volatile、ThreadLocal的使用场景和原理" class="headerlink" title="volatile、ThreadLocal的使用场景和原理"></a>volatile、ThreadLocal的使用场景和原理</h1><p>vloatile关键字：</p>
<p>指令重排</p>
<p>原文链接：<a href="https://cloud.tencent.com/developer/article/1684031">创建线程到底有多少种方式？ - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://blog.csdn.net/fuyuwei2015/article/details/83719444">(31条消息) ReentrantLock原理_孙悟空2015的博客-CSDN博客_reentrantlock原理</a></p>
<p><a href="https://blog.csdn.net/xindoo/article/details/103637547">(28条消息) ReentrantLock源码解析_xindoo的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/263762343">Java并发编程——深入理解自旋锁 - 知乎 (zhihu.com)</a></p>
<p><a href="https://juejin.cn/post/6844903805683761165">https://juejin.cn/post/6844903805683761165</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2022/06/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>什么是线程池？</strong></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661">线程池_百度百科 (baidu.com)</a></p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在<a href="https://baike.baidu.com/item/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81/2886980">托管代码</a>中空闲（如正在等待某个事件）,则线程池将插入另一个<a href="https://baike.baidu.com/item/%E8%BE%85%E5%8A%A9%E7%BA%BF%E7%A8%8B/4746601">辅助线程</a>来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>说实话，百度的答案我没看懂。</p>
<span id="more"></span>

<p><strong>创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？</strong></p>
<ol>
<li>核心参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数量大小 </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 线程池最大容纳线程数 </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, // 线程空闲后的存活时长 </span></span><br><span class="line"><span class="params">                          TimeUnit unit, //缓存异步任务的队列 //用来构造线程池里的worker线程 </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程池任务满载后采取的任务拒绝策略 </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>核心说明</li>
</ol>
<ol>
<li>当线程池中线程数量小于 corePoolSize 则创建线程，并处理请求。</li>
<li>当线程池中线程数量大于等于 corePoolSize 时，则把请求放入 workQueue 中,随着线程池 中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从 workQueue 中取 任务并处理。</li>
<li>当 workQueue 已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目 达到maximumPoolSize（最大线程数量设置值）。</li>
<li>如果线程池中线程数大于 maximumPoolSize 则使用 RejectedExecutionHandler 来进行任 务拒绝处理。</li>
</ol>
<ol start="3">
<li>线程池大小分配</li>
</ol>
<p>线程池究竟设置多大要看你的线程池执行的什么任务了，CPU密集型、IO密集型、混合型，任 务类型不同，设置的方式也不一样。 </p>
<p>任务一般分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线 程池。</p>
<p>3.1）CPU密集型 </p>
<p>尽量使用较小的线程池，一般Cpu核心数+1</p>
<p>3.2）IO密集型 </p>
<p>方法一：可以使用较大的线程池，一般CPU核心数 * 2 </p>
<p>方法二：（线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
<p>3.3）混合型 可以将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，按情况而定</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2022/05/16/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><p>Innodb存储引擎的实现原理 索引的原理：</p>
<p>内存泄露怎么解决：</p>
<p>线程的生命周期：</p>
<img src="/2022/05/16/%E9%9D%A2%E8%AF%95/image-20220517082401082.png" class="" title="image-20220517082401082">

<p>缓存穿透、缓存击穿、缓存雪崩：</p>
<p>hashmap的实现原理</p>
<p>redis的数据类型：String（字符串） Hash（哈希 k-v） Set（集合） Zset（有序集合） List（列表）</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>回文子串：</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/05/11/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<img src="/2022/05/11/%E9%9B%86%E5%90%88/1166662.jpg" class="" width="1166662">

<h2 id="Collection："><a href="#Collection：" class="headerlink" title="Collection："></a>Collection：</h2><img src="/2022/05/11/%E9%9B%86%E5%90%88/20180803184706534.png" class="" width="20180803184706534">

<span id="more"></span>

<p>1.List:  元素可重复 可以多个元素为null </p>
<p>2.Set:  添加的元素不可重复</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="1-ArrayList："><a href="#1-ArrayList：" class="headerlink" title="1.ArrayList："></a>1.ArrayList：</h3><p>​	底层使用数组实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//首先了解一下几个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		ArrayList的空参构造器 构建一个空间大小为10的空链表</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		ArrayList的指定列表大小的构造方法</span></span><br><span class="line"><span class="comment">		当传入的参数为0的时候 会自动使用ArrayList的static数组EMPTY_ELEMENTDATA  这是一个空的对象数组</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		转化集合为ArrayList的构造方法 首先将集合使用Collection的toArray()方法 转化为数组</span></span><br><span class="line"><span class="comment">		然后进行判断 如果该集合的内容大小为0 则直接等效于上一个构造方法的指定长度为0的情况</span></span><br><span class="line"><span class="comment">					否则 则需要判断内容是否为Object类型</span></span><br><span class="line"><span class="comment">							如果为Object类型的 则直接将其赋值给ArrayList的Object[]数组</span></span><br><span class="line"><span class="comment">							否则 将其内容转化为Obejct类型</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1）扩容：1.空间扩容：先把原来数组内的元素复制到另一个空间大小更大的数组中：</p>
<p>​				2.添加元素：把新元素添加到扩容后的数组中</p>
<p>​			</p>
<p>​	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加方法 首先ensureCapacityInternal确定大小</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*如果 当前数组和默认的初始数组相同 那么就选择10和size+1的更大值 为10</span></span><br><span class="line"><span class="comment">	*也验证了 ArrayList使用无参构造函数的时候第一次添加元素时 数组初始化为10</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 如果数组elementData的长度小于最小需要的容量（minCapacity）就需要扩容数组</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//扩容机制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	*最大容量 2^18-8</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *	新数组的大小=（原数组大小&gt;&gt;1）+原数组大小 相当于1.5倍</span></span><br><span class="line"><span class="comment">     * 如果太小 则使用原数组大小 如果太大 则使用最大数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	2）安全：ArrayList是非线程安全的</p>
<p>​	3）效率：因为底层根据数组实现 所以对集合内元素的移动操作相对于链表是效率较慢的 适合快速随机存取</p>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList:"></a>2.LinkedList:</h3><p>​	底层使用双向链表实现 继承于AbstractSequentialList</p>
<p>​	1）扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加元素的方法 直接将元素添加到最后一个位置</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  2）效率：LinkedList是根据双向链表实现 在增删元素的效率 相对ArrayList略高 但是在存储空间方面 因为要存储指向上一个和下一个元素位置的索引 所以元素的存储空间相对ArrayList较大</p>
<p> 3）安全：和ArrayList不一样 LinkedList是非线程安全的</p>
<h3 id="3-Vertor"><a href="#3-Vertor" class="headerlink" title="3.Vertor"></a>3.Vertor</h3><p>vertor内部实现是类似于ArrayList</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>数据以键值对的形式进行存储</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/%E5%9B%BE%E7%89%871.png" class="" title="图片1">

<h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li><p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value 放入链表中</p>
</li>
<li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<h4 id="扩容："><a href="#扩容：" class="headerlink" title="扩容："></a>扩容：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Table数组的初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//Table数组的最大长度： 1&lt;&lt;302^30=1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//负载因子：默认值为0.75。 当元素的总个数 &gt; 当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>



<h4 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span></span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;　　　　　　</span><br><span class="line">        inflateTable(threshold);<span class="comment">//如果为空，则初始化</span></span><br><span class="line">    &#125;<span class="comment">//判断key是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)<span class="keyword">return</span> putForNullKey(value);<span class="comment">//hashmap允许key为空</span></span><br><span class="line">    <span class="comment">//计算当前key的哈希值　　　</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;　　　　　　</span><br><span class="line">        Object k;<span class="comment">//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);　　　　　　　</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;　　　</span><br><span class="line">    <span class="comment">//存放值的具体方法</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">　　　　<span class="comment">//1、判断当前个数是否大于等于阈值</span></span><br><span class="line">　　　　<span class="comment">//2、当前存放是否发生哈希碰撞</span></span><br><span class="line">　　　　<span class="comment">//如果上面两个条件否发生，如果发生，那么就扩容</span></span><br><span class="line">　　　　<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　<span class="comment">//扩容，并且把原来数组中的元素重新放到新数组中</span></span><br><span class="line">　　　　　　resize(<span class="number">2</span> * table.length);</span><br><span class="line">　　　　　　hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">　　　　Entry[] oldTable = table;</span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">　　　　<span class="comment">//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作</span></span><br><span class="line">　　　　<span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">　　　　　　threshold = Integer.MAX_VALUE;</span><br><span class="line">　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">　　　　<span class="comment">// transfer()方法把原数组中的值放到新数组中</span></span><br><span class="line">　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容后为新的数组引用</span></span><br><span class="line">　　　　table = newTable;</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容新的阈值</span></span><br><span class="line">　　　　threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h4><p>在JDK7中，当new Hashmap()的时候会对对象进行初始化，而JDK8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。 .在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行</p>
<p>扩容:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Hash 这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出</p>
<p>所以 当散列值（Hash值）相同的时候 不可以判断为 两个输入就相同</p>
<p>哈希碰撞：两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。</p>
<p>将拥有相同哈希值的对象组织成一个链表放在hash值所对应的 bucket下，但相比</p>
<p>于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即</p>
<p>2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的</p>
<p>bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还</p>
<p>需要对hashCode作一定的优化 hash()函数</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，</p>
<p>高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低</p>
<p>hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123; </span><br><span class="line">     <span class="type">int</span> h; </span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将生成的hashcode值的高16位于低16位进行异或运算，这样得到的值再进行相与，一得到最散列的下标值。</span></span><br></pre></td></tr></table></figure>

<p>1.8新增红黑树</p>
<p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减</p>
<p>少，但是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍</p>
<p>历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使</p>
<p>得遍历复杂度降低至O(logn)。</p>
<p><strong>HashMap是如何解决哈希冲突的：</strong></p>
<ol>
<li><p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p>
</li>
<li><p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p>
</li>
<li><p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。（是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)）。</p>
</li>
</ol>
<p><strong>HashMap</strong> <strong>的长度为什么是2的幂次方</strong></p>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p>那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组</p>
<p>存储下标位置的随机性&amp;均匀性， 终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p>
<p><strong>HashMap的添加元素的过程：</strong></p>
<p><strong>( 1.)第一种就是数组下标下内容为空：</strong><br>这种情况没什么好说的，为空据直接占有这个slot槽位就好了，然后把当前.put方法传进来的key和value包装成一个node对象,放到这个slot中就好了。</p>
<p><strong>( 2.)第二种情况就是数组下标下内容不为空，但它引用的node还没有链化：</strong><br>这种情况下先要对比一下这个node对象的key与当前put对象的key是否完全.相等，如果完全相等的情况下，就行进行replace操作，把之前的槽位中node.下的value替换成新的value就可以了，否则的话这个put操作就是一个正儿.八经的hash冲突,这种情况在slot槽位后面追加一个node就可以了,用尾插法 ( 前面讲过，jdk7是把新增元素添加到头部节点，而jdk8则添加到尾部节点)。</p>
<p><strong>( 3.)第三种就是该数组下标下内容已经被链化了：</strong><br>这种情况和第二种情况处理很相似，首先也是迭代查找node，看看链表上中元素的key，与当前传过来的key是否完全一致，如果完全一致的话还是repleace操作，用put过来的新value替换掉之前node中的value，否则的话就是一致迭代到链表尾节点也没有匹配到完全一致的node，就和之前的一样，把put进来数据包装成node追加到链表的尾部，再检查一下当前链表的长度，有没有达到树化阈值，如果达到了阈值就调用一个树化方法，树化操作都是在这个方法里完成的。</p>
<p><strong>( 4.)第四种情况就是冲突很严重的情况下，这个链表已经转化成红黑树了：</strong><br>红黑树就比较复杂 要将清楚这个红黑树还得从TreeNode说起 TreeNode继承了Node结构，在Node基础上加了几个字段，分别是指向父节点parent字段，指向左子节点left字段，指向右子节点right字段，还有一个表示颜色的red字段，这就是TreeNode的基本结构，然后红黑树的插入操作，首先找到一个合适的插入点，就是找到插入节点的父节点，然后红黑树它又满足二叉树的所有特性，所以找这个父节点的操作和二叉树排序是完全一致的，然后说一下这个二叉树排序，其实就是二分查找算法映射出来的结构，就是一个倒立的二叉树，然后每个节点都可以有自己的子节点，本且左节点小于但前节点，右节点大于当前节点，然后每次向下查找一层就能那个排除掉一半的数据，查找效率非常的高效，当查找的过程中也是分情况的</p>
<p><strong>HashMap的负载因子为什么是0.75？</strong></p>
<ol>
<li>阈值(threshold) &#x3D; 负载因子(loadFactor) x 容量(capacity) 根据HashMap的扩容机制，他会保证容量(capacity)的值永远都是2的幂 为了保证负载因子x容量的结果是一个整数，这个值是0.75(4&#x2F;3)比较合理，因为这个数和任何2的次幂乘积结果都是整数。</li>
<li>理论上来讲，负载因子越大，导致哈希冲突的概率也就越大，负载因子越小，费的空间也就越大,这是一个无法避免的利弊关系，所以通过一个简单的数学推理，可以测算出这个数值在0.75左右是比较合理的</li>
</ol>
<p><strong>HashMap使用String作为key  有什么好处</strong></p>
<p>String作为hashMap的key HashMap是使用hashCode值作为参数 存放key的位置 而String对象是不可变的 在创建的时候 就已经缓存Hash Code值 所以存储对象更快</p>
<p><strong>HashMap 链表转化为红黑树，以及红黑树转化为链表的条件</strong></p>
<p>链表转化为红黑树：hashMap并不是在链表元素个数大于8就一定会转换为红黑树，而是先考虑扩容，扩容达到默认限制后才转换。</p>
<p>红黑树转化为链表：hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。</p>
<h3 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2.ConcurrentHashMap"></a><strong>2.ConcurrentHashMap</strong></h3><p>ConcurrentHashMap的内部实现对整个桶分组进行了分段分割Segment 每一把锁值锁住一部分数据 不会出现资源的恶行竞争 提高效率</p>
<p>（默认分配16个Segment，从效率上来讲 比HashMap高16倍）。</p>
<p>**ConcurrentHashMap 和HashMap的不同 **</p>
<p>ConcurrentHashMap是实现线程安全的ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁行保护，相对于HashTable的synchronized 锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启了一种全新的方式实现,利用CAS算法。） </p>
<p>所以ConcurrentHashMap也分为1.7和1.8两个jdk版本的不同</p>
<p>1.7</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/webp.webp" class="" title="img">

<p>1.8</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用<strong>Node + CAS + Synchronized</strong>来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N 倍。</p>
<p>每一个结点为node  而红黑树的结点为TreeNode</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/image-20220516110334299.png" class="" title="image-20220516110334299">

<p>使用CAS的部分 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    tab = initTable();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3.TreeMap"></a>3.TreeMap</h3><p>根据保存的key进行排序（默认排序，可自己定义），默认是按照升序排序的 ，并且不允许key的值为null <strong>非线程同步</strong></p>
<p>排序是SortedMap定义的方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回元素比较器。如果是自然顺序，则返回null；</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回从fromKey到toKey的集合：含头不含尾</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从头到toKey的集合：不包含toKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从fromKey到结尾的集合：包含fromKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer,Integer&gt; map= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * int compare(Object o1, Object o2) 返回一个基本类型的整型，</span></span><br><span class="line"><span class="comment">     * 返回负数表示：o1 小于o2，</span></span><br><span class="line"><span class="comment">     * 返回0 表示：o1和o2相等，</span></span><br><span class="line"><span class="comment">     * 返回正数表示：o1大于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b-a;<span class="comment">//倒序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong>TreeMap <strong>？</strong></p>
<p>对于在Map中插入、删除和查询元素这类操作，HashMap是 好的选择。</p>
<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，</p>
<p>也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h3 id="4-HashTable"><a href="#4-HashTable" class="headerlink" title="4.HashTable"></a>4.HashTable</h3><p>和hashmap类似 但不允许key或value为null 支持线程同步 只允许一条线程同时操作HashTable <strong>线程同步</strong></p>
<p>HashTable基本被淘汰</p>
<p><strong>与HashMap的区别</strong></p>
<p>1.线程安全; HashMap是非线程安全的 HashTable是线程安全的 HashTable的内部方法基本都经过synchronized修饰</p>
<p>（但是如果想要保证线程安全的话 请使用ConcurrentHashMap吧）</p>
<p>2.效率： 众所周知 鱼和熊掌不可兼得 保证了安全性 那一定会牺牲效率 </p>
<p>3.对null的支持： HashMap中 null可以作为键 但是只能有一个 对应的value可以多个为null </p>
<p>​								HashTable中 null如果添加 不论是key or value 则直接抛空指针异常NullPointerException。</p>
<p>4.初始容量大小的不同：</p>
<p>①如果不指定容量 HashTable的大小是11  每次扩容为2n+1</p>
<p>​	而hashMap的默认初始化大小是16	扩容为两倍（左移一位）</p>
<p>②HashTable如果指定了大小 则会初始化为指定大小 而HashMap则会在指定大小的基础上 扩充为2的幂次方</p>
<p>5.使用场景 ：HashTable如果是单线程使用 则推荐使用HashMap 如果是多线程使用 则推荐ConcurrentHashMap</p>
<p>​						因为HashTable是将整个表都锁 减少了并发的效率</p>
<h3 id="5-LinkedListMap"><a href="#5-LinkedListMap" class="headerlink" title="5.LinkedListMap"></a>5.LinkedListMap</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>不允许重复的元素存在 </p>
<p>只允许一个元素为null </p>
<p> 非线程安全</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>元素是无序的</p>
<p>首先是构造方法 直接创建了一个HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>说明 Set是用Map的key存储内容 而map的value 是在set中创建的Object类对象PRESENT</p>
<p>PRESENT为了使用HashMap而创建的一个Object对象，用来占掉value的位置，无其他意义 。</p>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>因为结构就是根据Hashmap生成 添加元素的方法也是根据Hashmap的put方法，结构同上。</p>
<p>hashset为什么要重写hashcode和equals方法？<br>在Hashset种 为了保证元素的不重复性 首先计算添加元素的hash值 计算hash值后 在map的区域算法计算去应该添加的桶位置<br>如果该位置有没有元素 则直接 添加<br>如果该位置铀元素 则进行equals（）判断 如果这两个内容相同 则替换原来的元素<br>                    如果不同 则添加到该位置元素的后面 以链表的形式存储 之后就和Hashmap相同</p>
<p>但是如果不重写HashCode  那么对于一些引用类型的对象 即使两者的内容和属性完全相同 两者的Hashcode也不会相同 那么就会出现Set种存在两个相同应用类型的对象<br>所以 当重写HashCode 那么对于两个内容完全相同的元素 也会计算出相同的HashCode值 完全符合Set 元素不重复的特点<br>equals()比较的是 当出现Hash冲突的时候 判断两个元素是否是完全相同的元素 如果不是才会添加<br>使用hashcode进行判断 也大大的减少了equals()的比较次数 增加了效率。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>元素是有序的</p>
<p>元素是使用它们的自然顺序来排序的，或者通过在设置的创建时提供的比较器来排序的，这取决于使用的是哪个构造函数</p>
<p>构造方法：同样是借助Map 但是TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层结构：二叉树排序。 </p>
<h5 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h5><p>Comparable与Comparator实际上是TreeSet集合的两种实现方式，用来实现对象的排序。</p>
<ol>
<li>Comparable称为元素的自然顺序，或者叫做默认顺序。</li>
<li>Comparator称为元素定制排序。</li>
</ol>
<p>​	</p>
<p>巨人的肩膀：</p>
<p><a href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>​	</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
