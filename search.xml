<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IOStream</title>
    <url>/2022/05/18/IOStream/</url>
    <content><![CDATA[<h1 id="IO流的继承关系和分类"><a href="#IO流的继承关系和分类" class="headerlink" title="IO流的继承关系和分类"></a>IO流的继承关系和分类</h1><img src="/2022/05/18/IOStream/image-20220518162023270.png" class="" title="image-20220518162023270">

<span id="more"></span>

<img src="/2022/05/18/IOStream/image-20220518162100236.png" class="" title="image-20220518162100236">

<img src="/2022/05/18/IOStream/image-20220518162120508.png" class="" title="image-20220518162120508">

<img src="/2022/05/18/IOStream/image-20220518162134464.png" class="" title="image-20220518162134464">
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/06/07/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>另一种操作系统</p>
<p>服务器操作系统</p>
<p>主要针对CentOS7进行操作讲解</p>
<span id="more"></span>

<h2 id="Linux文件信息位置"><a href="#Linux文件信息位置" class="headerlink" title="Linux文件信息位置"></a>Linux文件信息位置</h2><h3 id="1-网卡信息存放位置"><a href="#1-网卡信息存放位置" class="headerlink" title="1.网卡信息存放位置"></a>1.网卡信息存放位置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">/* 如果是dell的物理服务器 */</span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-em1或em2 ，em3，em4</span><br><span class="line">/* 如果是云服务器 */</span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure>

<h3 id="2-防火墙的开启和关闭"><a href="#2-防火墙的开启和关闭" class="headerlink" title="2.防火墙的开启和关闭"></a>2.防火墙的开启和关闭</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br><span class="line">或</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<p>启动防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld.service  		--启动firewall</span><br><span class="line">systemctl enable firewalld.service		--开机时启动firewall</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service    		--停止firewall</span><br><span class="line">systemctl disable firewalld.service		--禁止firewall开机启动</span><br></pre></td></tr></table></figure>

<p>重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<p>查看防火墙是否开启自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled firewalld.service;echo $?</span><br></pre></td></tr></table></figure>

<p>查看已启动的服务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files|grep enabled</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/05/16/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p><strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<p>提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a><strong>JRE</strong></h2><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java序，计算机中只需要安装JRE即可。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h2><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>从包含关系来讲：<strong>JDK&gt;JRE&gt;JVM</strong></p>
<img src="/2022/05/16/JVM/image-20220516150612535.png" class="" title="image-20220516150612535">

<span id="more"></span>

<p>既然谈到了JVM 众所周知 JVM是java语言的灵魂 那么JVM给java带来了什么？</p>
<p>1.跨平台性：所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。</p>
<p>2.实现原理：Java程序是通过java虚拟机在系统平台上运行的，<strong>只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</strong></p>
<p>众所周知 <strong>java文件运行的流程</strong>如下：</p>
<p>.java文件 由开发人员编写 经过编译后 生成.class文件 ——即字节码文件 该.<strong>class文件不面向任何机器 只面向虚拟机</strong></p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可 在多种不同的计算机上运行。<strong>一次编译 到处运行</strong>作为高级语言 就得有<strong>解释—&gt;编译—&gt;将语言转化为二进制</strong> 这两个步骤 Java是怎么实现的呢？</p>
<p><strong>java中的编译器和解释器：</strong></p>
<p>也可以直接看下面</p>
<p>Java中引入了虚拟机的概念，即在编译程序和机器之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码行。在Java中，这种供虚拟机理解的代码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java源代码(.java文件)----&gt;编译器----&gt;jvm可执行的Java字节码(.class文件)----&gt;jvm----&gt;jvm中的解释器-----&gt; 机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/JVM/image-20220711165236171.png" class="" title="image-20220711165236171">

<p>接下来看一下JVM内部结构：</p>
<h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><h2 id="JVM总体结构"><a href="#JVM总体结构" class="headerlink" title="JVM总体结构"></a>JVM总体结构</h2><img src="/2022/05/16/JVM/image-20220516154322660.png" class="" title="image-20220516154322660">

<p>可以分为两组件 两子系统：</p>
<p><strong>两个子系统</strong>：1.Class loader(类装载)  </p>
<p>​					   2. Execution engine(执行引擎)</p>
<p><strong>两个组件</strong>： 1.Runtime data area(运行时数据区）</p>
<p>​					2.Native Interface(本地接口)。</p>
<blockquote>
<p>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</blockquote>
<blockquote>
<p>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。</p>
</blockquote>
<blockquote>
<p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</blockquote>
<blockquote>
<p>Execution engine（执行引擎）：执行classes中的指令。</p>
</blockquote>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>运行时数据区存在于内存 又称jvm内存模型 分别有五个部分</p>
<blockquote>
<p><strong>程序计数器</strong>:当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选<strong>取下一条需要执行的 字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>:类似虚拟机栈，是为虚拟机使用native本地方法而准备的。具体实现由虚拟机厂商来实现。HotSpot虚拟机中实现与虚拟机栈一致，同时超出大小抛StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>:每个线程私有的空间，由多个栈帧组成，一个方法对应一个栈帧，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大1M，超出跑出StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>:所有线程都可以访问修改，存放的是对象实例，是数据区中占用空间最大的部分，在HotSpot虚拟机中分为新生代和老年代，新生代又分为Eden区和Survivor0区、Survivor1区。</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>:JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。不同虚拟机有不同的实现，oracle的HotSpot在Java7中方法区放在永久代，Java8中方法区放在元空间，并通过GC机制来管理。</p>
</blockquote>
<p>在<strong>线程共享</strong>的角度来分类：</p>
<p>​									<font color=Red><em>方法区,堆 属于线程共享的 | 虚拟机栈, 本地方法栈, 程序计数器不是线程共享的</em></font></p>
<p>**而程序计数器是唯一一个不会出现OOM的区域(Out Of Memory) ** 具体error：(java.lang.OutOfMemoryError)</p>
<p>首先聊一聊<strong>堆</strong>和<strong>方法区</strong>这两个最重要的区域:</p>
<p><strong>堆</strong>:从上面的定义来讲,存放对象实例,就是java中经常操作的对象,堆的物理地址分配对对象是不连续的。</p>
<p>因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩）。 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p><strong>方法区</strong>:存放类的相关信息</p>
<ol>
<li><p>静态变量放在方法区</p>
</li>
<li><p>静态的对象还是放在堆。</p>
</li>
</ol>
<p>既然创建的实例对象都在堆中,那堆中创建的对象多了怎么办,难道堆是一个无穷无尽的空间什么时期的实例对象都收纳吗?</p>
<p>堆空间是怎么决定哪些对象应该保存,哪些对象应该消失呢?难道要java程序员自己去决定吗?这就涉及到了java的垃圾回收机制</p>
<h3 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a><strong>什么是垃圾回收机制</strong></h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h3 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a><strong>什么是GC</strong></h3><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h3 id="垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗"><a href="#垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗" class="headerlink" title="垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?"></a><strong>垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?</strong></h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<h3 id="如何判断对象是否可以被回收（两种垃圾位置分析算法）"><a href="#如何判断对象是否可以被回收（两种垃圾位置分析算法）" class="headerlink" title="如何判断对象是否可以被回收（两种垃圾位置分析算法）"></a><strong>如何判断对象是否可以被回收</strong>（两种垃圾位置分析算法）</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<blockquote>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，</p>
<p>当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</p>
</blockquote>
<blockquote>
<p>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC</p>
<p>Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 </p>
</blockquote>
<p>&#x2F;&#x2F;TODO 可达性算法详解</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对于堆空间,java不同版本的虚拟机会有不同的垃圾回收算法,目前最主流的有:</p>
<h4 id="1-标记-清除算法："><a href="#1-标记-清除算法：" class="headerlink" title="1.标记-清除算法："></a>1.标记-清除算法：</h4><p>标记无用对象，然后进行清除回收。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<h4 id="2-标记-复制算法："><a href="#2-标记-复制算法：" class="headerlink" title="2.标记-复制算法："></a>2.标记-复制算法：</h4><p>按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<h4 id="3-标记-整理算法："><a href="#3-标记-整理算法：" class="headerlink" title="3.标记-整理算法："></a>3.标记-整理算法：</h4><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<h4 id="4-分代算法："><a href="#4-分代算法：" class="headerlink" title="4.分代算法："></a>4.分代算法：</h4><p>根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是新生代和老年 代，新生代分为Eden区和Survior区。<img src="/2022/05/16/JVM/image-20220521095627681.png" class="" title="image-20220521095627681"></p>
<p><strong>分代算法的对象迁移</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到 老年代。</p>
<h3 id="JVM都有哪些垃圾回收器？"><a href="#JVM都有哪些垃圾回收器？" class="headerlink" title="JVM都有哪些垃圾回收器？"></a>JVM都有哪些垃圾回收器？</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种作用于不同分代的收集器，其中于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于收整个Java堆的G1收集器。不同收集器 之间的连线表示它们可以搭配使用。</p>
<img src="/2022/05/16/JVM/image-20220520140939077.png" class="" title="image-20220520140939077">



<details>
<summary>点击查看垃圾回收器详细内容</summary>
Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU
环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不 高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器
的老年代版本；<br>
<b>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</b>： 老年代并行收集 器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。<br>
<b>G1(Garbage First)收集器 (标记-整理算法)</b>： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新
收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同
于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代 或老年代。<br>
</details>

<h3 id="各垃圾回收器的使用位置"><a href="#各垃圾回收器的使用位置" class="headerlink" title="各垃圾回收器的使用位置"></a><strong>各垃圾回收器的使用位置</strong></h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<h3 id="各代适合的垃圾回收算法"><a href="#各代适合的垃圾回收算法" class="headerlink" title="各代适合的垃圾回收算法"></a><strong>各代适合的垃圾回收算法</strong></h3><p>年轻代的堆空间，因为经常生成对象，并且对象的消亡和创建都很频繁，所以该区域需要高效率，能更好利用cpu的垃圾回收算法以保证内存空间的充足，<strong>新生代常常使用标记-复制算法。</strong></p>
<p>老年代的堆空间常常存放不易回收的对象，所以该区域不需要频繁的进行GC，需要考虑的是内存空间的利用，需要足够的空间存放不易回收的老年代对象，<strong>老年代常常使用标记整理算法，CMS的标记清除算法。</strong></p>
<h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p>CMS的垃圾回收算法</p>
<p>CMS的STW</p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a><strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="创建对象的内存分配"><a href="#创建对象的内存分配" class="headerlink" title="创建对象的内存分配"></a>创建对象的内存分配</h3><p>多数情况下，对象都在Eden区被创建，但是当Eden区内存空间不足的时候，虚拟机会进行一次<strong>年轻代的MinorGC</strong>，</p>
<p>如果本次GC以后，依然没有足够的空间，则将启用分配担保机制，在老年代中分配内存。</p>
<h3 id="如果对象太大怎么办？"><a href="#如果对象太大怎么办？" class="headerlink" title="如果对象太大怎么办？"></a><strong>如果对象太大怎么办？</strong></h3><p>大对象是指需要大的连续的内存空间的对象，而大对象如果存放在年轻代，而年轻代使用的是标记复制算法，大对象在两个幸存区之不断复制，占用了其他对象的空间，并且影响了效率。假设大对象是“朝生夕死”的（从GC次数上来讲不会进入老年代），那它占用了年轻的空间，其他对象进入的时候因为大对象的存在会提前触发GC，而大对象在幸存区的空间占比又过大，导致新创建的对象只能添加到老年代，这就加快了老年代GC的时间，对老年代的性能进行了很大的负面影响。<strong>（毕竟老年代的GC效率大概要比年轻代的GC效率低10倍左右）</strong>。如果确定大对象是“朝生夕死”的，可以通过设置JVM对大对象的参数阈值【-XX:PretenureSizeThreshold】，使大对象相对JVM来讲是不再那么大，从而在年轻代就GC（当然会这样影响性能）。</p>
<h3 id="发生在不同区域的GC"><a href="#发生在不同区域的GC" class="headerlink" title="发生在不同区域的GC"></a>发生在不同区域的GC</h3><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</p>
<p><strong>Major GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。</p>
<p><strong>FullGC</strong> 是指发生在整个堆内存的GC ，老年代和年轻代一起GC，应该避免FullGC的发生，会影响JVM的性能。</p>
<p>触发条件：1）System.gc() 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。</p>
<p>​					2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>​					3）通过Minor GC后进入年轻代的平均大小大于老年代的可用内存</p>
<p>FullGC详解</p>
<blockquote>
<p><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC | Plumbr – User Experience &amp; Application Performance Monitoring</a></p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h4 id="方法区存放的具体内容："><a href="#方法区存放的具体内容：" class="headerlink" title="方法区存放的具体内容："></a>方法区存放的具体内容：</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等。</p>
<img src="/2022/05/16/JVM/2128165-20200827223659712-1825753625.png" class="" title="9.4.1_1">

<h4 id="方法区的位置"><a href="#方法区的位置" class="headerlink" title="方法区的位置"></a>方法区的位置</h4><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或进行压缩。”但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于 Java 堆的内存空间。</strong></p>
<p>方法区在 JVM 启动的时候被创建，并且它在实际的物理内存空间中，和 Java 堆区一样都可以是不连续的。在 jdk7 及以前，习惯上把方法区称为永久代。jdk8 开始，使用元空间取代了永久代。本质上，方法区和永久代并不等价，等价仅是对 HotSpot 而言的。</p>
<p>到了 JDK8，永久代的概念被完全废除，改用了在本地内存中实现的元空间（Metaspace）来代替。</p>
<h4 id="运行时常量池和常量池"><a href="#运行时常量池和常量池" class="headerlink" title="运行时常量池和常量池"></a>运行时常量池和常量池</h4><ul>
<li>方法区内部包含了运行时常量池。</li>
<li>字节码文件包含了常量池。</li>
</ul>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p>常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用，此时不再是常量池中的符号地址了，这里换为真实地址。<ul>
<li>运行时常量池相对于 Class 文件常量池的另一重要特征是：具备动态性。</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li>
</ul>
<h4 id="字符串常量池的位置变化"><a href="#字符串常量池的位置变化" class="headerlink" title="字符串常量池的位置变化"></a>字符串常量池的位置变化</h4><p>运行时常量池存和字符串常量池的变化</p>
<p>JDK1.7之前 ：<br>运行时常量池(包含字符串常量池 )存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_1">





<p>JDK1.7 ：<br>字符串常量池被从方法区拿到了堆中；运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223858262-125394764.png" class="" title="9.5_2">





<p>JDK1.8 ：<br>hotspot移除了永久代，用元空间(Metaspace) 取而代之。这时候，字符串常量池还在堆,运行时常量池还在方法区, 只不过方法区的实现从永久代变成元空间(Metaspace)。</p>
<img src="/2022/05/16/JVM/2128165-20200827223940541-1635130641.png" class="" title="9.5_3">



<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><h4 id="元空间的内存大小"><a href="#元空间的内存大小" class="headerlink" title="元空间的内存大小"></a>元空间的内存大小</h4><p>元空间是方法区的在HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过<strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</strong>理论上取决于32位&#x2F;64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数，元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定。</p>
<h4 id="为什么jdk8用metaspace数据结构用来替代perm？"><a href="#为什么jdk8用metaspace数据结构用来替代perm？" class="headerlink" title="为什么jdk8用metaspace数据结构用来替代perm？"></a>为什么jdk8用metaspace数据结构用来替代perm？</h4><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。这项改动是很有必要的，原因有：</p>
<ol>
<li>永久代应该设置的空间大小很难确定。</li>
</ol>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<ol start="2">
<li>对永久代的调优是很困难的。</li>
</ol>
<h4 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h4><p>在 Java 7 中，<code>StringTable</code> 存储在永久代（PermGen）中，它会随着 JVM 的启动而被初始化，并且大小是固定的，不能动态调整。</p>
<p>jdk8 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发，这就就导致 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代不足。放在堆里，能及时回收内存。</p>
<img src="/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><img src="/2022/05/16/JVM/image-20220711174215771.png" class="" title="image-20220711174215771">

<p><strong>1. Loading 加载：</strong> 类的加载主要的职责为将.class文件的二进制字节流读入内存，并在堆内存中为之创建Class对象，作为.class进入内存后的数据的访问入口。在这里只是读入二进制字节流，后续的验证阶段就是要拿二进制字节流来验证.class文件，验证通过，才会将.class文件转为运行时数据结构</p>
<p><strong>2. Linking 连接：</strong></p>
<p><strong>校验</strong>：该阶段主要是为了<u>保证加载进来的字节流符合JVM的规范</u>，不会对JVM有安全性问题。其中有对元数据的验证，例如检查类是否继承了被final修饰的类；或者是检查符号引用的权限(private、public)是否符合语法规定等。</p>
<p><strong>准备：</strong> 准备阶段的主要任务是为类的<u>静态变量开辟空间并赋默认值</u>。<br>1、静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0<br>2、静态变量是引用类型的，默认值为null</p>
<p><strong>解析：</strong> 该阶段的主要职责为将<u>Class在常量池中的符号引用转变为直接引用</u>，此处针对的是静态方法和私有方法。</p>
<p><strong>3.初始化：</strong></p>
<p>  该阶段主要是为类的类变量初始化值的，初始化有两种方式：<br>1、在声明类变量时，直接给变量赋值<br>2、在静态初始化块为类变量赋值</p>
<p>常量在编译时就已经赋值了。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><img src="/2022/05/16/JVM/Center.png" class="" title="img">

<p>类加载器（ClassLoader）的作用是从文件系统、网络或其他来源加载 Java 字节码，并将其转换为 Java 类。类加载器可以说是 Java 虚拟机的核心组件之一，其主要作用有三个：</p>
<ol>
<li>从存储设备或网络获取 Java 类字节码。</li>
<li>将字节码转换成 Java 类对象。</li>
<li>对 Java 类提供命名空间，以避免同名类之间的冲突。</li>
</ol>
<p>根据加载的范围和来源不同，类加载器可以分为以下几种类型：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）：它负责加载 Java 的核心类，如 java.lang.Object 等。</li>
<li>扩展类加载器（Extension ClassLoader）：它负责加载 Java 平台扩展类，如 JDK 中的 com.sun.* 包中的类等。</li>
<li>应用程序类加载器（Application ClassLoader）：它负责加载应用程序中的类，如在 CLASSPATH 变量中指定的类等。</li>
<li>自定义类加载器：根据需要可以创建用户自定义的类加载器来加载自己的类</li>
</ol>
<h3 id="双亲委派类加载机制"><a href="#双亲委派类加载机制" class="headerlink" title="双亲委派类加载机制"></a>双亲委派类加载机制</h3><p><img src="https://uploadfiles.nowcoder.com/images/20211118/363939340_1637165320603/761B181C5781AFC06BE53D95033688DB" alt="img"></p>
<img src="/2022/05/16/JVM/image-20220711171336881.png" class="" title="image-20220711171336881">

<img src="/2022/05/16/JVM/image-20220711173346887.png" class="" title="image-20220711173346887">



<p><strong>双亲委派机制</strong>指的是，当某个特定的类加载器在收到类加载的请求时，会遵循下面的规则顺序：</p>
<p>1.首先判断被加载的类是否已经加载过，如果是则结束，否则会将加载任务委托给自己的父亲；<br>2.父类加载器在收到类加载的请求时，也会先判断被加载的类是否已经加载过，如果是则结束，否则同样将加载任务委托给自己的父亲<br>3.不断的循环进行步骤2，直到将加载任务委托给Bootstrap ClassLoader为止。此时，Bootstrap ClassLoader会先判断被加载的类是否已经加载过，如果是则结束；<br>请注意，到这里为止，都只是在转移加载任务的请求，下面将会进行类加载。</p>
<p>4.Bootstrap ClassLoader会判断能否完成加载任务，如果能则直接加载，否则会将加载任务交给儿子类加载器；<br>5.儿子类加载器也会判断能否完成加载任务，如果能则直接加载，否则会再一次将加载任务交给儿子类加载器；<br>6.不断的循环进行步骤5，直到最后一个类加载器，如果这个类加载器仍然不能够加载这个类，就会抛出一个异常：ClassNotFoundException。</p>
<pre><code>父加载器不是父类的关系 也不是类加载器的加载器 只是一种从属关系
</code></pre>
<h3 id="Tomcat如何打破双亲委派机制的？"><a href="#Tomcat如何打破双亲委派机制的？" class="headerlink" title="Tomcat如何打破双亲委派机制的？"></a>Tomcat如何打破双亲委派机制的？</h3><p>Tomcat是先去本地目录加载，为了避免本地目录覆盖掉JRE的核心类，如<code>java.lang</code>包等，先尝试用ExtClassLoader加载，这样即能打破双亲委派机制，有避免了覆盖掉核心类。</p>
<h3 id="为什么要设计这种机制"><a href="#为什么要设计这种机制" class="headerlink" title="为什么要设计这种机制"></a>为什么要设计这种机制</h3><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入，既保证JVM的安全。</p>
<p>其次，还能保证同一个类不会被加载多次。</p>
<h2 id="对象从创建到消亡的历史过程"><a href="#对象从创建到消亡的历史过程" class="headerlink" title="对象从创建到消亡的历史过程"></a>对象从创建到消亡的历史过程</h2><p>类的加载机制 到 GC</p>
<h2 id="User-user-x3D-new-User-做了什么操作，申请了哪些内存？"><a href="#User-user-x3D-new-User-做了什么操作，申请了哪些内存？" class="headerlink" title="User user &#x3D; new User()  做了什么操作，申请了哪些内存？"></a>User user &#x3D; new User()  做了什么操作，申请了哪些内存？</h2><h3 id="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"><a href="#指针碰撞和空闲列表（堆内存分配对象空间的两种方式）" class="headerlink" title="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"></a>指针碰撞和空闲列表（堆内存分配对象空间的两种方式）</h3><p>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“ <em>指针碰撞</em> ”。</p>
<p> Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<em>空闲列表</em> ”。</p>
<p>具体分配方式由Jvm堆是否规整决定，Jvm堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效；如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<p>对象创建在虚拟机中是非常频繁的行为，因而产生大量的线程并发安全问题。Jvm通常采用CAS自旋和TLAB(本地线程缓冲)方案，来处理对象创建中线程安全问题。</p>
<pre><code>    CAS机制：对分配内存空间的动作进行同步处理，虚拟机采用CAS加失败重试的方式保证更新操作的原子性。通过自旋的方式不断尝试分配内存，直到分配成功。

    TALB机制：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。TLAB只是让每个线程有私有的分配指针，但是对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。（Jvm默认使用此方案）。
</code></pre>
<h2 id="对象的内存分配位置"><a href="#对象的内存分配位置" class="headerlink" title="对象的内存分配位置"></a>对象的内存分配位置</h2><img src="/2022/05/16/JVM/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOO6KGM5rC05LiKX1pI,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="img">

<h2 id="JVM的性能调优"><a href="#JVM的性能调优" class="headerlink" title="JVM的性能调优"></a>JVM的性能调优</h2><h2 id="GC算法，永久代对象如何GC，GC有环怎么处理"><a href="#GC算法，永久代对象如何GC，GC有环怎么处理" class="headerlink" title="GC算法，永久代对象如何GC，GC有环怎么处理"></a>GC算法，永久代对象如何GC，GC有环怎么处理</h2><h2 id="Java7到Java8关于JVM的改变"><a href="#Java7到Java8关于JVM的改变" class="headerlink" title="Java7到Java8关于JVM的改变"></a>Java7到Java8关于JVM的改变</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>在讨论深拷贝和浅拷贝之前 首先要了解一下java的赋值机制——值传递</p>
<p>什么是值传递 什么是引用传递?</p>
<p>首先要了解一下 什么是实际参数 什么是形式参数?(纯纯套娃了)</p>
<p>形式参数 最先想到的就是java方法中的方法参数值了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123; <span class="comment">//word就是形式参数 简称形参</span></span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际参数 就是传给这个函数的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.speak(<span class="string">&quot;hello,java&quot;</span>);<span class="comment">//hello,java是实际参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 我传给这个函数的 到底是这个”hello,java”本身 还是”hello,java”这个对象在内存中的引用呢? 于是 就有了值传递和引用传递</p>
<p><strong>值传递</strong>: 把这个参数的值给函数,调用函数的时候只对传给这个函数的值进行修改等操作(就是说 在这个函数里你怎么折腾这个值都可以 但就是不会影响这个值本身) </p>
<p>将一个变量的值传给另一个变量。不管这个变量基本数据类型还是引用数据类型。引用数据类型的话传的还是值。不过这个值是指向对象的地址。</p>
<p><strong>引用传递</strong>: 直接传给函数这个参数的内存地址,直接在这个参数上面进行修改。</p>
<p>地址传递，传的是另一个变量的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>地址。<strong>java中没有引用传递</strong>。</p>
<hr>
<p><strong>深拷贝</strong></p>
<p>是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p><strong>浅拷贝</strong></p>
<p>只是增加了一个指针指向已存在的内存地址。</p>
<hr>
<p>那么这两个传递类型和深拷贝浅拷贝有什么关系呢?</p>
<p>深拷贝和浅拷贝在拷贝值的时候 都是值传递 并没有使用引用传递 而深拷贝的效果之所以有时候和引用传递相同,是因为引用传递是将对象的内存地址直接传给一个函数,而深拷贝是直接复制了一个内存值 在这个复制的内存值上进行操作.</p>
<h2 id="四种类型的引用"><a href="#四种类型的引用" class="headerlink" title="四种类型的引用"></a>四种类型的引用</h2><p>①强引用：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p>
<p>②软引用：简言之，如果一个对象具有弱引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p>
<p>③弱引用（这里讨论ThreadLocalMap中的Entry类的重点）：如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收期回收掉，JVM会将这个引用加入到与之关联的引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用的对象呗回收掉之后，再调用get方法就会返回null</p>
<p>④虚引用：虚引用是所有引用中最弱的一种引用，其存在就是为了将关联虚引用的对象在被GC掉之后收到一个通知。（不能通过get方法获得其指向的对象）</p>
<p>巨人的肩膀：</p>
<p><a href="https://blog.csdn.net/myfirstuser/article/details/98034911">(31条消息) 方法区和堆_csdn.user的博客-CSDN博客_堆和方法区</a></p>
<p><a href="https://www.cnblogs.com/pensieve/p/13574459.html">09_方法区 - 只是一名学徒 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/codeyanbao/article/details/82875064">(31条消息) 通俗易懂的双亲委派机制_IT烂笔头的博客-CSDN博客_双亲委派机制</a></p>
<p><a href="https://blog.csdn.net/weixin_39517868/article/details/111390001">(31条消息) 双亲委派机制_面试官：双亲委派机制的原理和作用是什么？_weixin_39517868的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_69650487/article/details/124202086#:~:text=jvm%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%BB,%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82">(31条消息) Jvm对象创建过程_风行水上_ZH的博客-CSDN博客_jvm初始化过程</a></p>
<p>更深入：</p>
<p><a href="https://www.cnblogs.com/duanxz/p/3520829.html">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JavaEE</title>
    <url>/2022/08/05/JavaEE/</url>
    <content><![CDATA[<h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><p>基础不牢地动山摇，这部分的知识零碎又重要。</p>
<span id="more"></span>

<h1 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h1><p>整型用于表示小数点后没有值得类型，共有四种，主要是表示范围的差别：</p>
<ol>
<li>整型<table>
<thead>
<tr>
<th>类型</th>
<th>所占空间</th>
<th>缓存区域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td>32位&#x2F;4字节	[-2^31,2^31-1]即[-2147483648,2147483647],</td>
<td>-128~127</td>
</tr>
<tr>
<td><strong>short</strong></td>
<td>16位&#x2F;2字节	[-2^15,2^15-1]即[-32768,32767]</td>
<td>-128~127</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>64位&#x2F;8字节	[-2^63,2^63-1]</td>
<td>-128~127</td>
</tr>
<tr>
<td><strong>byte</strong></td>
<td>8位&#x2F;1字节	[-128,127]</td>
<td>-128~127</td>
</tr>
</tbody></table>
</li>
</ol>
<p>为什么正数的最大值是2^31-1?<br>一个int是32位，即32个二进制位，由于要表示正负，所以要去掉一位标志位，即用来表示数据的位数为31，所以最大值应该是011…(共31个1)…11,最大值再加1即为231,所以，最大值为231-1</p>
<ol start="2">
<li>浮点类型</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>所占空间</th>
<th>可表示小数位</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>6-7位小数</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15位小数</td>
</tr>
</tbody></table>
<ul>
<li>由于float的精度只有double类型的一半，所以通常情况下都用double类型，float在很多情况下并不适用。</li>
</ul>
<ol start="3">
<li><p>char类型</p>
</li>
<li><p>boolean类型</p>
<p> boolean类型表示逻辑判断有<code>true</code>和<code>false</code>两个值</p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2></li>
</ol>
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>装箱调用了 包装类的 valueOf() 方法</p>
<p>拆箱调用了 xxxValue() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> 	等价于 <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i 		等价于 <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue() ;</span><br></pre></td></tr></table></figure>

<h2 id="关于缓存（常量池）"><a href="#关于缓存（常量池）" class="headerlink" title="关于缓存（常量池）"></a>关于缓存（常量池）</h2><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p>Byte , Short , Integer , Long 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据， Character 创建了数值在[0,127]范围的缓存数据， Boolean 直接返回 True or False 。</p>
<p>两种浮点数类型的包装类 Float , Double 并没有实现常量池技术。</p>
<p><strong>注意：所有整型包装类对象之间值的比较，全部使用</strong> <strong>equals</strong> <strong>方法比较</strong></p>
<p>比如Integer，因为在[-128,127]的区间内赋值，会直接从 IntegerCache.cache 生成，会复用已有的对象，地址值相同，可以使用&#x3D;&#x3D;进行比较判断，但是超过这个缓存范围的，不是在常量池中进行比较的，而是在堆内存中进行生成， 所以不管是在哪个范围，都要使用equals进行比较。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String类型为什么是不可变的"><a href="#String类型为什么是不可变的" class="headerlink" title="String类型为什么是不可变的"></a>String类型为什么是不可变的</h2><p>当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，<strong>final只保证这个引用变量所引用的地址不会改变</strong>，即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<p>String类的两个主要成员变量，其中value指向的是一个字符串数组，字符串中的字符就是用这个value<strong>变量存储起来的</strong>，并且用final修饰，也就是说value一旦赋予初始值之后，value指向的地址就不能再改变了。虽然value指向的数组是可以改变的，但是String也没有提供相应的方法让我们去修改value指向的数组的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<h3 id="可变的话会怎么样"><a href="#可变的话会怎么样" class="headerlink" title="可变的话会怎么样"></a>可变的话会怎么样</h3><ol>
<li>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，<strong>因为不同的字符串变量都指向池中的同一个字符串</strong>。如果字符串是可变的，那么String interning将不能实现(String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</li>
<li>如果字符串是可变的，那么会引起<strong>很严重的安全问题</strong>。譬如，<strong>数据库的用户名、密码</strong>都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。 因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</li>
<li>因为字符串是不可变的，所以是<strong>多线程安全的</strong>，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</li>
<li>因为字符串是不可变的，所以在它创建的时候<strong>hashcode就被缓存了</strong>，不需要重新计算。这就使得字符串很适合作为<strong>Map中的键</strong>，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li>
</ol>
<h2 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h2><img src="/2022/08/05/JavaEE/20200226214858667.png" class="" title="在这里插入图片描述">



<p>StringBuffer的速度是低于和StringBuilder的 ， 但是StringBuffer的安全性是有保障的，经过测试，实际上StringBuffer的速度并不逊色于StringBuilder很多，所以实际上是<strong>没有必要</strong>为了一点点的性能提升而舍弃安全性去选StringBuilder。</p>
<p><a href="https://blog.csdn.net/kaka_buka/article/details/78296217">StringBuffer和StringBuilder的性能对比_黑风风的博客-CSDN博客_stringbuilder stringbuffer 性能</a></p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Java的泛型是伪泛型，这是因为Java在<strong>编译期</strong>间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。<br>例如：<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都变成 <code>List</code></p>
<p><a href="https://www.cnblogs.com/hongdada/p/13993251.html">Java 泛型擦除 - hongdada - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/346486993">Java泛型中的类型擦除详解 - 知乎 (zhihu.com)</a></p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Java中的异常处理是一种机制，用于在程序执行期间处理错误或异常情况，</p>
<p><strong>当程序执行遇到错误或异常情况时，将会抛出一个异常对象。如果这个异常对象没有被捕获和处理，那么程序将会终止，并给出相应的错误信息。</strong></p>
<p>Java的异常分为两类：<strong>检查异常，非检查异常</strong>。</p>
<p>检查异常是指编译器在编译Java代码时就会检查出来的异常，这些异常必须要被捕获和处理，否则程序将无法通过<strong>编译</strong>。</p>
<p>非检查异常则是指在运行时才会发生的异常，如空指针异常和数组越界异常等。对于这些异常，可以选择捕获并处理，也可以直接让程序崩溃并抛出错误信息。</p>
<p>对于try-catch-finally的理解：</p>
<p>通常来讲，我们一个java程序中，有三个线程：主线程main()，异常线程，垃圾回收线程gc()。</p>
<p>当我们的main程序运行的时候，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(arr[<span class="number">5</span>]);</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理数组越界异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;last word speak&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">处理数组越界异常</span><br><span class="line">finally</span><br><span class="line">last word speak</span><br></pre></td></tr></table></figure>

<p>这说明 我们的try-catch结构中 异常线程对出现异常的位置进行了响应异常的catch捕捉，并反馈给主线程，该异常已经被处理，主线程继续运行，直到结束。try-catch结构对主线程进行了关于异常方面的保护，所以主线程能够顺利运行，也是一种保护java程序的手段。</p>
<h1 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h1><p>所有由static关键字声明的静态的内容，都是在类加载的时候就会分配内存</p>
<h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。</p>
<p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<h2 id="Java只有值传递"><a href="#Java只有值传递" class="headerlink" title="Java只有值传递"></a>Java只有值传递</h2><p>修改java内容的时候，地址值是不改变的，但是修改后，值改变了，所以传递的只是值。</p>
<h2 id="深拷贝和前拷贝"><a href="#深拷贝和前拷贝" class="headerlink" title="深拷贝和前拷贝"></a>深拷贝和前拷贝</h2><ol>
<li><p><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
</li>
<li><p><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
</li>
</ol>
<img src="/2022/08/05/JavaEE/image-20230530095059751.png" class="" title="image-20230530095059751">

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。</li>
<li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li>单例模式：确保一个类只有一个实例，并提供一个全局访问点。</li>
<li>建造者模式：将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li>原型模式：通过复制已经存在的实例来创建新的实例。</li>
<li>策略模式：定义一系列算法，将每个算法都封装起来，并让它们可以相互替换。(到达相同地点 使用不同交通方式的路径算法)</li>
<li>观察者模式：将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java反射是Java语言提供的一种运行时机制，它提供了在运行时检查和操作Java类和对象的能力。Java反射在一些框架和库中得到广泛应用，它<strong>允许我们在运行时获取类的信息，并可以实例化对象、调用方法和访问属性等</strong>。</p>
<p>反射在某些情况下非常有用，例如我们需要动态地加载类，创建对象，获取类的元数据，判断一个对象是否是某个类的实例，动态修改类的成员等，Java反射可以胜任这些任务。</p>
<h2 id="反射机制-以及可以实现哪些功能"><a href="#反射机制-以及可以实现哪些功能" class="headerlink" title="反射机制 以及可以实现哪些功能"></a>反射机制 以及可以实现哪些功能</h2><p>Java的反射机制指的是在<strong>运行时</strong>获取和<strong>操作类的属性、方法、构造器</strong>等信息的能力。在Java中，每个类都有一个Class对象，可以使用反射机制来获取这个Class对象，并<strong>通过Class对象获取类的各种属性和方法等信息</strong>。</p>
<p>例如，可以使用**Class.forName()**方法来获取类的对象</p>
<p>使用getFields()、getDeclaredFields()等方法获取类的成员变量</p>
<p>使用getMethods()、getDeclaredMethods()等方法获取类的成员方法等。</p>
<p>在运行时修改类的属性值和方法行为，即利用反射改变类的状态和行为，比如动态代理和AOP等技术。</p>
<h2 id="反射在Spring中的使用"><a href="#反射在Spring中的使用" class="headerlink" title="反射在Spring中的使用"></a>反射在Spring中的使用</h2><p> Spring 通过 XML 配置模式装载 <strong>Bean</strong> 的过程：</p>
<ol>
<li>将程序内所有 XML 或 Properties 配置文件加<strong>载入内存</strong>中</li>
<li>Java类里面解析xml或properties里面的内容，得到对应实体类的<strong>字节码字符串以及相关的属性信息</strong></li>
<li>使用<strong>反射</strong>机制，<strong>根据这个字符串获得某个类的Class实例</strong></li>
<li>动态配置实例的属性</li>
</ol>
<h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>反射提高了程序的<strong>灵活性和扩展性</strong>，降低耦合性，提高自适应能力，<strong>无需提前硬编码目标类</strong></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.性能问题</p>
<p>使用<strong>反射基本上是一种解释操作</strong>，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</p>
<p>2.使用反射会<strong>模糊程序内部逻辑</strong></p>
<p>程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</p>
<p>3.安全问题</p>
<p>使用反射技术要求程序必须在一个没有安全限制的环境中运行。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>Java中的线程池是一种线程管理机制，它用于实现线程的复用和管理，从而提高线程的利用率和效率。</p>
<p>Java中提供了两种线程池：<strong>ThreadPoolExecutor和ScheduledThreadPoolExecutor</strong>。</p>
<p>ThreadPoolExecutor是最基本的线程池，用于执行一些没有时间限制的线程任务。</p>
<p>ScheduledThreadPoolExecutor则是用于执行一些有时间限制的定时任务，可以设置线程启动的时间和任务执行周期等。</p>
<p>线程池的主要作用有：</p>
<ol>
<li>提高程序的性能和吞吐量，通过线程池的复用机制，避免了频繁地创建和销毁线程对象，提高了系统的并发能力。</li>
<li>简化了程序的编写和管理，程序员只需要将任务提交到线程池中，不需要自己管理线程的启动和销毁等细节。</li>
</ol>
<p>Java中的线程池使用<strong>Executor和Future两个核心接口实现多线程的池化，Executor用于管理线程池，Future用于获取线程的执行结果。</strong></p>
<p><strong>callable接口和Future接口</strong></p>
<p>这两个接口线程可以执行带返回的任务，用submit方法来向ExecutorService提交任务</p>
<h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><h1 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h1><ul>
<li>public：修饰的成员变量、成员方法和类可以被任意的类访问，包括不同的包和类。</li>
<li>protected：修饰的成员变量、成员方法和类可以被同一包内的类和不同包中的子类访问，但不能被其他的类访问。</li>
<li>default（默认）：如果不加访问修饰符，则表示该成员变量、成员方法和类仅在同一个包内可见，不能被其他包访问。</li>
<li>private：修饰的成员变量、成员方法只能被所属类的对象、方法或构造器访问，其他类是不能访问的。</li>
</ul>
<h1 id="抽象类和接口有什么不同"><a href="#抽象类和接口有什么不同" class="headerlink" title="抽象类和接口有什么不同"></a>抽象类和接口有什么不同</h1><p><strong>相同点：</strong></p>
<p>1.抽象类和接口都不能被<strong>实例化</strong>，但可以定义抽象类和接口类型的引用。</p>
<p>2.一个类如果继承了抽象类或接口，<strong>必须要对其中的抽象方法全部实现</strong>。（接口中方法默认的是public abstract修饰的）否则该类仍然需要被声明为抽象类。</p>
<p><strong>不同点：</strong></p>
<p>1、抽象类可以有构造方法，抽象方法和具体方法。</p>
<p>　 接口不能有构造方法，而且其中的方法全部都是抽象方法。（接口中方法默认的是public abstract修饰的）</p>
<p>2、抽象类中的成员可以使private、默认、protected、public的。</p>
<p>　　接口中的成员全部都是public的。</p>
<p>3、抽象类可以 定义成员变量。</p>
<p>　　接口中定义的成员变量其实都是常量。（<strong>接口中的成员变量默认是public static final 修饰的</strong> ）</p>
<h1 id="Java中finalize-方法的作用"><a href="#Java中finalize-方法的作用" class="headerlink" title="Java中finalize()方法的作用"></a>Java中finalize()方法的作用</h1><ol>
<li>当对象不再被任何对象引用时，GC会调用该对象的finalize()方法</li>
<li><strong>finalize()是Object的方法</strong>，子类可以覆盖这个方法来做一些系统资源的释放或者数据的清理</li>
<li><strong>当finalize被调用之后，JVM会再一次检测这个对象是否能被存活的线程访问得到</strong>，如果不是，则清除该对象。也就是finalize只能被调用一次；也就是说，<strong>覆盖了finalize方法的对象需要经过两个GC周期才能被清除</strong>。</li>
</ol>
<p>finalize()方法是Java中的一个重要的垃圾回收机制。当某个对象不再被任何引用所指向时，它就成为了Java虚拟机中的垃圾。在垃圾回收器对垃圾进行回收之前，JVM会调用该对象的finalize()方法，以完成一些必要的清理和资源回收操作。通常情况下，我们在finalize()方法中进行的操作包括释放该对象所占用的系统资源、断开该对象与其他对象之间的引用关系等。在finalize()方法执行后，该对象所占用的内存空间就可以被Java虚拟机回收。</p>
<h1 id="Java中的静态代理和动态代理"><a href="#Java中的静态代理和动态代理" class="headerlink" title="Java中的静态代理和动态代理"></a>Java中的静态代理和动态代理</h1><p>&#x2F;&#x2F;TODO</p>
<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</p>
<p><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</p>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<h2 id="序列化的必要条件"><a href="#序列化的必要条件" class="headerlink" title="序列化的必要条件"></a>序列化的必要条件</h2><ol>
<li>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</li>
<li>必须是同包，同名。</li>
<li>serialVersionUID必须一致。有时候两个类的属性稍微不一致的时候，可以通过将此属性写死值，实现序列化和反序列化。</li>
</ol>
<p>	</p>
<h2 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><strong>Java</strong> <strong>序列化中如果有些字段不想进行序列化，怎么办？</strong></h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
<p>关于 transient 还有几点<strong>注意</strong>：</p>
<ol>
<li><p>transient 只能修饰变量，不能修饰类和方法。</p>
</li>
<li><p>transient 修饰的变量，在<strong>反序列化后变量值将会被置成类型的默认值</strong>。例如，如果是修饰 int类型，那么反序列后结果就是 0 。</p>
</li>
<li><p>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</p>
</li>
</ol>
<h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><p><a href="https://blog.csdn.net/osillto/article/details/119811207">(143条消息) 反射的优缺点_osillto的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/dearKundy/article/details/82355019">https://blog.csdn.net/dearKundy/article/details/82355019</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2022/05/29/Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><img src="/2022/05/29/Mybatis/1502093784622523.png" class="" title="img">

<h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis?"></a>什么是Mybatis?</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<span id="more"></span>

<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>首先在pom.xml文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 <a href="https://www.w3cschool.cn/xml/">XML</a> 中构建 SqlSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 <code>file:// URL</code> 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（<a href="https://www.w3cschool.cn/kzsow/kzsow-frbn2grj.html">mapper</a>），这些映射器的 XML 映射文件包含了 <a href="https://www.w3cschool.cn/sql/">SQL</a> 代码和映射定义信息。</p>
<h1 id="MyBatis-XML配置"><a href="#MyBatis-XML配置" class="headerlink" title="MyBatis XML配置"></a>MyBatis XML配置</h1><p>mybatis-config.xml配置文件  <configuration> 标签中 各个标签的配置顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--    此处易报错 注意错误返回的标签规则 将下面的标签顺序重新排列--&gt;</span><br><span class="line">&lt;!--    (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt;--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h2><p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h2><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
<p>属性也可以被传递到 SqlSessionBuilder.build()方法中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment, props);</span><br></pre></td></tr></table></figure>

<p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的<strong>顺序来加载</strong>：</p>
<ul>
<li>在 properties 元素体内指定的属性首先被读取。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。</li>
</ul>
<h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a>配置环境（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p>
<p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p>
<ul>
<li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment,properties);</span><br></pre></td></tr></table></figure>

<p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader,properties);</span><br></pre></td></tr></table></figure>

<p>环境元素定义了如何配置环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用的是第一个环境变量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 另一个环境 在&lt;environments default=&quot; &quot;&gt; 设置应该加载哪个--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password2&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的关键点:</p>
<ul>
<li>默认的环境 ID（比如:default&#x3D;”development”）。</li>
<li>每个 environment 元素定义的环境 ID（比如:id&#x3D;”development”）。</li>
<li>事务管理器的配置（比如:type&#x3D;”JDBC”）。</li>
<li>数据源的配置（比如:type&#x3D;”POOLED”）。</li>
</ul>
<p>默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。</p>
<h3 id="数据源（dataSource）"><a href="#数据源（dataSource）" class="headerlink" title="数据源（dataSource）"></a><strong>数据源（dataSource）</strong></h3><p>数据源<dataSource> 标签 属于  <environment> 在其中配置数据源</p>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<ul>
<li>许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</li>
</ul>
<p>有三种内建的数据源类型（也就是 type&#x3D;”[   UNPOOLED     |    POOLED    |    JNDI    ]”）：</p>
<p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p>
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
</ul>
<p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为”driver.”，例如：</p>
<ul>
<li><code>driver.encoding=UTF8</code></li>
</ul>
<p>这将通过DriverManager.getConnection(url,driverProperties)方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</p>
<p><strong>POOLED</strong>– 这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
<p>除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是”NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 <code>poolPingQuery</code> 属性（最好是一个非常快的 SQL），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
<p><strong>JNDI</strong>– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p>
<ul>
<li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。</li>
<li><code>data_source</code> – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</li>
</ul>
<h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h2><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="编写XML映射文件"><a href="#编写XML映射文件" class="headerlink" title="编写XML映射文件"></a>编写XML映射文件</h1><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p>
<ul>
<li><code>cache</code> – 给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。</p>
<p>select 标签有很多属性允许你配置，来决定每条语句的作用细节。</p>
<p><strong>Select Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">resultType</td>
<td align="left">从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td>
</tr>
<tr>
<td align="left">resultMap</td>
<td align="left">外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</td>
</tr>
<tr>
<td align="left">useCache</td>
<td align="left">将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">fetchSize</td>
<td align="left">这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">resultSetType</td>
<td align="left">FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
<tr>
<td align="left">resultOrdered</td>
<td align="left">这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td>
</tr>
<tr>
<td align="left">resultSets</td>
<td align="left">这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</td>
</tr>
</tbody></table>
<p>类似的 insert update delete 标签的属性</p>
<p><strong>Insert Update Delete Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">命名空间中的唯一标识符，可被用来代表这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="left">（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td align="left">keyProperty</td>
<td align="left">（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">keyColumn</td>
<td align="left">（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<p>&#x2F;&#x2F;TODO 一些其他的构造方法和参数</p>
<h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h1><p>#{} 是以<strong>参数</strong>的形式进行传递，可以在其中定义参数类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE username=#&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>	解析结果：SELECT * FROM user WHERE username=&quot;Amy&quot;</span><br></pre></td></tr></table></figure>

<p>${}: 解析为SQL时，将形参<strong>变量的值</strong>直接取出，直接拼接显示在SQL中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span></span><br><span class="line">       SELECT * FROM user WHERE username=$&#123;value&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  解析结果：SELECT * FROM user WHERE username=Amy</span><br></pre></td></tr></table></figure>

<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE username=&#x27;$&#123;value&#125;&#x27;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 username &#x3D; “‘ OR 1&#x3D;1 OR ‘“ 传入后，${}将变量内容直接和SQL语句进行拼接，结果如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE username=&#x27;&#x27; OR 1=1 OR &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<p>#{}方式则是先用占位符代替参数将SQL语句先进行预编译，然后再将参数中的内容替换进来。由于SQL语句已经被预编译过，其SQL意图将无法通过非法的参数内容实现更改。故，**#{}可以防止SQL注入而${}却不行**</p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>根据条件进行判断：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<p>还是上面的例子，但是这次变为提供了”title”就按”title”查找，提供了”author”就按”author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><p>首先看一个动态SQL：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>乍一看没什么问题 但是当每个条件都匹配不到时,这条SQL会变成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure>

<p>如何解决这种条件不匹配的sql？MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>where 元素知道只有在一个以上的if条件有值的情况下才去插入”WHERE”子句。而且，若最后的内容是”AND”或”OR”开头的，where 元素也知道如何将他们去除。</p>
<p>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。</p>
<p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。</p>
<p>若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。</p>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p>
<h1 id="Mybatis-日志"><a href="#Mybatis-日志" class="headerlink" title="Mybatis 日志"></a>Mybatis 日志</h1><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>将用户经常查询的数据的结果的一个保存，保存到一个内存中（缓存就是内存中的一个对象），用户在查询的时候就不用到数据库文件中查询（磁盘），从而减少与数据库的交付次数提高了响应速度，解决了并发系统的性能问题。</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>MyBatis提供了一级缓存和二级缓存</p>
<ul>
<li>一级缓存：也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。</li>
<li>二级缓存：也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>在应用运行过程中，在一次数据库会话中，执行多次查询条件完全相同的SQL，会优先命中一级缓存，避免直接对数据库中直接查询。</p>
<img src="/2022/05/29/Mybatis/webp.webp" class="" title="img">

<p>每个SqlSession中都持有Excutor，每个Excutor中有一个LocalCache。当用户发起询问时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。</p>
<img src="/2022/05/29/Mybatis/webp-16538306997353.webp" class="" title="img">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>SqlSession：</strong> 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是DefaultSqlSession。<br> <strong>Executor：</strong> SqlSession向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。Executor有两个实现类，和一级缓存关联的是BaseExecutor。<br> <strong>BaseExecutor：</strong> BaseExecutor是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。<br> <strong>PerpetualCache：</strong>对Cache接口最基本实现，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。</p>
<p>SqlSession初始化时会创建Executor的实例，Mybatis默认使用的是SimpleExecutor，初始化代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如果启用二级缓存，使用CahingExecutor装饰类</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession在提交的时候会清空本地缓存，因为commit操作一般对应插入、更新或者删除操作，清空缓存防止读取脏数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Cannot commit, transaction is already closed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  flushStatements();</span><br><span class="line">  <span class="keyword">if</span> (required) &#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession的insert方法和delete方法，都会统一走update的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>update方法也是委托给了Executor执行。BaseExecutor的执行方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一级缓存失效的原因"><a href="#一级缓存失效的原因" class="headerlink" title="一级缓存失效的原因"></a>一级缓存失效的原因</h3><ul>
<li>同一个用户使用不同的SqlSession对象导致无法看到一级缓存工作。</li>
<li>在一个SqlSession中使用条件查询不同一级缓存也会失效。</li>
<li>在一个SqlSession使用相同条件，但是，此时在查询之间进行数据修改操作会导致一级缓存失效。</li>
<li>在一个SqlSession使用相同查询条件此时手动刷新缓存时导致一级缓存失败。</li>
</ul>
<h3 id="一级缓存注意"><a href="#一级缓存注意" class="headerlink" title="一级缓存注意"></a>一级缓存注意</h3><p>MyBatis一级缓存的生命周期和SqlSession一致。</p>
<p>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</p>
<p>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据。</p>
<p>mybatis和spring整合后进行mapper代理开发，不支持一级缓存。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><img src="/2022/05/29/Mybatis/webp-16538311623015.webp" class="" title="img">

<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。<br> 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="如何开启二级缓存"><a href="#如何开启二级缓存" class="headerlink" title="如何开启二级缓存"></a>如何开启二级缓存</h3><ol>
<li>需要在MyBatis核心配置文件,通过settings标签开发二级缓存。<br> <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></li>
<li>在对应的Mapper文件中添加cache标签</li>
<li>cache标签属性</li>
</ol>
<ul>
<li><p>type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。</p>
</li>
<li><p>eviction： 定义回收的策略，常见的有FIFO，LRU。</p>
</li>
<li><p>flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</p>
</li>
<li><p>size： 最多缓存对象的个数。</p>
</li>
<li><p>readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</p>
</li>
<li><p>blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存4</p>
<p>4.cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
</li>
</ul>
<p> <code>&lt;cache-ref namespace=&quot;mapper.StudentMapper&quot;/&gt;</code></p>
<h3 id="核心接口和实现类"><a href="#核心接口和实现类" class="headerlink" title="核心接口和实现类"></a>核心接口和实现类</h3><img src="/2022/05/29/Mybatis/webp-16538313584837.webp" class="" title="img">

<p>CachingExecutor的query方法，首先会从MappedStatement中获得在配置初始化时赋予的Cache。</p>
<p>以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。</p>
<ul>
<li>SynchronizedCache： 同步Cache，实现比较简单，直接使用synchronized修饰方法。</li>
<li>LoggingCache： 日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。</li>
<li>SerializedCache： 序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li>LruCache： 采用了Lru算法的Cache实现，移除最近最少使用的key&#x2F;value。</li>
<li>PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<p>可以为每条Mapper语句设置是否要刷新缓存,可以指定select语句是否使用缓存,如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>判断是否刷新缓存</p>
<p> <code>flushCacheIfRequired(ms);</code></p>
<p> 在默认的设置的select语句是不会刷新缓存的，insert&#x2F;update&#x2F;delte会刷新缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>&#x2F;&#x2F;TODO</p>
<h3 id="二级缓存失效的原因"><a href="#二级缓存失效的原因" class="headerlink" title="二级缓存失效的原因"></a>二级缓存失效的原因</h3><ul>
<li>flushCache属性在查询中作用针对二级缓存导致失效</li>
<li>flushCache属性在查询中作用针对一级缓存导致失效</li>
<li>flushCache属性在更新中作用导致两次查询结果完全一样</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</p>
<p>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p>
<p>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis,Memcached等分布式缓存可能成本更低，安全性也更高。</p>
<p>原文链接：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制 - 美团技术团队 (meituan.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/b4522c9212fb">https://www.jianshu.com/p/b4522c9212fb</a></p>
<p>原文链接：<a href="https://www.w3cschool.cn/mybatis/mybatis-dyr53b5w.html">MyBatis 入门_w3cschool</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>MQ</title>
    <url>/2022/08/01/MQ/</url>
    <content><![CDATA[<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ 是message queue ,消息队列，也叫消息中间件，遵守JMS（java message service）规范的一种软件。是类似于数据库一样需要独立部署在服务器上的一种应用，提供接口给其他系统调用。</p>
<p>主要用于各个系统之间通信的解耦。</p>
<span id="more"></span>

<h2 id="MQ的用途"><a href="#MQ的用途" class="headerlink" title="MQ的用途"></a>MQ的用途</h2><ol>
<li><p><strong>限流削峰</strong></p>
<p>MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮</p>
</li>
</ol>
<img src="/2022/08/01/MQ/image-20220801135527811.png" class="" title="image-20220801135527811">



<img src="/2022/08/01/MQ/image-20220801135606503.png" class="" title="image-20220801135606503">

<ol start="2">
<li><p><strong>异步解耦</strong></p>
<p>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层</p>
<img src="/2022/08/01/MQ/image-20220801135730675.png" class="" title="image-20220801135730675">
</li>
<li><p><strong>数据收集</strong></p>
<p>分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。</p>
</li>
</ol>
<h2 id="MQ的常见协议"><a href="#MQ的常见协议" class="headerlink" title="MQ的常见协议"></a>MQ的常见协议</h2><p>一般情况下MQ的实现是遵循一些常规性协议的。一下是一些常见的协议：</p>
<details>
<summary>点击查看MQ协议详细内容</summary>
<br>JMS<br>
JMS，Java Messaging Service（Java消息服务）。是Java平台上有关MOM（Message Oriented Middleware，面向消息的中间件 PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。<br>
<br>
STOMP <br>
STOMP，Streaming Text Orientated Message Protocol（面向流文本的消息协议），是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。
<br>
<br>AMQP<br>
AMQP，Advanced Message Queuing Protocol（高级消息队列协议），一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 RabbitMQ是该协议的典型实现。
<br>
<br>MQTT <br>
MQTT，Message Queuing Telemetry Transport（消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器的通信协议。 RabbitMQ通过插件可以支持该协议</br>


<h2 id="MQ产品"><a href="#MQ产品" class="headerlink" title="MQ产品"></a>MQ产品</h2><p><strong>1. RocketMQ</strong></p>
<p>阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为<a href="https://so.csdn.net/so/search?q=RocketMQ&spm=1001.2101.3001.7020">RocketMQ</a>，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。</p>
<p>具有以下特点：</p>
<ul>
<li>能够保证严格的消息顺序</li>
<li>提供针对消息的过滤功能</li>
<li>提供丰富的消息拉取模式</li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力</li>
<li>其没有遵循任何常见的MQ协议，而是<strong>使用自研协议</strong>。</li>
</ul>
<p>官方提供了一些不同于kafka的对比差异：<br><a href="https://rocketmq.apache.org/docs/motivation/">https://rocketmq.apache.org/docs/motivation/</a></p>
<p><strong>2. RabbitMQ</strong></p>
<p>使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p>
<p><strong>3.  ActiveMQ</strong></p>
<p>Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。<a href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。</p>
<p><strong>4. Redis</strong></p>
<p>使用C语言开发的一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<p><strong>5. Kafka</strong></p>
<p>Apache下的一个子项目，使用scala实现的一个高性能分布式Publish&#x2F;Subscribe消息队列系统，具有以下特性：</p>
<ul>
<li>快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到10W&#x2F;s的吞吐速率；</li>
<li>高堆积：支持topic下消费者较长时间离线，消息堆积量大；</li>
<li>完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；</li>
<li>支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。</li>
<li>其没有遵循任何常见的MQ协议，而是<strong>使用自研协议</strong>。</li>
</ul>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><p><a href="https://developer.aliyun.com/article/780968">RocketMQ 简介-阿里云开发者社区 (aliyun.com)</a></p>
<p>RocketMQ是由阿里捐赠给Apache的一款<strong>低延迟、高并发、高可用、高可靠</strong>的分布式消息中间件。经历了淘宝<strong>双十一</strong>的洗礼。RocketMQ既可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。</p>
<h2 id="基本组成及其概念"><a href="#基本组成及其概念" class="headerlink" title="基本组成及其概念"></a>基本组成及其概念</h2><ol>
<li><p><strong>消息Message</strong></p>
<p>就是要传输的信息。</p>
<p>一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。</p>
<p>一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。</p>
</li>
<li><p><strong>主题Topic</strong></p>
<p>Topic表示一类Message的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message &#x3D;1:n </p>
<p>message:topic &#x3D;1:1</p>
<p>一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种Topic的消息。 producer:topic &#x3D;1:n </p>
<p>consumer:topic &#x3D;1:1</p>
</li>
<li><p><strong>标签Tag</strong></p>
<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
</li>
<li><p><strong>队列Queue</strong></p>
<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>
</li>
<li><p><strong>消息标识Message ID&#x2F;Key</strong></p>
<p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>
</li>
</ol>
<p><strong>msgId</strong>：由producer端生成，其生成规则为：producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +当前时间 + AutomicInteger自增计数器</p>
<p><strong>offsetMsgId</strong>：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的偏移量）</p>
<p><strong>key</strong>：由用户指定的业务相关的唯一标识</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><img src="/2022/08/01/MQ/image-20220801141303900.png" class="" title="image-20220801141303900">

<h3 id="1-Producer"><a href="#1-Producer" class="headerlink" title="1. Producer"></a>1. <strong>Producer</strong></h3><p>   消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2. Consumer"></a>2. <strong>Consumer</strong></h3><p>   消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。消费者组使得在消息消费方面，实现<strong>负载均衡</strong>（：将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和<strong>容错</strong>（：一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>
<h3 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3. Name Server"></a>3. <strong>Name Server</strong></h3><p>   NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>
<p>主要包括两个功能：</p>
<p><strong>Broker管理：</strong>接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。</p>
<p><strong>路由信息管理：</strong>每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。</p>
<p><strong>路由注册</strong></p>
<p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。</p>
<p>Broker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每30秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、 Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这个Broker的最新存活时间。</p>
<p><strong>路由剔除</strong></p>
<p>由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。NameServer中有⼀个定时任务，每隔10秒就会扫描⼀次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过120秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。</p>
<p><strong>路由发现</strong></p>
<p>RocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每30秒会拉取一次最新的路由。</p>
<p>扩展： </p>
<p><em>1</em>）<em>Push</em>模型：推送模型。其实时性较好，是一个<em>“</em>发布*-<em>订阅</em>”*模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景： </p>
<p>实时性要求较高</p>
<p><em>Client</em>数量不多，<em>Server</em>数据变化较频繁 </p>
<p><em>2</em>）<em>Pull</em>模型：拉取模型。存在的问题是，实时性较差。 </p>
<p><em>3</em>）<em>Long Polling</em>模型：长轮询模型。其是对<em>Push</em>与<em>Pull</em>模型的整合，充分利用了这两种模型的优 势，屏蔽了它们的劣势。<a href="https://www.jianshu.com/p/d3f66b1eb748?isappinstalled=0">Long Polling长轮询详解 - 简书 (jianshu.com)</a></p>
<p><strong>客户端Nameserver选择策略</strong></p>
<p>这里的客户端指的是<em>Producer</em>与<em>Consumer</em></p>
<p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p>
<p>首先采用的是随机策略进行的选择，失败后采用的是轮询策略。</p>
<h3 id="4-Borker"><a href="#4-Borker" class="headerlink" title="4. Borker"></a>4. Borker</h3><p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p>
<p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。 Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为0表 示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
<h2 id="生产者组和消费者组（ProducerGroup-amp-ConsumerGroup）"><a href="#生产者组和消费者组（ProducerGroup-amp-ConsumerGroup）" class="headerlink" title="生产者组和消费者组（ProducerGroup&amp;ConsumerGroup）"></a>生产者组和消费者组（ProducerGroup&amp;ConsumerGroup）</h2><p>一个生产者组存在多个生产者，一个胜场这可以说生产的多个topic的消息。</p>
<p>一个topic对应一个ConsumerGroup。</p>
<p>一个ConsumerGroup里的一个Consumer 可以消费不同的Queue，但是一个Queue不可以被同一个Consumer所消费。</p>
<p>官方文档：</p>
<p><a href="https://help.aliyun.com/document_detail/43523.htm?spm=a2c4g.11186623.0.0.17933635TNm0d1">订阅关系一致 (aliyun.com)</a></p>
<h2 id="操作和使用"><a href="#操作和使用" class="headerlink" title="操作和使用"></a>操作和使用</h2><p>开启nameserver</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p>开启broker</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:<span class="number">9876</span> &amp;</span><br></pre></td></tr></table></figure>

<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><img src="/2022/08/01/MQ/image-20220803151312628.png" class="" title="image-20220803151312628">

<h3 id="1-数据复制与刷盘策略"><a href="#1-数据复制与刷盘策略" class="headerlink" title="1 数据复制与刷盘策略"></a><strong>1</strong> <strong>数据复制与刷盘策略</strong></h3><img src="/2022/08/01/MQ/image-20220803151434118.png" class="" title="image-20220803151434118">



<p><strong>复制策略</strong></p>
<p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p>
<ol>
<li><p>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</p>
</li>
<li><p>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</p>
</li>
</ol>
<p>优缺点：异步复制策略会降低系统的写入延迟，<em>RT</em>（esponse-time响应时间）变小，提高了系统的吞吐量</p>
<p><strong>刷盘策略</strong></p>
<p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘</p>
<ol>
<li><p>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。</p>
</li>
<li><p>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</p>
</li>
</ol>
<p>优缺点：</p>
<p><em>1</em>）异步刷盘策略会降低系统的写入延迟，<em>RT</em>变小，提高了系统的吞吐量 </p>
<p><em>2</em>）消息写入到<em>Broker</em>的内存，一般是写入到了<em>PageCache</em> </p>
<p><em>3</em>）对于异步 刷盘策略，消息会写入到<em>PageCache</em>后立即返回成功<em>ACK</em>。但并不会立即做落盘操 作，而是当<em>PageCache</em>到达一定量时会自动进行落盘。</p>
<h3 id="2-Broker集群模式"><a href="#2-Broker集群模式" class="headerlink" title="2 Broker集群模式"></a><strong>2 Broker</strong>集群模式</h3><ol>
<li><p><strong>单Master</strong>：只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p>
</li>
<li><p><strong>多Master</strong>：broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。</p>
<p>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</p>
<p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响</p>
<blockquote>
<p>以上优点的前提是，这些<em>Master</em>都配置了<em>RAID</em>磁盘阵列。如果没有配置，一旦出现某<em>Master</em>宕 机，则会发生大量消息丢失的情况。</p>
</blockquote>
</li>
</ol>
<p><strong>多Master多Slave模式-异步复制</strong></p>
<p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。</p>
<p>异步复制即前面所讲的复制策略中的异步复制策略，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。</p>
<p>该模式的最大特点之一是，当master宕机后slave能够自动切换为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p>
<p><strong>多Master多Slave模式-同步双写</strong></p>
<p>该模式是多Master多Slave模式的同步复制实现。所谓同步双写，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即双写。该模式与异步复制模式相比，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。</p>
<p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave不会自动切换到Master。</p>
<h1 id="KafKa"><a href="#KafKa" class="headerlink" title="KafKa"></a>KafKa</h1>]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/08/01/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="https://redis.io/">Redis</a></p>
<img src="/2022/08/01/Redis/image-20230326184927282.png" class="" title="image-20230326184927282">

<p>7.0版本后不再出现重大bug 推荐7.0</p>
<h3 id="使用文档："><a href="#使用文档：" class="headerlink" title="使用文档："></a>使用文档：</h3><p><a href="https://redis.io/commands/?alpha=s">Commands | Redis</a>  官方文档 各种命令的解释和使用</p>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p><a href="https://blog.csdn.net/lin443514407lin/article/details/124997940">(109条消息) Linux系统下安装Redis-7.0.0_lin502的博客-CSDN博客</a></p>
<p>在linux中下载</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-<span class="number">7</span>.<span class="number">0</span>.<span class="number">0</span>.tar.gz</span><br></pre></td></tr></table></figure>

<p>使用位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>

<p>下载位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/redis-7.0.0</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-server /myredis/redis7.conf (设置读取的配置文件)</span><br></pre></td></tr></table></figure>

<p>进入客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a &quot;zsr413413&quot; (进入客户端需要登录密码-requirepass 在server读取文件中可以设置)</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h2><p>Redis支持数据类型：</p>
<p>常用5种：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<p>另外5种：GEO（地理位置），HyperLogLog（基数统计），bitmap（位图），bitfield（位域），Steam（流）。</p>
<p><a href="https://zhuanlan.zhihu.com/p/148562122">最详细的Redis五种数据结构详解（理论+实战），建议收藏。 - 知乎 (zhihu.com)</a></p>
<p>关于NX|XX 这是各种类型操作的常见参数</p>
<ul>
<li><code>NX</code> – Only set the key if it does not already exist. </li>
<li>NX命令: <strong>仅当key不存在时，set才会生效</strong>。</li>
<li><code>XX</code> – Only set the key if it already exist.</li>
<li>XX命令：<strong>仅当key存在时，set才会生效。</strong></li>
</ul>
<h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><p>String是redis最基本的类型，一个key对应一个value</p>
<p>String类类型是二进制安全的，String可以包含任何数据，比如jpg图片或序列化的对象 最大的value是512M。</p>
<h3 id="2-hash"><a href="#2-hash" class="headerlink" title="2.hash"></a>2.hash</h3><p>是一个String类型的field和value的映射表 hash特别适合存储对象 例：k1 field v1</p>
<h3 id="3-list"><a href="#3-list" class="headerlink" title="3.list"></a>3.list</h3><p>简单的String列表 按照插入顺序排序 可以添加元素到列表的头部或尾部 它的底层实际是个双端链表 最多包含2^32-1个元素。</p>
<h3 id="4-set"><a href="#4-set" class="headerlink" title="4.set"></a>4.set</h3><img src="/2022/08/01/Redis/image-20220908095506307.png" class="" title="image-20220908095506307">

<p>使用场景：</p>
<p>1.微信朋友圈点赞场景：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1. 新增点赞</td>
<td>sadd pub:msgId 点赞用户id01 点赞用户Id02</td>
</tr>
<tr>
<td>2. 取消点赞</td>
<td>smev pub:msgId 点赞用户Id01</td>
</tr>
<tr>
<td>3. 展示所有点赞用户</td>
<td>smembers pub:msgId</td>
</tr>
<tr>
<td>4. 已点赞用户数量</td>
<td>scard pub:msgId</td>
</tr>
<tr>
<td>5. 判断这条朋友圈是否已经点赞过</td>
<td>sismembers pub:msg 用户id</td>
</tr>
</tbody></table>
<h3 id="5-zset"><a href="#5-zset" class="headerlink" title="5.zset"></a>5.zset</h3><p>zset和set一样也是String类型元素的集合 不允许有重复的成员</p>
<p>不同的是：每个元素都会对应一个double类型的score  通过比较分数来进行从小到大的排序 是通过哈希表来实现的 </p>
<img src="/2022/08/01/Redis/image-20220908100053637.png" class="" title="zset命令">



<p>查找value分数值:  &gt;2 &amp;&amp; &lt;&#x3D;100 的value   ——此处命令中的 “ ( ” 代表不包含边界值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zrangebyscore <span class="title function_">zset01</span> <span class="params">(<span class="number">2</span> <span class="number">100</span> withscores</span></span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>打赏主播榜：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>某用户送出了某一个礼物 ：</td>
<td>zincrby user:sellsort 1 1001</td>
</tr>
<tr>
<td>送出礼物最多的前3个用户：</td>
<td>zrange user:sellsort 0 2 withscores</td>
</tr>
</tbody></table>
<h3 id="6-位图bitmap"><a href="#6-位图bitmap" class="headerlink" title="6. 位图bitmap"></a>6. 位图bitmap</h3><p>由0和1状态表现的二进制的bit数组 底层通过type命令查看后 依然还是string</p>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ol>
<li>电影，广告是否被点击观看过</li>
<li>用户登录和打卡签到</li>
</ol>
<img src="/2022/08/01/Redis/image-20230417143247996.png" class="" title="image-20230417143247996">

<p>其他命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strlen <span class="title function_">k1</span> <span class="params">(获取bitmap的key长度 此处的长度不是字符串长度 而是占据几个字节 <span class="number">8</span>个长度一个字节 超过<span class="number">8</span>位后自己按照<span class="number">8</span>位<span class="number">1</span>组1byte扩容)</span></span><br></pre></td></tr></table></figure>

<img src="Redis/image-20230402083041358.png" alt="image-20230402083041358" style="zoom: 67%;" />



<h3 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7. HyperLogLog"></a>7. HyperLogLog</h3><p>是用来做基数统计的算法 HyperLogLog的优点是 在输入元素的数量或者体积非常非常大时 计算基数所需的空间容量是固定的 并且是很小的 HyperLogLog不会存储输入元素本身 所以不能输出各个元素</p>
<img src="/2022/08/01/Redis/image-20230402090042790.png" class="" title="image-20230402090042790">





<h3 id="8-GEO"><a href="#8-GEO" class="headerlink" title="8.GEO"></a>8.GEO</h3><p>用于存储地理位置信息 可以添加地理位置的坐标 获取地理位置的坐标 计算两个位置之间的距离</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>核酸点距离 附近酒店 &#x2F;&#x2F;TODO 没学完</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>redis中 分别关于<strong>RDB和AOF的持久化</strong>解释：</p>
<img src="/2022/08/01/Redis/image-20230402094740867.png" class="" title="image-20230402094740867">

<ol>
<li><p>RDB：Redis DataBase 以指定的时间间隔执行数据集的时间点快照 将某一时刻的数据和状态以文件的形式写到磁盘上	生成快照文件（dump.rdb文件）</p>
</li>
<li><p>AOF：Append Only File  追加写入到文件中</p>
</li>
<li><p>RDB+AOF：</p>
</li>
</ol>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><img src="/2022/08/01/Redis/image-20230421085757842.png" class="" title="image-20230421085757842">

<p>rdb生成快照文件的时间条件：redis6和redis7中时机不同 （在redis.conf里配置的snapshot）</p>
<p>redis6： 每隔<strong>900s（15分钟）</strong> 如果有1个key发生变化 重新写一份rdb文件   </p>
<p>​				每隔300s（5分钟） 如果有10个key发生变化 重新写一份rdb文件</p>
<p>​				每隔60s （1分钟）如果有10000个key发生变化 重新写一份rdb文件					</p>
<p>redis7： 每隔<strong>3600s（60分钟）</strong> 如果有1个key发生变化 重新写一份rdb文件    （不同点）</p>
<p>​				每隔300s（5分钟） 如果有10个key发生变化 重新写一份rdb文件</p>
<p>​				每隔60s （1分钟）如果有10000个key发生变化 重新写一份rdb文件	</p>
<h4 id="触发快照-生成rdb文件："><a href="#触发快照-生成rdb文件：" class="headerlink" title="触发快照 生成rdb文件："></a>触发快照 生成rdb文件：</h4><p>在配置文件中可以设置rdb文件的生成路径 （502行）</p>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发 :"></a>自动触发 :</h5><p>在配置文件内规定的时间里进行key的修改操作 就会自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flushdb(但是这个命令生成的rdb文件只是一个空的文件 shutdown操作也会如此)</span><br></pre></td></tr></table></figure>

<p>所以不要将真正有数据的rdb文件 和 会生成空的rdb文件放在同一目录下</p>
<h5 id="手动触发："><a href="#手动触发：" class="headerlink" title="手动触发："></a>手动触发：</h5><p>对于主动想进行数据备份的操作 两个命令:  save，bgsave 相当于创建出一个子进程去生成rdb文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save 在主程序中会执行阻塞当前redis服务器 直到持久化结束 </span><br></pre></td></tr></table></figure>

<img src="Redis/image-20230402104903724-16817132858108-16820386888601.png" alt="image-20230402104903724"  />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bgsave (会在后台异步进行快照操作 不阻塞 会fork一个子进程 由它进行持久化操作 推荐使用！！！！)</span><br></pre></td></tr></table></figure>

<p><strong>使用bgsave</strong></p>
<h4 id="rdb持久化的优缺点："><a href="#rdb持久化的优缺点：" class="headerlink" title="rdb持久化的优缺点："></a>rdb持久化的优缺点：</h4><p>优点：rdb是redis数据的一个非常紧凑的单文件时间点表示 非常适合备份</p>
<p>缺点：在redis停止工作的时候 可能会丢失数据 需要将数据丢失的可能性降到最低</p>
<p>​			如果数据量太大 fork数据的时间和性能需要考虑</p>
<h4 id="如何检查和修复rdb文件："><a href="#如何检查和修复rdb文件：" class="headerlink" title="如何检查和修复rdb文件："></a>如何检查和修复rdb文件：</h4><p>redis中存在redis-check-rdb命令  使用该命令可以修复rdb文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-check-rdb /myredis/dump.rdb</span><br></pre></td></tr></table></figure>

<h4 id="触发快照的几种方式"><a href="#触发快照的几种方式" class="headerlink" title="触发快照的几种方式"></a>触发快照的几种方式</h4><img src="/2022/08/01/Redis/image-20230416213730301-16817132949599.png" class="" title="image-20230416213730301">



<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以日志的形式来记录每一个写操作 将redis执行过的所有写命令都记录下来 只允许追加写文件不可以修改写文件</p>
<p>redis重启的过程就是根据日志的文件内容将写指令从前到后执行一次 完成数据的构造过程</p>
<p>（默认情况下不开启AOF	在配置文件中配置appendonly yes）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>AOF保存的是appendonly.aof文件</p>
<h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><img src="/2022/08/01/Redis/image-20230416213751549.png" class="" title="image-20230416213751549">	

<img src="/2022/08/01/Redis/image-20230403105812988.png" class="" title="image-20230403105812988">

<h4 id="AOF缓存区三种写回策略："><a href="#AOF缓存区三种写回策略：" class="headerlink" title="AOF缓存区三种写回策略："></a>AOF缓存区三种写回策略：</h4><table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
<th>写回时机</th>
<th>丢失风险</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>每个命令执行完会立即同步到日志写回磁盘</td>
<td>同步写回</td>
<td>基本不丢失</td>
</tr>
<tr>
<td>everysec</td>
<td>每个写命令执行完 把日志写到AOF文件的缓存区 <strong>每隔1秒</strong>把缓存区的内容写到磁盘</td>
<td>每秒写回</td>
<td>1s内的数据</td>
</tr>
<tr>
<td>no</td>
<td>由操作系统决定何时将缓冲区内容写到磁盘</td>
<td>控制系统写回</td>
<td>宕机丢失较多</td>
</tr>
</tbody></table>
<p>打开AOF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendonly no （在配置文件中将其设置为yes）</span><br></pre></td></tr></table></figure>



<h4 id="AOF在redis6-和-redis-7-的区别"><a href="#AOF在redis6-和-redis-7-的区别" class="headerlink" title="AOF在redis6 和 redis 7 的区别"></a>AOF在redis6 和 redis 7 的区别</h4><p>redis6中aof文件只有一个 </p>
<p>redis7中使用MP-AOF的设计  一个文件中有三个文件构成</p>
<img src="/2022/08/01/Redis/image-20230416213817686.png" class="" title="image-20230416213817686">

<p>记录写操作命令的适合 增量文件会改变 其他不会改变</p>
<h4 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h4><p>优点：</p>
<ul>
<li>使用 AOF Redis 更加持久：您可以拥有不同的 fsync 策略：完全没有 fsync，每秒 fsync 一次，每次查询时 fsync。使用每秒 fsync 的默认策略，写入性能仍然很高。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此您只能丢失一秒钟的写入。</li>
<li>AOF 日志是仅追加日志，因此在断电时不会有寻道或损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以半写命令结束，redis-check-aof 工具也可以轻松修复它。</li>
<li>Redis 能够在 AOF 变得太大时在后台自动重写它。重写是完全安全的，因为当 Redis 继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始追加到新文件。</li>
<li>AOF 以易于理解和解析的格式包含所有操作一个接一个的日志。您甚至可以轻松导出 AOF 文件。例如，即使您使用 <a href="https://redis.io/commands/flushall"><code>FLUSHALL</code></a> 命令意外刷新了所有内容，只要在此期间没有重写日志，您仍然可以通过停止服务器、删除最新命令并重新启动 Redis 来保存数据集。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF 文件通常大于同一数据集的等效 RDB 文件。</li>
<li>AOF 可能比 RDB 慢，具体取决于确切的 fsync 策略。一般来说，将 fsync 设置为<em>每秒性能</em>仍然非常高，并且在禁用 fsync 的情况下，即使在高负载下，它应该与 RDB 一样快。尽管如此，RDB仍然能够提供更多关于最大延迟的保证，即使在巨大的写入负载的情况下也是如此。</li>
</ul>
<h4 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h4><p>启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集</p>
<p>自动触发：满足配置文件的要求 redis会记录上次重写的AOF的大小 默认配置是当AOF大小是上次rewrite后大小的一倍 且文件大于64M的时候。</p>
<p>手动触发：客户端向服务端使用 bgrewriteaof 命令</p>
<h4 id="AOF在配置文件中的各种参数"><a href="#AOF在配置文件中的各种参数" class="headerlink" title="AOF在配置文件中的各种参数"></a>AOF在配置文件中的各种参数</h4><img src="/2022/08/01/Redis/image-20230403121309520.png" class="" title="image-20230403121309520">

<h3 id="RDB-AOF"><a href="#RDB-AOF" class="headerlink" title="RDB+AOF"></a>RDB+AOF</h3><p>在两者都开启的情况下 重启机器只会加载AOF文件</p>
<p>使用RDB+AOF的混合方式 先使用RDB存储快照 再用AOF存储写入内容 当重写的策略满足或手动触发重写的时候 将最新数据存储为RDB文件 <strong>混合持久化的方式存储的文件：一部分是RDB文件 一部分是AOF文件</strong> RDB作为头部 AOF作为后续的写入内容</p>
<img src="/2022/08/01/Redis/image-20230416213959817.png" class="" title="image-20230416213959817">





<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>redis事务和MySQL事务的区别</p>
<img src="/2022/08/01/Redis/image-20230409141205391.png" class="" title="image-20230409141205391">

<p>开启事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MULTI</span><br></pre></td></tr></table></figure>

<p>执行事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>放弃执行事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DISCARD</span><br></pre></td></tr></table></figure>

<h3 id="redis事务中出现错误的情况"><a href="#redis事务中出现错误的情况" class="headerlink" title="redis事务中出现错误的情况"></a>redis事务中出现错误的情况</h3><ol>
<li>redisd的命令如果不执行就判断为错误 则无法加入到队列中  导致所有其他正确的命令也不会执行</li>
<li>redis的命令如果执行后发生错误 那么就不会影响该事务中其他命令的正常执行</li>
<li>redis不支持事务回滚 出现错误自行恢复</li>
</ol>
<h3 id="redis的锁"><a href="#redis的锁" class="headerlink" title="redis的锁"></a>redis的锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">watch key</span><br></pre></td></tr></table></figure>

<p>如果事务在执行的过程中 其中被事务以外的其他命令干扰 那么这个事务会返回nil  整个事务执行失败</p>
<p>如果不加锁的话 事务会直接执行 但不生效</p>
<h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><img src="/2022/08/01/Redis/image-20230409144205814.png" class="" title="image-20230409144205814">

<img src="/2022/08/01/Redis/image-20230409144227529.png" class="" title="image-20230409144227529">

<img src="/2022/08/01/Redis/image-20230409144258535.png" class="" title="image-20230409144258535">

<img src="/2022/08/01/Redis/image-20230409144428842.png" class="" title="image-20230409144428842">

<h3 id="redis管道在客户端中使用"><a href="#redis管道在客户端中使用" class="headerlink" title="redis管道在客户端中使用"></a>redis管道在客户端中使用</h3><p>pipeline（管道）是需要linux的客户端共同使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat rediscmd.txt | redis-cli -a <span class="string">&quot;zsr413413&quot;</span> --pipe</span><br></pre></td></tr></table></figure>

<h3 id="redis的管道和事务的区别"><a href="#redis的管道和事务的区别" class="headerlink" title="redis的管道和事务的区别"></a>redis的管道和事务的区别</h3><p>管道pipeline是批处理 而事务是原子性 事务会阻塞 而批处理不会阻塞</p>
<h1 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h1><img src="/2022/08/01/Redis/image-20230409151233087.png" class="" title="image-20230409151233087">

<p>master以写为主 salver以读为主</p>
<p>主从复制能干什么？</p>
<p>​	读写分离 容灾恢复 数据备份 水平扩容支撑高并发</p>
<p>如何配置？i	在slaver节点中配置 寻找master节点 在slaver中配置master的password</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">info <span class="title function_">replication</span> <span class="params">(查看复制节点的主从关系和配置信息)</span></span><br></pre></td></tr></table></figure>

<p>具体操作&#x2F;&#x2F;TODO</p>
<p>关于主从复制的总结</p>
<ol>
<li><p>slave启动 同步初清 slave启动成功后会向master发送一个sync命令 slave首次全新连接master slave自身数据被清除</p>
</li>
<li><p>首次连接 全量复制 mater收到sync命令后会在后台保存快照（rdb）同时收集所有接收到的用于修改数据集命令缓存起来 master的rdb持久化之后 rdb快照文件和所有缓存的命令发送到所有slave 完成这一次同步</p>
</li>
<li><p>心跳持续 保持通信 master发送ping包检测slave的存活状态</p>
</li>
<li><p>进入平稳 增量复制 master继续将新收集到的指令集发送给slave 完成同步</p>
</li>
<li><p>从机下线 重新续传 当slave下线后重新上线 master会根据backlog里面的offset 把新的内容传给slave</p>
</li>
</ol>
<h1 id="Redis中常用的Java的客户端"><a href="#Redis中常用的Java的客户端" class="headerlink" title="Redis中常用的Java的客户端"></a>Redis中常用的Java的客户端</h1><img src="/2022/08/01/Redis/image-20220915082700182.png" class="" title="image-20220915082700182">





<h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</p>
<p>官网：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<h3 id="提供功能"><a href="#提供功能" class="headerlink" title="提供功能"></a>提供功能</h3><ol>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>SpringDataRedis的使用步骤：</p>
<ol>
<li>引入spring-boot-starter-data-redis依赖</li>
<li>在application.yml配置Redis信息</li>
<li>注入RedisTemplate</li>
</ol>
<h3 id="关于SpringDataRedis的序列化（使用Stringredistemplate）"><a href="#关于SpringDataRedis的序列化（使用Stringredistemplate）" class="headerlink" title="关于SpringDataRedis的序列化（使用Stringredistemplate）"></a>关于SpringDataRedis的序列化（使用Stringredistemplate）</h3><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<img src="/2022/08/01/Redis/image-20220915083459885.png" class="" title="image-20220915083459885">

<p>这样的方式会导致数据：<strong>可读性差，内存占用较大。</strong></p>
<p>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。</p>
<p>使用方法：</p>
<ol>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ol>
<h1 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h1><p>在实际项目中，我们通常要借助redis完成一些其他数据库完成不到的功能。</p>
<h2 id="Redis的-缓存穿透，雪崩，击穿"><a href="#Redis的-缓存穿透，雪崩，击穿" class="headerlink" title="Redis的 缓存穿透，雪崩，击穿"></a>Redis的 缓存穿透，雪崩，击穿</h2><p>redis可以作为缓存信息数据库存入用户查询的信息，将查询信息缓存到redis中后，数据库的压力会大大减小。</p>
<img src="/2022/08/01/Redis/image-20220915084849919.png" class="" title="image-20220915084849919">

<p>但是redis的内部空间是有限的，缓存信息不可以一直存在于redis中，所以我们需要设置redis内部信息的缓存淘汰机制。针对不同的缓存信息，我们需要制定不同的淘汰策略，比如对于一些更改机率很小的数据，我们通常不会改变它，所以这种低一致性的数据，我们可以使用内存淘汰机制。而像一些经常更改且用户经常查询的数据，我们采用主动更新的方式去完成，并采用超时兜底作为结局方案。</p>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p><a href="https://blog.csdn.net/qq_43390895/article/details/107669478">(55条消息) 数据一致性问题、redis如何与数据库保持一致性问题，完整版详解_qq_43390895的博客-CSDN博客_redis和数据库怎么保证数据一致性</a></p>
<p>关于主动更新，我们有三个问题需要考虑：</p>
<ol>
<li><p>数据更改时，对于redis中的缓存，我们是选择<strong>更新</strong>还是<strong>删除</strong>？</p>
<p>更新缓存：每次更新数据库都更新缓存，无效写操作较多<br>删除缓存：更新数据库时让缓存失效，查询时再更新缓存 	√</p>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功与失败？</p>
</li>
</ol>
<p>​		单体系统，将缓存与数据库操作放在一个事务<br>​		分布式系统，利用TCC等分布式事务方案</p>
<ol start="3">
<li>先更新缓存还是先更新数据库？</li>
</ol>
<p>​		<strong>读操作</strong>：缓存命中则直接返回，缓存未命中则查询数据库，并写入缓存，设定超时时间。<br>​		写操作：先写数据库，然后再删除缓存，要确保数据库与缓存操作的原子性。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库，过多的请求会导致数据库压力过大。</p>
<p>两种解决方案：</p>
<ol>
<li><p>存空对象</p>
<p>优点：实现简单，维护方便<br>缺点：额外的内存消耗，可能造成短期的不一致。</p>
<img src="/2022/08/01/Redis/image-20220915092242875.png" class="" title="image-20220915092242875">
</li>
<li><p>布隆过滤<br>优点：内存占用较少，没有多余key<br>缺点：实现复杂，存在误判可能。</p>
</li>
</ol>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p><a href="https://developer.aliyun.com/article/773205">布隆过滤器，这一篇给你讲的明明白白-阿里云开发者社区 (aliyun.com)</a></p>
<img src="/2022/08/01/Redis/007S8ZIlly1gebuc2ee3dj31o10u0drg.jpg" class="" title="img">

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决办法：</p>
<ol>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫热点Key问题，就是<strong>某一个</strong>被<strong>高并发访问</strong>并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。<br>常见的解决方案有两种：</p>
<ol>
<li>互斥锁</li>
</ol>
<img src="/2022/08/01/Redis/image-20220915095422162.png" class="" title="image-20220915095422162">

<ol start="2">
<li>逻辑过期</li>
</ol>
<h2 id="单点登录SSO"><a href="#单点登录SSO" class="headerlink" title="单点登录SSO"></a>单点登录SSO</h2><p><a href="https://blog.csdn.net/WuCourage/article/details/77802812">Redis实现单点登录_初学者W的博客-CSDN博客</a></p>
<img src="/2022/08/01/Redis/SouthEast.png" class="" title="SSO登录流程">



<p>1、登录页面提交用户名密码。<br>2、登录成功后生成token。Token相当于原来的jsessionid，字符串，可以使用uuid。<br>3、把用户信息保存到redis。<strong>Key就是token，value就是TbUser对象转换成json</strong>。<br>4、使用String类型保存Session信息。可以使用“前缀:token”为key<br>5、设置key的过期时间。模拟Session的过期时间。一般半个小时。<br>6、把token写入cookie中。<br>7、Cookie需要跨域。例如<a href="http://www.jd.com/sso.jd.com/order.jd.com%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E3%80%82">www.jd.com\sso.jd.com\order.jd.com，可以使用工具类。</a><br>8、Cookie的有效期。关闭浏览器失效。<br>9、登录成功。</p>
<h2 id="最热话题，点赞排行"><a href="#最热话题，点赞排行" class="headerlink" title="最热话题，点赞排行"></a>最热话题，点赞排行</h2><h2 id="短信登陆"><a href="#短信登陆" class="headerlink" title="短信登陆"></a>短信登陆</h2><h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h2 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h2><h2 id="商品秒杀"><a href="#商品秒杀" class="headerlink" title="商品秒杀"></a>商品秒杀</h2><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><a href="https://github.com/redisson/redisson">GitHub - redisson&#x2F;redisson: Redisson - Redis Java client with features of In-Memory Data Grid. Over 50 Redis based Java objects and services: Set, Multimap, SortedSet, Map, List, Queue, Deque, Semaphore, Lock, AtomicLong, Map Reduce, Publish &#x2F; Subscribe, Bloom filter, Spring Cache, Tomcat, Scheduler, JCache API, Hibernate, MyBatis, RPC, local cache …</a></p>
<p>巨人的肩膀：</p>
<p><a href="https://blog.csdn.net/pyufftj/article/details/106955607">(113条消息) Redis - NX与XX_redis xx_平_繁的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat的网络请求及Web界面的工作流程</title>
    <url>/2022/05/18/Server/</url>
    <content><![CDATA[<img src="/2022/05/18/Server/image-20220819104112930.png" class="" title="image-20220819104112930">

<p><a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a></p>
<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><p>Web (World Wide Web) 即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面。</p>
<p>那么Web端就是可以浏览Internet上信息的设备，再说得简单点，就是设备上可以安装浏览器，都可以称之为Web端，可以是台笔记本电脑，也可以是PAD,或是一台冰箱，只要<strong>可以安装浏览器的设备</strong>，我们都可以称之为Web端。</p>
<span id="more"></span>

<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Java Servlet（Java服务器小程序）是一个<strong>基于Java</strong>技术的Web组件，运行在服务器端，它<strong>由Servlet容器</strong>所管理，用于生成动态的内容。 Servlet是平台独立的Java类，编写一个Servlet，<strong>实际上就是按照Servlet规范编写一个Java类</strong>。Servlet被编译为平台独立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。</p>
<h1 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h1><p>Servlet容器也叫做Servlet引擎，是<strong>Web服务器</strong>或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于MIME的请求，格式化基于MIME的响应。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包容和管理Servlet。在JSP技术 推出后，管理和运行Servlet&#x2F;JSP的容器也称为Web容器。</p>
<img src="/2022/05/18/Server/v2-ca567ba088698a36d2d418358f45ad9d_720w.jpg" class="" title="img">

<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>Server是Tomcat最顶层的容器，代表着整个服务器，即一个Tomcat只有一个Server，Server中包含至少一个Service组件，用于提供具体服务。</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>作为后端开发，数据传输到前端界面，或者浏览器运行，如果出现问题，那么就会让人崩溃，各种错误代码扑面而来，让头发焦急。</p>
<p>每当一个项目开始运行（启动）那么，支撑浏览器到达指定端口的位置，并且显示界面的，显示数据的，一定是服务器的工作，在本地的项目开始运行，tomcat就充当这个服务器的角色，所以tomcat是web应用服务器,是用来处理java程序的一个应用服务器。</p>
<p>Tomcat是⼀个由⼀系列可配置（conf&#x2F;server.xml）的组件构成的Web容器，⽽<strong>Catalina是Tomcat的servlet容器</strong>。从另⼀个⻆度来说，Tomcat 本质上就是⼀款 Servlet 容器， 因为 Catalina 才是 Tomcat 的核⼼ ， 其他模块都是为Catalina 提供⽀撑的。 ⽐如 ： 通过 Coyote 模块提供链接通信，Jasper 模块提供 JSP 引擎，Naming 提供JNDI 服务，Juli 提供⽇志服务。</p>
<p>Tomcat 组件：</p>
<img src="/2022/05/18/Server/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTk0Mzg4,size_16,color_FFFFFF,t_70.png" class="" title="Tomcat 组件">

<h2 id="Servlet-和-Server-的关系"><a href="#Servlet-和-Server-的关系" class="headerlink" title="Servlet 和 Server 的关系"></a>Servlet 和 Server 的关系</h2><p>Server 元素表示整个 Catalina servlet 容器。</p>
<h2 id="Tomcat和Catelina的关系"><a href="#Tomcat和Catelina的关系" class="headerlink" title="Tomcat和Catelina的关系"></a>Tomcat和Catelina的关系</h2><p>我们往往有⼀个认识，Tomcat就是⼀个Catalina的实例，因为Catalina是Tomcat的核⼼，其实，<strong>可以认为整个Tomcat就是⼀个Catalina实例，Tomcat 启动的时候会初始化这个实例</strong>，Catalina实例通过加载server.xml完成其他实例的创建，创建并管理<strong>⼀个Server</strong>，Server创建并管理多个服务，每个服务⼜可以有<strong>多个Connector和⼀个Container。</strong></p>
<h2 id="Catalina-的结构（Servlet容器）"><a href="#Catalina-的结构（Servlet容器）" class="headerlink" title="Catalina 的结构（Servlet容器）"></a>Catalina 的结构（Servlet容器）</h2><img src="/2022/05/18/Server/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTk0Mzg4,size_16,color_FFFFFF,t_70-16608748133523.png" class="" title="Catalina 的结构">



<p><strong>Catalina</strong><br>负责解析Tomcat的配置⽂件（server.xml） , 以此来创建服务器Server组件并进⾏管理<br><strong>Server</strong><br>Server表示整个Catalina Servlet容器以及其它组件，负责组装并启动Servlaet引擎,Tomcat连接器。Server通过实现Lifecycle接⼝，提供了⼀种优雅的启动和关闭整个系统的⽅式<br><strong>Service</strong><br>服务是Server内部的组件，⼀个Server包含多个Service。它将若⼲个Connector组件绑定到⼀个Container容器，负责处理⽤户的servlet请求，并返回对象给web⽤户的模块Container 组件的具体结构。<br><strong>Connector</strong><br>连接器（Connector）处理与客户端的通信，它负责接收客户请求，以及向客户返回响应结果。在Tomcat中，有多个连接器可以使用。</p>
<h2 id="Container-组件的具体结构"><a href="#Container-组件的具体结构" class="headerlink" title="Container 组件的具体结构"></a>Container 组件的具体结构</h2><p>Container组件下有⼏种具体的组件，分别是Engine、Host、Context和Wrapper。这4种组件（容器）是⽗⼦关系。Tomcat通过⼀种分层的架构，使得Servlet容器具有很好的灵活性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200801170056168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTk0Mzg4,size_16,color_FFFFFF,t_70" alt="Container 组件的具体结构"></p>
<p><strong>Engine</strong><br>表示整个Catalina的Servlet引擎，⽤来管理多个虚拟站点，⼀个Service最多只能有⼀个Engine，但是⼀个引擎可包含多个Host<br><strong>Host</strong><br>表示一个虚拟主机，一个引擎可以包含多个Host。用户通常不需要创建自定义的Host，因为Tomcat给出的Host接口的实现（类StandardHost）提供了重要的附加功能。<br><strong>Context</strong><br>一个Context表示了一个Web应用程序，运行在特定的虚拟主机中（Web应用程序：一个Web应用程序是由一组Servlet、HTML页面、类，以及其他的资源组成的运行在Web服务器上的完整的应用程序。它可以在多个供应商提供的实现了Servlet规范的Web容器中运行）。<br><strong>Wrapper</strong><br>wrapper是四大容器最底层的容器，是请求处理的真正容器。与servlet的区别是：wrapper本质并未处理请求，而是加载对应的servlet来处理，在这之前也会调用filter。</p>
<img src="/2022/05/18/Server/20160816205332380.png" class="" title="Tomcat总体架构">



<p><a href="https://zhuanlan.zhihu.com/p/40249834">几个概念：Servlet、Servlet容器、Tomcat - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_36194388/article/details/107733315">(43条消息) Tomcat Servlet 容器 Catalina基本认识_时小浅的博客-CSDN博客</a></p>
<h2 id="整体请求流程"><a href="#整体请求流程" class="headerlink" title="整体请求流程"></a>整体请求流程</h2><img src="/2022/05/18/Server/image-20220819103553762.png" class="" title="image-20220819103553762">



<h1 id="Servlet深入"><a href="#Servlet深入" class="headerlink" title="Servlet深入"></a>Servlet深入</h1><p><a href="https://blog.csdn.net/qq_19782019/article/details/80292110?ops_request_misc=%7B%22request_id%22:%22166086995916781790723169%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166086995916781790723169&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80292110-null-null.142%5Ev42%5Econtrol,185%5Ev2%5Econtrol&utm_term=Servlet&spm=1018.2226.3001.4187">(43条消息) JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_刘扬俊的博客-CSDN博客_servlet</a></p>
<h1 id="Requset-和-Response"><a href="#Requset-和-Response" class="headerlink" title="Requset 和 Response"></a>Requset 和 Response</h1><h2 id="Request和Response的生命周期"><a href="#Request和Response的生命周期" class="headerlink" title="Request和Response的生命周期"></a>Request和Response的生命周期</h2><img src="/2022/05/18/Server/image-20220826102149537.png" class="" title="image-20220826102149537">

<ol>
<li>服务器在接收到客户端的请求之后，会创建request对象和response对象</li>
<li>服务器会通过request对象把客户的数据，包括请求信息都封装到这个对象里面</li>
<li>所以我们在控制层，servlet里面就是service方法里面通过request得到很多数据，并对信息进行相应的业务处理，最后反馈给用户结果</li>
<li>这个结果我们是通过response来封装的，并带到用户面前</li>
<li>当这整个过程结束之后，request和response对象的周期也就结束了，他们的生命范围就是用户的一次请求和得到的一次结果的反馈。</li>
</ol>
<h3 id="Request、Response对象的内存地址维护"><a href="#Request、Response对象的内存地址维护" class="headerlink" title="Request、Response对象的内存地址维护:"></a>Request、Response对象的内存地址维护:</h3><p>1、在同一个浏览器中不断的向同一个Servlet发送请求，reqeust和response不断的新建和销毁但是内存地址没有改变。是因为tomcat根据访问的IP地址对reqeust和response内存地址进行维护，当reqeust和response对象销毁后，tomcat不会立刻将该内存地址销毁，而是将该内存进行占位，等到下次创建新的reqeust和response对象就会分配到这个内存中。避免了不断分配新内存造成资源浪费。<br>2、如果该内存长时间（默认30分钟）没有reqeust和response对象，将会销毁该内存地址，或是存放其他的对象。</p>
<h2 id="Request和Response的区别"><a href="#Request和Response的区别" class="headerlink" title="Request和Response的区别"></a>Request和Response的区别</h2><h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><h3 id="请求转发（forward"><a href="#请求转发（forward" class="headerlink" title="请求转发（forward)"></a>请求转发（forward)</h3><img src="/2022/05/18/Server/image-20220826102117571.png" class="" title="image-20220826102117571">

<p>（1）转发是一次请求，一次响应<br>（2）请求转发前后，浏览器的地址栏地址不会发生变化。（浏览器–访问–&gt; A –转发–&gt; B，地址栏地址始终指向A的地址）<br>（3）请求转发前后的request对象是同一个（转发前在A中的request和转发到B后，B中的request对象和A中的request对象是同一个。基于这一点，可以通过request从A带数据到B）<br>（4）请求转发前后的两个资源必须<strong>属于同一个Web应用</strong>，否则将无法进行转发。（A–转发–&gt;B，A和B必须属于同一个Web应用！）</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(url地址/转发到资源的地址).forward(req, res);</span><br></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><img src="/2022/05/18/Server/image-20220826102056812.png" class="" title="image-20220826102056812">

<p>（1）重定向是两次请求、两次响应<br>（2）重定向前后，浏览器的地址栏地址会发生变化。（因为两次请求都是通过浏览器发起，浏览器知道这个跳转的过程，因此地址栏地址会变化）<br>（3）重定向前后的<strong>request对象不是同一个</strong>（因为重定向是两次请求，服务器会根据两次请求创建两个不同的request对象，request对象不是同一个，也就不能在重定向时通过request带数据到目的地。）<br>（4）重定向前后的两个资源可以是来自不同的web应用，甚至可以是来自不同的服务器。(进行跳转的两个资源之间没有限制)。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(所重定向到资源的URL地址);</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_45151795/article/details/105999196">(48条消息) Request、Response对象的生命周期_段远山的博客-CSDN博客_response生命周期</a></p>
<p><a href="https://blog.csdn.net/qq1808814025/article/details/106199159">(43条消息) request和response的区别!!!_经理，天台风好大的博客-CSDN博客_request和response的区别</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Cloud Alibaba</title>
    <url>/2022/07/01/Spring-Cloud-Alibaba/</url>
    <content><![CDATA[<p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html">Spring Cloud Alibaba 参考文档 (spring-cloud-alibaba-group.github.io)</a></p>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba">alibaba&#x2F;spring-cloud-alibaba: Spring Cloud Alibaba provides a one-stop solution for application development for the distributed solutions of Alibaba middleware. (github.com)</a></p>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><img src="https://mrhelloworld.com/resources/articles/articles_header/2020/06/03/header.jpg" alt="https://mrhelloworld.com/resources/articles/articles_header/2020/06/03/header.jpg" style="zoom:80%;" />

<span id="more"></span>

<h2 id="Nacos-x3D-eureka-config-bus-！！！"><a href="#Nacos-x3D-eureka-config-bus-！！！" class="headerlink" title="Nacos &#x3D; eureka + config + bus ！！！"></a><strong>Nacos &#x3D; eureka + config + bus ！！！</strong></h2><p>Quick Start</p>
<p>首先打开下载好的nacos，进入bin目录启动start.cmd 就开启了本地的nacos服务</p>
<h2 id="作为注册中心"><a href="#作为注册中心" class="headerlink" title="作为注册中心"></a>作为注册中心</h2><p>开启nacos服务后,相当与配置了一个完整的eureka服务并开启,nacos的本地地址为<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p>
<p>接下来姐可以开启服务模块和客服模块了.</p>
<p>服务模块:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日常通用jar包配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>主启动类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nacos和其他注册中心比较"><a href="#Nacos和其他注册中心比较" class="headerlink" title="Nacos和其他注册中心比较"></a>Nacos和其他注册中心比较</h2><p>Nacos自动支持CP和AP</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706154546368.png" class="" title="image-20220706154546368">

<p>Nacos如何切换AP和CP?</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#x27;$NACOS_SERVER:<span class="number">8848</span>/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="作为配置中心Config"><a href="#作为配置中心Config" class="headerlink" title="作为配置中心Config"></a>作为配置中心Config</h2><p>在nacos的配置文件的命名规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个微服务，cloudalibaba-config-nacos-client3377</p>
<p>需要 <strong>application.yaml 和 bootstrap.yaml</strong> 两个配置文件 (为了能和SpringCloud平滑过渡）</p>
<blockquote>
<p> <em><strong>bootstrap.yaml的优先级高于application.yaml</strong></em></p>
</blockquote>
<p>1.application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line"><span class="comment">#    active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bootstrap.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"><span class="comment">#        group: DEV_GROUP # 指定分组</span></span><br><span class="line"><span class="comment">#        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4 # 指定命名空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>



<p>因为nacos集成了bus+config+eureka 所以当nacos的配置文件进行修改了之后 其config客户端自动就会进行动态刷新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用@Value注解自动填充配置文件里的信息。</p>
<p>于是就可以获取的到文件了。</p>
<h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><p><strong>之后想要不同的配置文件则切换环境就可以了。首先可以再 bootstrap.yaml指定命名空间namespace 然后 Group 最后在 application.yaml 通过命名规则指定 DataID。</strong></p>
<h2 id="Group和Data-ID"><a href="#Group和Data-ID" class="headerlink" title="Group和Data ID"></a>Group和Data ID</h2><img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220701200647822.png" class="" title="image-20220701200647822">

<p>所以，当我们需要制定某个配置文件的时候，就需要Group和Data Id配合使用 所以就需要application.yaml和bootstrap.yaml两个配置文件配合使用。</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220707105954569.png" class="" title="image-20220707105954569">



<h2 id="Nacos集群配置"><a href="#Nacos集群配置" class="headerlink" title="Nacos集群配置"></a>Nacos集群配置</h2><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">集群部署说明 (nacos.io)</a></p>
<p>作为服务注册中心，为了保证其可用性以及出现宕机的意外情况，应该配置nacos集群以保证线上环境的稳定。</p>
<p><img src="https://nacos.io/img/deployDnsVipMode.jpg" alt="deployDnsVipMode.jpg"></p>
<p>SLB代表的是负载均衡的集群配置，此处使用的是nginx的一个集群配置。<a href="https://developer.aliyun.com/article/1803">SLB技术原理浅析-阿里云开发者社区 (aliyun.com)</a></p>
<p>关于nacos的数据源使用高可用数据库，类似以下情况架构</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220702100327727.png" class="" title="image-20220702100327727">

<p>从github上的源码中查看nacos的pom依赖文件，<strong>derby是nacos自带的内置数据库</strong>，所以我们的配置文件才得以保存在nacos中，而当我们需要一个稳定的数据源的使用，就需要将这个<strong>derby数据库切换为mysql数据库</strong>（集群）</p>
<p>切换步骤：（本机电脑未切换）</p>
<p>nacos-server-1.1.3\nacos\conf\nacos-mysql.sql </p>
<p>复制该sql脚本到本地数据库中，创建对应配置文件表。</p>
<p>nacos-server-1.1.3\nacos\conf\application.properties</p>
<p>修改该配置文件，在最后添加一段配置，指向本地mysql</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">介绍 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>
<img src="https://user-images.githubusercontent.com/9434884/43697219-3cb4ef3a-9975-11e8-9a9c-73f4f537442d.png" alt="Sentinel Logo" style="zoom: 50%;" />

<p>Sentinel单独组件，直接界面化的细粒度统一配置。</p>
<p>Sentinel 是什么？<br>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性</p>
<p>Sentinel的官方标题是：分布式系统的流量防卫兵。从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。</p>
<p>在官网下载jar包后，使用java -jar命令运行该项目，访问localhost:8080 即可进入（通常情况下同时配合Nacos使用，Sentinel与Nacos进行具体服务的操作和配置）</p>
<h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><p>Sentinel 不需要Hystrix一样自己进行服务的搭建，而是直接运行jar包启动服务。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard-<span class="number">1</span>.<span class="number">7</span>.<span class="number">0</span>.jar</span><br></pre></td></tr></table></figure>

<p>运行具体版本jar包。</p>
<p>支付端：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"><span class="comment">#      datasource:</span></span><br><span class="line"><span class="comment">#        ds1:</span></span><br><span class="line"><span class="comment">#          nacos:</span></span><br><span class="line"><span class="comment">#            server-addr: localhost:8848</span></span><br><span class="line"><span class="comment">#            dataId: cloudalibaba-sentinel-service</span></span><br><span class="line"><span class="comment">#            groupId: DEFAULT_GROUP</span></span><br><span class="line"><span class="comment">#            data-type: json</span></span><br><span class="line"><span class="comment">#            rule-type: flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#feign:</span></span><br><span class="line"><span class="comment">#  sentinel:</span></span><br><span class="line"><span class="comment">#    enabled: true # 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure>



<h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><h3 id="流控规则的规则意义"><a href="#流控规则的规则意义" class="headerlink" title="流控规则的规则意义"></a>流控规则的规则意义</h3><p>Sentinel 作为一种轻量级高可用流量控制组件，流量控制是它最主要的工作之一。</p>
<p>我们可以针对资源定义流控规则，Sentinel 会根据这些规则对流量相关的各项指标进行监控。当这些指标当达到或超过流控规则规定的阈值时，Sentinel 会对请求的流量进行限制（即“限流”），以避免系统被瞬时的流量高峰冲垮，保障系统的高可用性。</p>
<p><strong>同一个资源可以创建多条流控规则，Sentinel 会遍历这些规则，直到有规则触发限流或者所有规则遍历完毕为止。</strong></p>
<h3 id="流控规则的具体实现"><a href="#流控规则的具体实现" class="headerlink" title="流控规则的具体实现"></a>流控规则的具体实现</h3><img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706153537108.jpg" class="" title="image-20220706153537108">



<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220703105117104.png" class="" title="image-20220703105117104">

<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220703105210793.png" class="" title="image-20220703105210793">



<p>添加流控规则添加：簇点链路 ——&gt;列表视图 ——&gt;选择具体资源名  就可以继续进行流控限制。</p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel <strong>熔断降级</strong>会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 <code>DegradeException</code>）。</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/10252343H-15.png" class="" title="Sentinel 熔断状态转换">

<h3 id="Sentinel-熔断策略"><a href="#Sentinel-熔断策略" class="headerlink" title="Sentinel 熔断策略"></a>Sentinel 熔断策略</h3><ol>
<li><strong>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)<strong>：当 1s 内持续进入 5 个请求（大于等于5），对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口期（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，</strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li>
<li>**异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)**：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li>**异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)**：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li>
</ol>
<p><strong>需要注意的是</strong>：</p>
<p>RT和异常比例分别需要满足的条件不只是处理时间和异常的所占比率，而且<strong>都需要满足每秒的请求数 &gt;&#x3D;5</strong>，如果请求数目不满足的话，只会进入RunTimeException然后返回常见的报错界面。</p>
<p>Sentinel 1.8.0 版本对熔断降级特性进行了全新的改进升级，以下熔断策略针对的是 Sentinel 1.8.0 及以上版本。</p>
<h4 id="Sentinel-1-8-0-以上熔断策略"><a href="#Sentinel-1-8-0-以上熔断策略" class="headerlink" title="Sentinel 1.8.0 以上熔断策略"></a>Sentinel 1.8.0 以上熔断策略</h4><p>Sentinel 提供了 3 种熔断策略，如下表所示。</p>
<table>
<thead>
<tr>
<th>熔断策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>慢调用比例 (SLOW_REQUEST_RATIO）</td>
<td>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大响应时间），若请求的响应时间大于该值则统计为慢调用。  当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则再次被熔断。</td>
</tr>
<tr>
<td>异常比例 (ERROR_RATIO)</td>
<td>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目且异常的比例大于阈值，则在接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</td>
</tr>
<tr>
<td>异常数 (ERROR_COUNT)</td>
<td>当单位统计时长内的异常数目超过阈值之后会自动进行熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</td>
</tr>
</tbody></table>
<h3 id="和Hystrix的熔断降级对比"><a href="#和Hystrix的熔断降级对比" class="headerlink" title="和Hystrix的熔断降级对比"></a>和Hystrix的熔断降级对比</h3><p>Sentinel 和 Hystrix 的熔断降级功能本质上都是基于熔断器模式（Circuit Breaker Pattern）。Sentinel 与 Hystrix 都支持基于失败比率（异常比率）的熔断降级，在调用达到一定量级并且失败比率达到设定的阈值时自动进行熔断，此时所有对该资源的调用都会被 block，直到过了指定的时间窗口后才启发性地恢复。Sentinel 还支持基于平均响应时间的熔断降级，可以在服务响应时间持续飙高的时候自动熔断，拒绝掉更多的请求，直到一段时间后才恢复。这样可以防止调用非常慢造成级联阻塞的情况。</p>
<p>Hystrix存在半开规则，判断是否可以恢复服务，而<strong>Sentinel的熔断器是没有半开状态</strong>的，取而代之的是时间窗口期内的<strong>探测恢复状态</strong>。</p>
<h2 id="热点Key"><a href="#热点Key" class="headerlink" title="热点Key"></a>热点Key</h2><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<ul>
<li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li>
<li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li>
</ul>
<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。<br> Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新增热点规则：</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706104040702.png" class="" title="image-20220706104040702">

<p>限流规则：仅支持QPS（线程数）</p>
<p>参数索引：指定限制的热点参数的索引位置</p>
<p>单机阈值：流量个数</p>
<p>统计时长：休息的窗口期 </p>
<p>如果使用了热点规则，强烈建议**@SentinelResource注解添加blockHandler参数**，否则返回正常的错误界面，不友好。</p>
<h3 id="参数例外项："><a href="#参数例外项：" class="headerlink" title="参数例外项："></a>参数例外项：</h3><p>选择高级选项，具体到某一参数的具体值进行限流控制。仅支持八大数据类型。</p>
<h2 id="系统自适应限流"><a href="#系统自适应限流" class="headerlink" title="系统自适应限流"></a>系统自适应限流</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">系统自适应限流 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>
<p>Sentinel 系统<strong>自适应限流从整体维度对应用入口流量进行控制</strong>，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个<strong>平衡</strong>，让系统尽可能跑在最大吞吐量的同时保证系统整体的<strong>稳定性</strong>。</p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h2 id="SentinelResource注解配置"><a href="#SentinelResource注解配置" class="headerlink" title="@SentinelResource注解配置"></a>@SentinelResource注解配置</h2><p>以上使用@SentinelResource的规则 我们要面临以下几个问题。</p>
<ol>
<li>系统默认的，没有体现我们自己的业务逻辑</li>
<li>依照现有条件，我们自定义的处理方法又和业务模块耦合在一起，耦合度高。</li>
<li>每个业务方法都添加一个blockhandler兜底方法，代发过于冗余。</li>
<li>没有全局统一的处理方法。</li>
</ol>
<p>对于很多的方法类，如果都需要一个降级的blockHandler兜底方法，不能挨个配置，可以定义一个公共的降级方法提供给这些方法使用。</p>
<p>所以我们可以解锁 @SentinelResource 的更多姿势：写一个公共类（本例中为CustomerBlockHandler），可以定义不同的静态blockHandler方法提供给其他方法，在具体方法上添加@SentinelResource注解，然后（blockHandlerClass ）指定处理异常的类，（blockHandler）再具体到这个类中的某个方法。</p>
<p>配置参数和具体方法的对应位置：</p>
<img src="/2022/07/01/Spring-Cloud-Alibaba/image-20220706151534201.png" class="" title="image-20220706151534201">





<h1 id="Sentinel-整合Ribbon-OpenFeign-Fallback"><a href="#Sentinel-整合Ribbon-OpenFeign-Fallback" class="headerlink" title="Sentinel 整合Ribbon+OpenFeign+Fallback"></a>Sentinel 整合Ribbon+OpenFeign+Fallback</h1><blockquote>
<p> 本地三个微服务：提供者cloudalibaba-provider-payment9003 cloudalibaba-provider-payment9004 								</p>
<p>​								消费者 cloudalibaba-consumer-nacos-order84	</p>
</blockquote>
<p>巨人的肩膀：</p>
<p><a href="https://developer.aliyun.com/article/623424">Sentinel 与 Hystrix 的对比-阿里云开发者社区 (aliyun.com)</a></p>
<p><a href="http://c.biancheng.net/springcloud/sentinel.html">Sentinel：Spring Cloud Alibaba高可用流量控制组件（非常详细） (biancheng.net)</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2022/05/26/Spring/</url>
    <content><![CDATA[<p>[Spring官网]<a href="https://spring.io/">Spring | Home</a></p>
<img src="/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg" class="" title="v2-f35943a6d87c5f9f10f45eee4941deb3_720w">

<h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h1><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的大小。	然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>​	<strong>简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。</strong></p>
<span id="more"></span>

<h1 id="Spring的核心组件"><a href="#Spring的核心组件" class="headerlink" title="Spring的核心组件"></a>Spring的核心组件</h1><img src="/2022/05/26/Spring/image-20220526175028291-16536637559683.png" class="" title="image-20220526175028291">

<h1 id="Spring大致加载流程"><a href="#Spring大致加载流程" class="headerlink" title="Spring大致加载流程"></a>Spring大致加载流程</h1><img src="/2022/05/26/Spring/image-20220731112029587.png" class="" title="image-20220731112029587">

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Spring是一个生态圈，需要的是新的拓展功能不停的进行完善，所以我们可以通过BeanFactoryPostProcesser和BeanPostProcesser进行Spring功能的拓展。所以 Spring最核心的一个思想就是<strong>拓展</strong>。</p>
<h2 id="BeanFactoryPostProcesser："><a href="#BeanFactoryPostProcesser：" class="headerlink" title="BeanFactoryPostProcesser："></a>BeanFactoryPostProcesser：</h2><p><strong>功能：允许自定义对ApplicationContext的 bean definitions 进行修饰，扩展功能。</strong> </p>
<p>BeanFactoryPostProcessor是<strong>实现spring容器功能扩展的重要接口</strong>，例如修改bean属性值，实现bean动态代理等。很多框架都是通过此接口实现对spring容器的扩展，例如mybatis与spring集成时，只定义了mapper接口，无实现类，但spring却可以完成自动注入。</p>
<p>BeanFactoryPostProcessor的主体是BeanFactory，并且该接口中只定义了一个方法，其将会在ApplicationContext内部的BeanFactory加载完bean的定义后，但是在对应的bean实例化之前进行回调。所以通常我们可以通过实现该接口来对实例化之前的bean定义进行修改。</p>
<p>BeanFactoryPostProcessor可以对bean的定义（<strong>配置元数据</strong>）进行处理。也就是说，<strong>Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其它的bean之前读取配置元数据，并有可能修改它</strong>。如果你愿意，你可以配置多个BeanFactoryPostProcessor。你还能通过设置’order’属性来控制BeanFactoryPostProcessor的<strong>执行次序</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是BeanFactoryPostProcessor接口的定义，其中只定义了一个方法。接下来我们来定义一个自己的BeanFactoryPostProcessor，用以输出当前bean容器中bean定义的基本信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">			ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">//获取所有的beanName</span></span><br><span class="line">		String beanNames[] = beanFactory.getBeanDefinitionNames();</span><br><span class="line">		<span class="keyword">if</span> (beanNames != <span class="literal">null</span> &amp;&amp; beanNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">				<span class="comment">//获取对应的bean定义</span></span><br><span class="line">				beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">				<span class="built_in">this</span>.printBeanDef(beanName, beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印bean定义的基本信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDef</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printBeanDef</span><span class="params">(String beanName, BeanDefinition beanDef)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">defStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;beanName: &quot;</span>).append(beanName);</span><br><span class="line">		defStr.append(<span class="string">&quot;, className: &quot;</span>).append(beanDef.getBeanClassName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, scope: &quot;</span>).append(beanDef.getScope());</span><br><span class="line">		defStr.append(<span class="string">&quot;, parent: &quot;</span>).append(beanDef.getParentName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryBean: &quot;</span>).append(beanDef.getFactoryBeanName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryMethod: &quot;</span>).append(beanDef.getFactoryMethodName());</span><br><span class="line">		System.out.println(defStr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<strong>BeanFactoryPostProcessor是针对于bean容器的</strong>，在调用它时，BeanFactory只加载了bean的定义，<strong>还没有对它们进行实例化</strong>，所以我们可以通过对BeanFactory的处理来达到影响之后实例化bean的效果。跟BeanPostProcessor一样，ApplicationContext也能自动检测和调用容器中的BeanFactoryPostProcessor。 </p>
<h2 id="BeanPostProcesser："><a href="#BeanPostProcesser：" class="headerlink" title="BeanPostProcesser："></a>BeanPostProcesser：</h2><p>BeanPostProcessor 可以在 spring 容器实例化 bean 之后，在执行 bean 的初始化方法前后，添加一些自己的处理逻辑。 这里说的初始化方法，指的是以下两种：</p>
<ol>
<li>bean 实现 了 InitializingBean 接口，对应的方法为 afterPropertiesSet 。</li>
<li>在 XML 文件中定义 bean 的时候，<bean>标签有个属性叫做 init-method，来指定初始化方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125; </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.    </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务  </span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125;   </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.       </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入、初始化完毕时执行  </span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个接口的某个实现类被注册到某个容器，<strong>那么该容器的每个受管Bean在调用初始化方法的前后，都会获得该接口实现类的一个回调</strong>。容器调用接口定义的方法时会将该受管Bean的实例和名字通过参数传入方法，经过处理后通过方法的返回值返回给容器。</p>
<p>要使用BeanPostProcessor回调，就必须先在容器中注册实现该接口的类，那么如何注册呢？BeanFactory和ApplicationContext容器的注册方式不大一样：</p>
<ul>
<li>若使用BeanFactory，则必须要显示的调用其addBeanPostProcessor()方法进行注册，参数为BeanPostProcessor实现类的实例；</li>
<li>如果是使用ApplicationContext，那么容器会在配置文件在中自动寻找实现了BeanPostProcessor接口的Bean，然后自动注册，我们要做的只是配置一个BeanPostProcessor实现类的Bean就可以了。</li>
</ul>
<p>假如我们使用了多个的BeanPostProcessor的实现类，那么如何确定处理顺序呢？其实只要实现Ordered接口，设置order属性就可以很轻松的确定不同实现类的处理顺序了。</p>
<h2 id="BeanFactoryPostProcessor和BeanPostProcessor"><a href="#BeanFactoryPostProcessor和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcessor和BeanPostProcessor"></a>BeanFactoryPostProcessor和BeanPostProcessor</h2><p>相同点：</p>
<p>1.BeanFactoryPostProcessor和BeanPostProcessor都是<strong>spring初始化bean的扩展点</strong>。两个接口非常相似。</p>
<p>2.二者都可以被ApplicationContext自动检测到。</p>
<p>不同点：</p>
<p><strong>BeanFactoryPostProcessor 作用于 bean 实例化之前，读取配置元数据，并且可以修改；而 BeanPostProcessor 作用于 bean 的实例化过程中，然后可以改变 bean 实例（例如从配置元数据创建的对象）。</strong></p>
<h2 id="执行的过程如下"><a href="#执行的过程如下" class="headerlink" title="执行的过程如下:"></a><strong>执行的过程如下:</strong></h2><p>1.ResouceLoader加载配置信息<br>2.解析配置信息，生成一个一个的BeanDefintion<br>3.BeanDefintion由BeanDefintionRegistry管理起来<br>4.BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)<br>5.实例化Bean<br>6.如果该Bean配置&#x2F;实现了InstantiationAwareBean，则调用对应的方法<br>7.使用BeanWarpper来完成对象之间的属性配置(依赖)<br>8.如果该Bean配置&#x2F;实现了Aware接口，则调用对应的方法<br>9.如果该Bean配置了BeanPostProcessor的before方法，则调用<br>10.如果该Bean配置了init-method或者实现InstantiationBean，则调用对应的方法<br>11.如果该Bean配置了BeanPostProcessor的after方法，则调用<br>12.将对象放入到HashMap中<br>13.最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</p>
<h1 id="Spring浅看"><a href="#Spring浅看" class="headerlink" title="Spring浅看"></a>Spring浅看</h1><img src="/2022/05/26/Spring/image-20220526175017424-16536637765225-16536638098216.png" class="" title="image-20220526175017424-16536637765225">

<img src="/2022/05/26/Spring/image-20220526174932412-16536638610858.png" class="" title="image-20220526174932412">

<img src="/2022/05/26/Spring/image-20220526175457607-16536638760849.png" class="" title="image-20220526175457607">

<p>bean注入与装配的的方式有很多种，可以通过xml，get, set方式，构造函数或者注解等。简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式，让项目阅读和开发起来更加方便。</p>
<img src="/2022/05/26/Spring/image-20220526175600355-165366388819310.png" class="" title="image-20220526175600355">

<img src="/2022/05/26/Spring/image-20220526175612242-165366391229911.png" class="" title="image-20220526175612242">

<p>它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。Spring框架的开发不是为了替代现有的优秀第三方框架，而是通过集成的方式把它们都连接起来。下面总结了一些常集成的优秀框架。</p>
<img src="/2022/05/26/Spring/image-20220526175650919-165366393348713.png" class="" title="image-20220526175650919">

<h1 id="SpringIOC-和-Spring-AOP"><a href="#SpringIOC-和-Spring-AOP" class="headerlink" title="SpringIOC 和 Spring AOP"></a>SpringIOC 和 Spring AOP</h1><p>作为Spring框架最核心的两个“功能” ，需要完全理解IOC和AOP，才能真正灵活正确的使用Spring框架 ，而Spring框架作为Spring全家桶系列的最基础的使用框架，它的最核心功能就是—拓展， 让这个框架的功能越来越丰富，在基石上创建最实用的功能。</p>
<p>spring的IoC容器是spring的核心，spring AOP是spring框架的重要组成部分。</p>
<h2 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h2><p>在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此被称作控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），<strong>依赖注入和控制反转是同一个概念。</strong></p>
<p>IOC:控制反转也叫依赖注入。利用了<strong>工厂模式</strong></p>
<p>将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p>
<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p>面向切面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使IoC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。</p>
<p>AOP:面向切面编程。（Aspect-Oriented Programming）<br><strong>AOP可以说是对OOP的补充和完善:</strong></p>
<p>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义<strong>从上到下</strong>的关系，但并不适合定义<strong>从左到右</strong>的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br><strong>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面</strong>，然后注入到目标对象（具体业务逻辑）中去。</p>
<p>&#x2F;&#x2F;TODO AOP的具体实现步骤 （ 帮助理解） </p>
<h2 id="Spring中beanFactory和ApplicationContext的联系和区别"><a href="#Spring中beanFactory和ApplicationContext的联系和区别" class="headerlink" title="Spring中beanFactory和ApplicationContext的联系和区别"></a><strong>Spring中beanFactory和ApplicationContext的联系和区别</strong></h2><p>声明二者之间的关系：</p>
<p>早期的电脑性能低，内存小，所以spring容器的容量不足，不能讲所以的对象全部创建好放入容器，所以使用的是BeanFactory，需要某个对象时，再进行创建，随着电脑硬件的发展，内存越来越大，所以spring框架引入了ApplicationContext，将所有的对象都创建好，放入容器，使用哪个对象，从容器中取得即可。</p>
<p><strong>一、 BeanFactory</strong></p>
<p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。也是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>
<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。</p>
<p>BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。来看一下BeanFactory的基本类体系结构（接口为主）：</p>
<img src="/2022/05/26/Spring/image-20220528103213112.png" class="" title="image-20220528103213112">

<p>1、BeanFactory作为一个主接口不继承任何接口，暂且称为<strong>一级接口</strong>。<br>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为<strong>二级接口</strong>。<br>3、ConfigurableBeanFactory可以被称为<strong>三级接口</strong>，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为<strong>四级接口</strong>。（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。</p>
<p>BeanFactory接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111158974.png" class="" title="image-20220528111158974">

<details> 
    <summary><font color=blue>点击查看BeanFactory接口源码</font></summary> 
    <pre><code>   
/**
 *The root interface for accessing a Spring bean container.
 * This is the basic client view of a bean container;
 * further interfaces such as &#123;@link ListableBeanFactory&#125; and
 * &#123;@link org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;
 * are available for specific purposes.
 *
 * This interface is implemented by objects that hold a number of bean definitions,
 * each uniquely identified by a String name. Depending on the bean definition,
 * the factory will return either an independent instance of a contained object
 * (the Prototype design pattern), or a single shared instance (a superior
 * alternative to the Singleton design pattern, in which the instance is a
 * singleton in the scope of the factory). Which type of instance will be returned
 * depends on the bean factory configuration: the API is the same. Since Spring
 * 2.0, further scopes are available depending on the concrete application
 * context (e.g. "request" and "session" scopes in a web environment).
 *
 * Bean factory implementations should support the standard bean lifecycle interfaces
 * as far as possible. The full set of initialization methods and their standard order is:
 * <ol>
 * <li>BeanNameAware's &#123;@code setBeanName&#125;
 * <li>BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;
 * <li>BeanFactoryAware's &#123;@code setBeanFactory&#125;
 * <li>EnvironmentAware's &#123;@code setEnvironment&#125;
 * <li>EmbeddedValueResolverAware's &#123;@code setEmbeddedValueResolver&#125;
 * <li>ResourceLoaderAware's &#123;@code setResourceLoader&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125;
 * (only applicable when running in an application context)
 * <li>MessageSourceAware's &#123;@code setMessageSource&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationContextAware's &#123;@code setApplicationContext&#125;
 * (only applicable when running in an application context)
 * <li>ServletContextAware's &#123;@code setServletContext&#125;
 * (only applicable when running in a web application context)
 * <li>&#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors
 * <li>InitializingBean's &#123;@code afterPropertiesSet&#125;
 * <li>a custom init-method definition
 * <li>&#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors
 * </ol>
 *
 * On shutdown of a bean factory, the following lifecycle methods apply:
 * <ol>
 * <li>&#123;@code postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors
 * <li>DisposableBean's &#123;@code destroy&#125;
 * <li>a custom destroy-method definition
 * </ol>
 */
public interface BeanFactory &#123;
   /**
    * Used to dereference a &#123;@link FactoryBean&#125; instance and distinguish it from
        * beans <i>created</i> by the FactoryBean. For example, if the bean named
        * &#123;@code myJndiObject&#125; is a FactoryBean, getting &#123;@code &myJndiObject&#125;
        * will return the factory, not the instance returned by the factory.
        */
      String FACTORY_BEAN_PREFIX = "&";
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
        * This method allows a Spring BeanFactory to be used as a replacement for the
        * Singleton or Prototype design pattern. Callers may retain references to
        * returned objects in the case of Singleton beans.
        * Translates aliases back to the corresponding canonical bean name.
        * Will ask the parent factory if the bean cannot be found in this factory instance.
        * @param name the name of the bean to retrieve
        * @return an instance of the bean
        * @throws NoSuchBeanDefinitionException if there is no bean definition
        * with the specified name
        * @throws BeansException if the bean could not be obtained
        */
      Object getBean(String name) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Behaves the same as &#123;@link #getBean(String)&#125;, but provides a measure of type
    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the
    * required type. This means that ClassCastException can't be thrown on casting
    * the result correctly, as can happen with &#123;@link #getBean(String)&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to retrieve
    * @param requiredType type the bean must match. Can be an interface or superclass
    * of the actual class, or &#123;@code null&#125; for any match. For example, if the value
    * is &#123;@code Object.class&#125;, this method will succeed whatever the class of the
    * returned instance.
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanNotOfRequiredTypeException if the bean is not of the required type
    * @throws BeansException if the bean could not be created
    */
   <T> T getBean(String name, Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * @param name the name of the bean to retrieve
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 2.5
    */
   Object getBean(String name, Object... args) throws BeansException;
   /**
    * Return the bean instance that uniquely matches the given object type, if any.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @return an instance of the single bean matching the required type
    * @throws NoSuchBeanDefinitionException if no bean of the given type was found
    * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
    * @throws BeansException if the bean could not be created
    * @since 3.0
    * @see ListableBeanFactory
    */
   <T> T getBean(Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 4.1
    */
   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
   /**
    * Does this bean factory contain a bean definition or externally registered singleton
    * instance with the given name?
    * If the given name is an alias, it will be translated back to the corresponding
    * canonical bean name.
    * If this factory is hierarchical, will ask any parent factory if the bean cannot
    * be found in this factory instance.
    * If a bean definition or singleton instance matching the given name is found,
    * this method will return &#123;@code true&#125; whether the named bean definition is concrete
    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;@code true&#125;
    * return value from this method does not necessarily indicate that &#123;@link #getBean&#125;
    * will be able to obtain an instance for the same name.
    * @param name the name of the bean to query
    * @return whether a bean with the given name is present
    */
   boolean containsBean(String name);
   /**
    * Is this bean a shared singleton? That is, will &#123;@link #getBean&#125; always
    * return the same instance?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * independent instances. It indicates non-singleton instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isPrototype&#125; operation to explicitly
    * check for independent instances.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean corresponds to a singleton instance
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @see #getBean
    * @see #isPrototype
    */
   boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
   /**
    * Is this bean a prototype? That is, will &#123;@link #getBean&#125; always return
    * independent instances?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * a singleton object. It indicates non-independent instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isSingleton&#125; operation to explicitly
    * check for a shared singleton instance.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean will always deliver independent instances
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.3
    * @see #getBean
    * @see #isSingleton
    */
   boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code ResolvableType&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 4.2
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code Class&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.1
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Determine the type of the bean with the given name. More specifically,
    * determine the type of object that &#123;@link #getBean&#125; would return for the given name.
    * For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates,
    * as exposed by &#123;@link FactoryBean#getObjectType()&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return the type of the bean, or &#123;@code null&#125; if not determinable
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 1.1.2
    * @see #getBean
    * @see #isTypeMatch
    */
   Class<?> getType(String name) throws NoSuchBeanDefinitionException;
   /**
    * Return the aliases for the given bean name, if any.
    * All of those aliases point to the same bean when used in a &#123;@link #getBean&#125; call.
    * If the given name is an alias, the corresponding original bean name
    * and other aliases (if any) will be returned, with the original bean name
    * being the first element in the array.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the bean name to check for aliases
    * @return the aliases, or an empty array if none
    * @see #getBean
    */
   String[] getAliases(String name);
&#125;
    </code></pre> 
</details>

<p>总结：</p>
<p>1、4个获取实例的方法。getBean的重载方法。<br>2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>3、1个获取类型的方法、1个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<p>BeanFactory最常见的实现类为XmlBeanFactory，可以从classpath或文件系统等获取资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;classpath.xml&quot;</span>); </span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>



<p><strong>二、 ApplicationContext</strong></p>
<p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</p>
<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>
<p>（1）MessageSource, 提供国际化的消息访问<br>（2）资源访问，如URL和文件<br>（3）事件传播特性，即支持aop特性<br>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </p>
<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。</p>
<p><strong>ApplicationContext的继承关系图:</strong></p>
<img src="/2022/05/26/Spring/70.png" class="" title="img">

<p>ApplicationContext接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111124796.png" class="" title="image-20220528111124796">

<details> 
    <summary>
        <font color=blue>点击查看ApplicationContext源码</font>
    </summary> 
    <pre><code>  
 /**
 * Central interface to provide configuration for an application.
 * This is read-only while the application is running, but may be
 * reloaded if the implementation supports this.
 *
 *  An ApplicationContext provides:
 * <ul>
 * <li>Bean factory methods for accessing application components.
 * Inherited from &#123;@link org.springframework.beans.factory.ListableBeanFactory&#125;.
 * <li>The ability to load file resources in a generic fashion.
 * Inherited from the &#123;@link org.springframework.core.io.ResourceLoader&#125; interface.
 * <li>The ability to publish events to registered listeners.
 * Inherited from the &#123;@link ApplicationEventPublisher&#125; interface.
 * <li>The ability to resolve messages, supporting internationalization.
 * Inherited from the &#123;@link MessageSource&#125; interface.
 * <li>Inheritance from a parent context. Definitions in a descendant context
 * will always take priority. This means, for example, that a single parent
 * context can be used by an entire web application, while each servlet has
 * its own child context that is independent of that of any other servlet.
 * </ul>
 *
 *  In addition to standard &#123;@link org.springframework.beans.factory.BeanFactory&#125;
 * lifecycle capabilities, ApplicationContext implementations detect and invoke
 * &#123;@link ApplicationContextAware&#125; beans as well as &#123;@link ResourceLoaderAware&#125;,
 * &#123;@link ApplicationEventPublisherAware&#125; and &#123;@link MessageSourceAware&#125; beans.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see ConfigurableApplicationContext
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.core.io.ResourceLoader
 */
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;
/**
     * Return the unique id of this application context.
     * @return the unique id of the context, or &#123;@code null&#125; if none
     */
    String getId();
    /**
     * Return a name for the deployed application that this context belongs to.
     * @return a name for the deployed application, or the empty String by default
     */
    String getApplicationName();
    /**
     * Return a friendly name for this context.
     * @return a display name for this context (never &#123;@code null&#125;)
     */
    String getDisplayName();
    /**
     * Return the timestamp when this context was first loaded.
     * @return the timestamp (ms) when this context was first loaded
     */
    long getStartupDate();
    /**
     * Return the parent context, or &#123;@code null&#125; if there is no parent
     * and this is the root of the context hierarchy.
     * @return the parent context, or &#123;@code null&#125; if there is no parent
     */
    ApplicationContext getParent();
    /**
     * Expose AutowireCapableBeanFactory functionality for this context.
     *  This is not typically used by application code, except for the purpose of
     * initializing bean instances that live outside of the application context,
     * applying the Spring bean lifecycle (fully or partly) to them.
     *  Alternatively, the internal BeanFactory exposed by the
     * &#123;@link ConfigurableApplicationContext&#125; interface offers access to the
     * &#123;@link AutowireCapableBeanFactory&#125; interface too. The present method mainly
     * serves as a convenient, specific facility on the ApplicationContext interface.
     *  <b>NOTE: As of 4.2, this method will consistently throw IllegalStateException
     * after the application context has been closed.</b> In current Spring Framework
     * versions, only refreshable application contexts behave that way; as of 4.2,
     * all application context implementations will be required to comply.
     * @return the AutowireCapableBeanFactory for this context
     * @throws IllegalStateException if the context does not support the
     * &#123;@link AutowireCapableBeanFactory&#125; interface, or does not hold an
     * autowire-capable bean factory yet (e.g. if &#123;@code refresh()&#125; has
     * never been called), or if the context has been closed already
     * @see ConfigurableApplicationContext#refresh()
     * @see ConfigurableApplicationContext#getBeanFactory()
     */
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
&#125;
    </code></pre> 
</details>

<p><strong>三、二者区别</strong></p>
<p>不同点：Bean的加载时机</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身时检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。<br>应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相同点：</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）</p>
<h2 id="Spring用到的设计模式"><a href="#Spring用到的设计模式" class="headerlink" title="Spring用到的设计模式"></a>Spring用到的设计模式</h2><p>Spring作为一款及其优秀的框架，其代码的编写非常优秀，里面采用了大量的设计模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 这两个接口 来创建 bean 对象。<br>两者对比：</p>
<ul>
<li><p>BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li><p>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 由 BeanFactory 派生而来 ，提供了更多面向实际应用的功能 ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</p>
</li>
</ul>
<h5 id="设置延迟加载的方式："><a href="#设置延迟加载的方式：" class="headerlink" title="设置延迟加载的方式："></a>设置延迟加载的方式：</h5><p>方式1：对单个Bean对象进行延迟加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例如连接池的延时加载设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  通过数据库连接池给我们提供的init方法和 close方法进行设置 指定初始化（类似构造器）到销毁的具体方法。</span><br></pre></td></tr></table></figure>
<p>方式2：对Bean标签集中的所有bean对象都进行延迟加载设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h5 id="Bean对象的作用域"><a href="#Bean对象的作用域" class="headerlink" title="Bean对象的作用域"></a>Bean对象的作用域</h5><p>Spring中bean对象的默认作用域就是singleton ，创建以后一直存在，除了singleton的作用域，还有其他的作用域。</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在Spring ioc 容器中仅存在一个Bean实例，Bean以单例方式存在，默认值</td>
</tr>
<tr>
<td>prototype</td>
<td>每次请求都会创建一个新的 bean 实例。</td>
</tr>
<tr>
<td>request</td>
<td>每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</td>
</tr>
<tr>
<td>session</td>
<td>每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</td>
</tr>
<tr>
<td>globalSession</td>
<td>用于分布式web开发中，创建的实例绑定全局session对象</td>
</tr>
</tbody></table>
<p>对于<strong>prototype作用域的bean对象</strong>：</p>
<p>作用域为 prototype 的 bean ，其destroy方法并没有被调用。如果 bean 的 scope 设为prototype时，<strong>当容器关闭时，destroy 方法不会被调用</strong>。对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring不能对一个 prototype bean 的整个生命周期负责：<strong>容器在初&#x2F;始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。</strong> 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。<strong>清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责</strong>（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。<br>谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由<strong>客户端</strong>来处理。<br>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，<strong>Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<p>​											<strong>（Spring容器对prototype作用域的bean对象 ——只管生，不管养）</strong></p>
<p>Spring通过<strong>ConcurrentHashMap</strong>实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;  </span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例    </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。  </span></span><br><span class="line">                addSingleton(beanName, singletonObject);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将对象添加到单例注册表  </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Spring的注册表</p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Spring中策略模式的应用</p>
<p>当bean需要访问资源配置文件时，Spring有两种方式</p>
<p>1.代码中获取Rescource实例<br>2.依赖注入<br>第一种方式需要获取rescource资源的位置，代码中耦合性太高，而今我们一直使用注解，依赖注入的方式去获取。这样的话就无需修改程序，只改配置文件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Test&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- 注入资源 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tmp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:book.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>在依赖注入的过程中，<strong>Spring会调用ApplicationContext 来获取Resource的实例</strong>。然而，Resource 接口封装了各种可能的资源类型，包括了：UrlResource，ClassPathResource，FileSystemResource等，Spring需要针对不同的资源采取不同的访问策略。在这里，Spring让ApplicationContext成为了资源访问策略的“决策者”。<strong>在资源访问策略的选择上，Spring采用了策略模式。</strong>当 Spring 应用需要进行资源访问时，它并不需要直接使用 Resource 实现类，而是<strong>调用 ApplicationContext 实例的 getResource() 方法来获得资源。ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略</strong>，从而将应用程序和具体的资源访问策略分离开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> PathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;book.xml&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>上面的代码中，Spring 将采用和 ApplicationContext 相同的策略来访问资源。即： ApplicationContext 是ClassPathXmlApplicationContext，则res 就是 ClassPathResource 实例。若将代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>通过使用修饰模式，可以在运行时扩充一个类的功能。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//根据指定的bean使用对应的侧脸创建新的实例，如工厂方法，构造函数自动注入，简单初始化</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。如下图所示：</p>
<img src="/2022/05/26/Spring/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220805154104.jpg" class="" title="微信图片_20220805154104">

<p>当然你也可以使用AspectJ，Spring AOP已经继承了AspectJ,AspectJ应该算的上是java生态系统中最完整的AOP框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。<br>动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。</p>
<p><strong>jdk动态代理，必须有接口，目标类必须实现jdk动态代理的接口， 没有接口时，需要使用<a href="https://so.csdn.net/so/search?q=cglib&spm=1001.2101.3001.7020">cglib</a>动态代理。</strong></p>
<p><strong>动态代理能做什么？</strong></p>
<p>可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。</p>
<p>举例：</p>
<p>在开发中也会有这样的情况， 你有a类， 本来是调用c类的方法， 完成某个功能。 但是c不让a调用。</p>
<p>a —–不能调用 c的方法。<br>在a 和 c 直接 创建一个 b 代理， c让b访问。<br>a –访问b—访问c</p>
<p>实际的例子： 登录，注册有验证码， 验证码是手机短信。<br>中国移动， 联通能发短信。<br>中国移动， 联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能<br>张三项目发送短信—-子公司，或者关联公司—–中国移动， 联通</p>
<p><strong>使用代理模式的作用</strong></p>
<ol>
<li>功能增强： 在你原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强。</li>
<li>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。</li>
</ol>
<p><strong>实现代理的方式：</strong></p>
<ol>
<li><p>静态代理</p>
<p>代理类是自己手工实现的，自己创建一个java类，表示代理类。<br>同时你所要代理的目标类是确定的。</p>
<p>特点：</p>
<p>1）实现简单 2）容易理解。<br>缺点：当你的项目中，目标类和代理类很多时候，有以下的缺点<br>1）当目标类增加了， 代理类可能也需要成倍的增加。 代理类数量过多。<br>2）当你的接口中功能增加了， 或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。jdk动态代理实现</p>
</li>
<li><p>动态代理</p>
<p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。<br>1）代理类数量可以很少，<br>2）当你修改了接口中的方法时，不会影响代理类。</p>
<p>动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理类对象， 并动态的指定要代理目标类。换句话说， 动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。</p>
<hr>
<p>在java中，要想创建对象：</p>
<p>创建类文件， java文件编译为class<br>使用构造方法，创建类的对象。</p>
<hr>
<p>而<strong>动态代理的实现</strong>：<br>反射包 java.lang.reflect , 包含 一个接口 ： InvocationHandler </p>
<p>​													 两个类	： Method, Proxy</p>
<p>(1)InvocationHandler 接口（调用处理器）：</p>
<p>只有一个方法invoke（）：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>(2) Method类：表示方法的， 确切的说就是目标类中的方法。</p>
<p>作用：通过Method可以执行某个目标类的方法，Method.invoke();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(目标对象，方法的参数)</span><br><span class="line"><span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(service2, “李四”);</span><br><span class="line"><span class="comment">// method.invoke（）就是用来执行目标方法的，等同于静态代理中的</span></span><br><span class="line"><span class="comment">//向厂家发送订单，告诉厂家，我买了u盘，厂家发货</span></span><br><span class="line"><span class="comment">//float price = factory.sell(amount); //厂家的价格。</span></span><br></pre></td></tr></table></figure>

<p>(3) Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法(),现在我们是使用Proxy类的方法，代替new的使用。</p>
<p>方法： 静态方法 newProxyInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                         Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                         InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>作用： 创建代理对象， 等同于静态代理中的TaoBao taoBao &#x3D; new TaoBao();<br>参数：<br>ClassLoader loader 类加载器，负责向内存中加载对象的。 使用反射获取对象的ClassLoader类a , a.getCalss().getClassLoader(), 目标对象的类加载器<br>Class&lt;?&gt;[] interfaces： 接口， 目标对象实现的接口，也是反射获取的。<br>InvocationHandler h : 我们自己写的，代理类执行invoke()方法，实现要完成的功能。</p>
<p>这样我们就完成了JDK的动态代理流程。</p>
</li>
</ol>
<h4 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h4><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p>
<p>cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。</p>
<p>CGLIB的核心类：<br>    net.sf.cglib.proxy.Enhancer – 主要的增强类<br>    net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>    net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>    Object o &#x3D; methodProxy.invokeSuper(proxy, args);&#x2F;&#x2F;虽然第一个参数是被代理对象，也不会出现死循环的问题。</p>
<p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, java.lang.reflect.Method method,Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(cglibProxy);</span><br><span class="line"> </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">o</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">        o.getName(<span class="number">1</span>);</span><br><span class="line">        o.getAge(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>++++++before CGLIB$getName$0++++++<br>getName<br>——getName——<br>++++++before CGLIB$getName$0++++++<br>++++++before CGLIB$getAge$1++++++<br>getAge<br>——getAge——</p>
<p>++++++before CGLIB$getAge$1++++++</p>
<h4 id="Spring-AOP和AspectJ-AOP有什么区别？"><a href="#Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别？"></a>Spring AOP和AspectJ AOP有什么区别？</h4><p>Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作。</p>
<p>Spring AOP已经集成了AspectJ，AsectJ应该算的上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单，如果我们的切面比较少，那么两者的性能差异不大。但是当切面太多的话，最好选择AspectJ，它比Spring AOP快很多。</p>
<p><a href="https://blog.csdn.net/u012285269/article/details/122022182?spm=1001.2101.3001.6650.16&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&utm_relevant_index=18">(20条消息) 关于Jdk的Proxy与CGLib的理解_臧馆长的博客-CSDN博客_jdk proxy 和cglib</a></p>
<p><a href="https://www.cnblogs.com/resentment/p/5742661.html">CGLib与JDKProxy的区别 - resentment - 博客园 (cnblogs.com)</a></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变一个算法的结构即可重定义该算法的默写特定步骤的实现方式。</p>
<p>还有很多设计模式 就不详细写了 下面解析源码的时候将设计模式和spring的加载流程串联到一起。</p>
<h1 id="Bean对象的生命周期"><a href="#Bean对象的生命周期" class="headerlink" title="Bean对象的生命周期"></a>Bean对象的生命周期</h1><p>上面我们已经提到过Bean对象的作用域了，现在我们谈一谈Bean对象从被创建到消亡的过程。（就像一个人的一生一样，更应该着重看人的一生的意义，而不是出生和死亡。）</p>
<p>该位置也是从进入容器开始实例化 到bean对象被销毁的对应位置：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI0NjUxOA==,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p>再通过调用的方法名来进行区域的划分：</p>
<img src="/2022/05/26/Spring/bean%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16537349916045.png" class="" title="bean对象生命周期">

<p>主要分为四大阶段：</p>
<ul>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ul>
<p><strong>生命周期执行的过程如下:</strong></p>
<ol>
<li>spring对bean进行实例化,默认bean是单例<strong>singleton</strong>作用域</li>
<li>spring对bean进行依赖注入</li>
<li>如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来</li>
<li>如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入</li>
<li>如果bean实现了<strong>BeanPostProcessor</strong>接口,spring将调用它们的<strong>postProcessBeforeInitialization</strong>接口方法</li>
<li>如果bean实现了<strong>InitializingBean</strong>接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了<strong>init-method属性声明了初始化方法</strong>,该方法也会被调用</li>
<li>如果bean实现了<strong>BeanPostProcessor</strong>接口,spring将调用它们的<strong>postProcessAfterInitialization</strong>接口方法</li>
<li>此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁</li>
<li>若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用</li>
</ol>
<p><strong>关于initializingbean</strong></p>
<p><a href="https://juejin.cn/post/6964604073223913509">Spring InitializingBean 接口都不知道，源码你还是缓缓吧… - 掘金 (juejin.cn)</a></p>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>  该接口作用是<strong>在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑</strong>。注意是Bean实例化完毕后及依赖注入完成后触发的。接口的源码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public interface <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="title class_">Object</span> <span class="title function_">postProcessBeforeInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">postProcessBeforeInitialization</td>
<td align="left">实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务</td>
</tr>
<tr>
<td align="left">postProcessAfterInitialization</td>
<td align="left">实例化、依赖注入、初始化完毕时执行</td>
</tr>
</tbody></table>
<p>既分为前置处理和后置处理的方法。</p>
<h3 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h3><p>spring依赖注入有三种方式</p>
<ol>
<li>set注入</li>
<li>构造器注入</li>
<li>注解@Autoware @Resource</li>
</ol>
<h1 id="Spring的Bean的安全问题"><a href="#Spring的Bean的安全问题" class="headerlink" title="Spring的Bean的安全问题"></a>Spring的Bean的安全问题</h1><p>因为Spring中的Bean默认是单例的，所以在定义成员变量时也有可能会发生线程安全问题</p>
<p>单例的bean 多线程共享，存在资源竞争。如果单例bean 只关注于方法，不会对Bean的成员执行查询以外的操作，这个bean是线程安全的。 重点在于有无对bean 属性的查询以外操作。</p>
<p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>
<p>原型Bean<br>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>
<p>单例Bean<br>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p>
<p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<p>对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。</p>
<h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><h2 id="Spring事务分类"><a href="#Spring事务分类" class="headerlink" title="Spring事务分类"></a>Spring事务分类</h2><p><strong>编程式事务</strong>:允许用户在实现代码中使用显式的方式调用beginTransaction()开启事务、commit()提交事务、rollback()回滚事务，从而可以达到精确定义事务的边界。</p>
<p><strong>声明式事务管理</strong>:底层是建立在Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。声明式事务的最大优点就是不需要编程，将事务管理从复杂业务逻辑中抽离，只需要在配置文件中配置并在目标方法上添加 <strong>@Transactional</strong> 注解即可实现。</p>
<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是<strong>DataSource</strong>、<strong>TransactionManager</strong>和<strong>代理机制</strong>这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager,关系图如下</p>
<img src="/2022/05/26/Spring/webp.webp" class="" title="img">

<h2 id="Spring事务的传播属性"><a href="#Spring事务的传播属性" class="headerlink" title="Spring事务的传播属性"></a>Spring事务的传播属性</h2><ol>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRED)</strong></p>
<p>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)</strong></p>
<p>容器不为这个方法开启事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)</strong></p>
<p>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行旧的事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.MANDATORY)</strong></p>
<p>必须在一个已有的事务中执行,否则抛出异常</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NEVER)</strong></p>
<p>必须在一个没有的事务执行,否则抛出异常(与Propagation.MANDATORY相反)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.SUPPORTS)</strong></p>
<p>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他  bean没有声明事务,那就不用事务.</p>
</li>
</ol>
<h2 id="Spring事务注意事项"><a href="#Spring事务注意事项" class="headerlink" title="Spring事务注意事项"></a>Spring事务注意事项</h2><ol>
<li>在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。</li>
<li>@Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</li>
<li>注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。</li>
<li>通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。</li>
<li>Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</li>
<li>@Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。<ins>所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</ins></li>
</ol>
<h2 id="Spring事务超时时间"><a href="#Spring事务超时时间" class="headerlink" title="Spring事务超时时间"></a>Spring事务超时时间</h2><ol>
<li>TransactionDefinition 接口中定义了1个表示超时时间的常量**TIMEOUT_DEFAULT **，使用getTimeout()方法可以获取到超时时间，单位是秒。Spring事务超时时间，是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在Spring程序中超时时间设置的注解方式是设置timeout的值表示这个事务，true只读取数据但不更新数据，false表示可正常读写数据</li>
<li><strong>@Transactional(timeout&#x3D;30)</strong> 默认是-1，不超时</li>
</ol>
<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h2 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h2><img src="/2022/05/26/Spring/format,png-16599262367702.png" class="" title="format,png">

<p>循环依赖其实就是多个类（或一个类）互相拥有彼此的属性，bean加载的时候不能怎么解决如何加载他们。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A中注入了B</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// B中也注入了A</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-什么情况下循环依赖可以被处理？"><a href="#2-什么情况下循环依赖可以被处理？" class="headerlink" title="2. 什么情况下循环依赖可以被处理？"></a>2. 什么情况下循环依赖可以被处理？</h2><p>Spring解决循环依赖是有前置条件的</p>
<ol>
<li>出现循环依赖的Bean必须要是单例</li>
<li>依赖注入的方式不能全是构造器注入的方式</li>
</ol>
<p><strong>因为加入singletonFactories三级缓存的前提是执行了构造器来创建半成品的对象，所以构造器的循环依赖没法解决</strong></p>
<h2 id="3-Spring是如何解决的循环依赖？"><a href="#3-Spring是如何解决的循环依赖？" class="headerlink" title="3. Spring是如何解决的循环依赖？"></a>3. Spring是如何解决的循环依赖？</h2><p>关于循环依赖的解决方式应该要分两种情况来讨论</p>
<ol>
<li>简单的循环依赖（没有AOP）</li>
<li>结合了AOP的循环依赖</li>
</ol>
<h3 id="使用Spring的缓存"><a href="#使用Spring的缓存" class="headerlink" title="使用Spring的缓存"></a>使用Spring的缓存</h3><p>首先我们要先了解一下spring 的缓存都是什么。</p>
<p>一级缓存为单例池（<code>singletonObjects</code>）,一级缓存中存储的是已经完全创建好了的单例Bean。</p>
<p>二级缓存为早期曝光对象<code>earlySingletonObjects</code>，</p>
<p>三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6X3NtYWxscmVk,size_16,color_FFFFFF,t_70#pic_center-16599262007251-16614820779222.jpeg" class="" title="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6X3NtYWxscmVk,size_16,color_FFFFFF,t_70">

<h3 id="Spring解决循环依赖的大致流程："><a href="#Spring解决循环依赖的大致流程：" class="headerlink" title="Spring解决循环依赖的大致流程："></a>Spring解决循环依赖的大致流程：</h3><p>这里我们假设一个场景进行讲解：ServiceA、ServiceB相互依赖。</p>
<p>Spring容器依次创建两个bean时，发现在缓存中没有ServiceA，因此将新创建好的未注入属性的ServiceA放到三级缓存中去。<br>然后ServiceA进行属性注入时，发现依赖ServiceB，转而去实例化B。<br>同样创建对象ServiceB，注入属性时发现依赖ServiceA，依次从一级到三级缓存查询ServiceA，从三级缓存通过对象工厂拿到ServiceA，把ServiceA放入二级缓存，同时删除三级缓存中的ServiceA，此时，ServiceB已经实例化并且初始化完成，把ServiceB放入一级缓存。<br>接着继续创建ServiceA，顺利从一级缓存拿到实例化且初始化完成的ServiceB对象，ServiceA对象创建也完成，删除二级缓存中的ServiceA，同时把ServiceA放入一级缓存<br>最后，一级缓存中保存着实例化、初始化都完成的ServiceA、ServiceB对象</p>
<h3 id="不结合AOP的Bean加载流程："><a href="#不结合AOP的Bean加载流程：" class="headerlink" title="不结合AOP的Bean加载流程："></a>不结合AOP的Bean加载流程：</h3><p>我们应该知道，Spring在创建Bean的过程中分为三步：</p>
<ol>
<li>实例化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>中的<code>createBeanInstance</code>方法</li>
<li>属性注入，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法</li>
<li>初始化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code></li>
</ol>
<p>我们对于getSingleton(beanName,true)的boolean变量设置为false，这样bean就不会添加到三级缓存中了。</p>
<img src="/2022/05/26/Spring/format,png-16594342853715.png" class="" title="image-20200706092738559">

<p>实际上我们要将这个bean的单例对象 放入到单例池中（singletonFactory）。<strong>也就是说如果在不考虑<code>AOP</code>的情况下，上面的代码等价于：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也就是说这个工厂啥都没干，直接将实例化阶段创建的对象返回了！所以说在不考虑<code>AOP</code>的情况下三级缓存有用嘛？讲道理，真的没什么用</strong>，我直接将这个对象放到二级缓存中不是一点问题都没有吗？</p>
<p>所以不使用AOP的时候，也不会存在三级缓存。</p>
<img src="/2022/05/26/Spring/format,png-16594339917133.png" class="" title="image-20200706133018669">

<h3 id="使用AOP的Bean加载流程："><a href="#使用AOP的Bean加载流程：" class="headerlink" title="使用AOP的Bean加载流程："></a>使用AOP的Bean加载流程：</h3><img src="/2022/05/26/Spring/format,png-16594344712637.png" class="" title="image-20200706161709829">

<ol>
<li>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</li>
</ol>
<p>答：不会，这是因为不管是<code>cglib</code>代理还是<code>jdk</code>动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p>
<ol start="2">
<li>在给B注入的时候为什么要注入一个代理对象？</li>
</ol>
<p>答：当我们对A进行了<code>AOP</code>代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p>
<ol start="3">
<li>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</li>
</ol>
<p>答：<strong>这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</strong></p>
<h2 id="为什么要使用三级缓存？二级缓存不可以吗？"><a href="#为什么要使用三级缓存？二级缓存不可以吗？" class="headerlink" title="为什么要使用三级缓存？二级缓存不可以吗？"></a>为什么要使用三级缓存？二级缓存不可以吗？</h2><p>不可以，主要是为了生成代理对象。如果使用二级缓存，<strong>会导致被暴露出去的和最终的bean不是同一个bean。</strong></p>
<p><strong>三级缓存可以验证早期暴露的bean被其他bean使用过，并且用来判断被使用的和最终暴露的不一致的问题，二级缓存做不到。二级缓存无法判断早期bean是否被使用过，早期bean若没被使用过就无需判断早期暴露的bean和最终bean是否一致的问题。</strong></p>
<h2 id="循环依赖无法解决的情况"><a href="#循环依赖无法解决的情况" class="headerlink" title="循环依赖无法解决的情况"></a>循环依赖无法解决的情况</h2><p>只有<strong>单例的bean</strong>会通过三级缓存提前暴露来解决循环依赖的问题，而<strong>非单例的bean</strong>，每次从容器中获取都是一个新的对象，都会重新创建，所以<strong>非单例的bean是没有缓存的</strong>，不会将其放到三级缓存中。</p>
<h1 id="Spring中反射的应用"><a href="#Spring中反射的应用" class="headerlink" title="Spring中反射的应用"></a>Spring中反射的应用</h1><h1 id="Spring-连环问："><a href="#Spring-连环问：" class="headerlink" title="Spring 连环问："></a>Spring 连环问：</h1><h2 id="Autoware和-Resource的区别"><a href="#Autoware和-Resource的区别" class="headerlink" title="@Autoware和@Resource的区别"></a>@Autoware和@Resource的区别</h2><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p>
<ol>
<li><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为**<code>byType</code><strong>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</strong>当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了**，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 **<code>byName</code>**（根据名称进行匹配），这个名称通常就是类名（首字母小写）。（先用类型进行匹配bytype，然后根据名字匹配byname)</p>
</li>
<li><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的实现类的话，注入方式会变为<code>byType</code>。</p>
</li>
</ol>
<p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p>
<p>巨人的肩膀：</p>
<p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/5846416.html">Spring系列之beanFactory与ApplicationContext - 平凡希 - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/9a5acbf54b91">Spring-事务机制 - 简书 (jianshu.com)</a></p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_38246518/article/details/106131083">https://blog.csdn.net/weixin_38246518/article/details/106131083</a></p>
<p>原文链接：<a href="https://blog.csdn.net/chao821/article/details/92400186">https://blog.csdn.net/chao821/article/details/92400186</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/139f813fca80">Spring源码(七)-IOC中的那些设计模式 - 简书 (jianshu.com)</a></p>
<p><a href="https://www.cnblogs.com/duanxz/p/3750725.html">spring扩展点之一：BeanFactoryPostProcessor和BeanPostProcessor - duanxz - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_43973404/article/details/113094312">https://blog.csdn.net/weixin_43973404/article/details/113094312</a></p>
<p><a href="https://blog.csdn.net/heyutao007/article/details/49738887">(36条消息) Java动态代理的两种实现方法_和大黄的博客-CSDN博客_java动态代理的两种方式</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1409315#:~:text=BeanPost,ean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E5%90%8E">Spring之BeanPostProcessor(后置处理器)介绍 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>循环依赖和三级缓存：</p>
<p>原文链接：<a href="https://blog.csdn.net/zz_smallred/article/details/119698804">https://blog.csdn.net/zz_smallred/article/details/119698804</a> </p>
<p><a href="https://www.cnblogs.com/daimzh/p/13256413.html">面试必杀技，讲一讲Spring中的循环依赖 - 程序员DMZ - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/05/28/SpringBoot/</url>
    <content><![CDATA[<p>官网：<a href="https://spring.io/projects/spring-boot">Spring Boot</a></p>
<img src="/2022/05/28/SpringBoot/v2-704d04346a5e35b9bd3a4923732a589d_180x120.jpg" class="" title="查看源图像">

<h1 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h1><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<p>Spring Boot 集成了大量常用的第三方库配置，Spring Boot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p>
<span id="more"></span>

<h1 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h1><p>Spring Boot 项目创建完成后，即使不进行任何的配置，也能够顺利地运行，这都要归功于 Spring Boot 的自动化配置。</p>
<p>Spring Boot 默认使用 application.properties 或 application.yml 作为其全局配置文件，我们可以在该配置文件中对各种自动配置属性（server.port、logging.level.* 、spring.config.active.no-profile 等等）进行修改，并使之生效，那么您有没有想过这些属性是否有据可依呢？答案是肯定的。</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#application-properties">Spring Boot 官方文档：常见应用属性</a>中对所有的配置属性都进行了列举和解释，我们可以根据官方文档对 Spring Boot 进行配置，但 Spring Boot 中的配置属性数量庞大，仅仅依靠官方文档进行配置也十分麻烦。我们只有了解了 Spring Boot 自动配置的原理，才能更加轻松熟练地对 Spirng Boot 进行配置。</p>
<h2 id="Spring-Factories-机制"><a href="#Spring-Factories-机制" class="headerlink" title="Spring Factories 机制"></a>Spring Factories 机制</h2><p>Spring Boot 的自动配置是基于 Spring Factories 机制实现的。</p>
<p>Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。</p>
<p><a href="https://www.jianshu.com/p/00e49c607fa1">Spring Factories - 简书 (jianshu.com)</a></p>
<h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key&#x3D;vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Factories-实现原理"><a href="#Spring-Factories-实现原理" class="headerlink" title="Spring Factories 实现原理"></a>Spring Factories 实现原理</h3><p>spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF&#x2F;spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><T> List<T></td>
<td>loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)</td>
<td>静态方法； 根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。</td>
</tr>
<tr>
<td>List<String></td>
<td>loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</td>
<td>公共静态方法； 根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表</td>
</tr>
</tbody></table>
<p>以上两个方法的关键都是从指定的 ClassLoader 中获取 spring.factories 文件，并解析得到类名列表。</p>
<p>loadFactories() 方法能够获取指定接口的实现类对象</p>
<p>loadFactoryNames() 方法能够根据接口获取其实现类类名的集合。</p>
<h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h3><p>所有 Spring Boot 项目的主启动程序类上都使用了一个 @SpringBootApplication 注解，该注解是 Spring Boot 中最重要的注解之一 ，也是 Spring Boot 实现自动化配置的关键。 </p>
<p>@SpringBootApplication 是一个组合元注解，其主要包含两个注解：@SpringBootConfiguration 和 @EnableAutoConfiguration，其中 @EnableAutoConfiguration 注解是 SpringBoot 自动化配置的核心所在。</p>
<img src="/2022/05/28/SpringBoot/image-20220529152015019.png" class="" title="image-20220529152015019">

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@<strong>ComponentScan</strong></h3><p>@ComponentScan主要就是定义<strong>扫描的路径</strong>从中找出标识了<strong>需要装配</strong>的类自动装配到spring的bean容器中</p>
<p>@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个<strong>共同的注解@Component</strong></p>
<img src="/2022/05/28/SpringBoot/image-20220529153202827.png" class="" title="image-20220529153202827">



<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>@ConfigurationProperties 注解的作用，是将这个类的所有属性与配置文件中相关的配置进行绑定，以便于获取或修改配置，但是 @ConfigurationProperties 功能是由容器提供的，被它注解的类必须是容器中的一个组件，否则该功能就无法使用。而 @EnableConfigurationProperties 注解的作用正是将指定的类以组件的形式注入到 IOC 容器中，并开启其 @ConfigurationProperties 功能。因此，@ConfigurationProperties + @EnableConfigurationProperties 组合使用，便可以为 XxxProperties 类实现配置绑定功能。</p>
<h2 id="自动配置的生效和修改"><a href="#自动配置的生效和修改" class="headerlink" title="自动配置的生效和修改"></a>自动配置的生效和修改</h2><p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 Spring Boot 中以 @Conditional 派生注解的形式体现，如下表。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>生效条件</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>应用使用指定的 Java 版本时生效</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足指定的 SpEL 表达式时生效</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>不存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定属性存在指定的值时生效</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下存在指定的资源文件时生效</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前应用是 web 应用时生效</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前应用不是 web 应用生效</td>
</tr>
</tbody></table>
<p><a href="http://c.biancheng.net/spring_boot/auto-config.html">Spring Boot自动配置原理 (biancheng.net)</a></p>
<h1 id="Spring-boot-starter-web（Web启动器）"><a href="#Spring-boot-starter-web（Web启动器）" class="headerlink" title="Spring-boot-starter-web（Web启动器）"></a>Spring-boot-starter-web（Web启动器）</h1><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。</p>
<p>Spring Boot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 Spring MVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。</p>
<p>只要我们在 Spring Boot 项目中的 pom.xml 中引入了 spring-boot-starter-web ，即使不进行任何配置，也可以直接使用 Spring MVC 进行 Web 开发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Spring-Boot拦截器"><a href="#Spring-Boot拦截器" class="headerlink" title="Spring Boot拦截器"></a>Spring Boot拦截器</h1><p><a href="https://www.cnblogs.com/ye-hcj/p/9614109.html">springboot成神之——监视器 - qz奔跑的马 - 博客园 (cnblogs.com)</a></p>
<h1 id="Spring-Boot-中的监视器"><a href="#Spring-Boot-中的监视器" class="headerlink" title="Spring Boot 中的监视器"></a><strong>Spring Boot</strong> <strong>中的监视器</strong></h1><p><strong>Spring Boot中的监视器是什么？</strong></p>
<p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>
<h1 id="Spring-Boot-热加载"><a href="#Spring-Boot-热加载" class="headerlink" title="Spring Boot 热加载"></a><strong>Spring Boot</strong> 热加载</h1><p>修改代码后不需要重启服务， 自动加载修改的内容。  修改内容后restart加载器加载会变动的资源。 那些第三方的包不会被重新加载， 所以可以提高重启速度</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是JavaConfig？"><a href="#什么是JavaConfig？" class="headerlink" title="什么是JavaConfig？"></a><strong>什么是JavaConfig？</strong></h2><p>Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：</p>
<p>面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。</p>
<p>减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。</p>
<p>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud一站式微服务解决方案</title>
    <url>/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="微服务生态"><a href="#微服务生态" class="headerlink" title="微服务生态"></a>微服务生态</h1><p><a href="https://martinfowler.com/microservices/">Microservices Guide (martinfowler.com)</a></p>
<p><img src="https://pic1.zhimg.com/v2-411c496a803862df08e8ac16f9fe5039_1440w.jpg?source=172ae18b" alt="一篇文章搞懂 Spring Cloud 是什么"></p>
<span id="more"></span>

<h2 id="SpringCloud模块的搭建"><a href="#SpringCloud模块的搭建" class="headerlink" title="SpringCloud模块的搭建"></a>SpringCloud模块的搭建</h2><p>1.在父项目下创建module模块 选择Maven模式</p>
<p>2.修改pom.xml文件 将其需要从父类继承的依赖添加进本模块的pom文件中</p>
<p>3.写application.yml文件 关于模块的资源配置</p>
<p>4.创建模块的主启动类 添加注解</p>
<p>5.开始写业务</p>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h2><h2 id="ribbon和nginx的区别"><a href="#ribbon和nginx的区别" class="headerlink" title="ribbon和nginx的区别"></a>ribbon和nginx的区别</h2><h2 id="Ribbon-如何使用？"><a href="#Ribbon-如何使用？" class="headerlink" title="Ribbon 如何使用？"></a>Ribbon 如何使用？</h2><h2 id="Ribbon使用场景"><a href="#Ribbon使用场景" class="headerlink" title="Ribbon使用场景"></a>Ribbon使用场景</h2><h2 id="Ribbon轮询算法及其实现原理"><a href="#Ribbon轮询算法及其实现原理" class="headerlink" title="Ribbon轮询算法及其实现原理"></a>Ribbon轮询算法及其实现原理</h2><h2 id="手写Ribbon负载均衡算法"><a href="#手写Ribbon负载均衡算法" class="headerlink" title="手写Ribbon负载均衡算法"></a>手写Ribbon负载均衡算法</h2><p>Ribbon是负载均衡算法</p>
<h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><p><a href="https://spring.io/projects/spring-cloud-openfeign">Spring Cloud OpenFeign</a></p>
<p><strong>消费端</strong>的负载均衡和路由转发 即自动集成了Ribbon+RestTemplate </p>
<p>就是对外的一个提供负载均衡的微服务使用中间件。</p>
<h2 id="使用OpenFeign"><a href="#使用OpenFeign" class="headerlink" title="使用OpenFeign"></a>使用OpenFeign</h2><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注册到服务中心</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<p>首先创建主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableFeignClients标识该微服务为Feign的消费端</p>
<p>接着创建service包 并创建与服务端接口interface 即其中的提供服务的方法与服务端提供的对外@RequestMapping（@GettingMapping或@PostMapping）方法相同。</p>
<p>在Feign的这个接口添加两个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.@Component 给Spring扫描</p>
<p>2.@FeignClient(value &#x3D; “CLOUD-PAYMENT-SERVICE”) 指定哪个服务名称的服务端提供给服务 如果是集群 则进行负载均衡（默认轮询）</p>
<p><strong>代表的是 这个接口中 在@FeignClient的value值所指向的集群中 寻找以下接口中的对外Request方法。</strong></p>
<p>接着创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br></pre></td></tr></table></figure>

<p>然后就可以在其中调用接口中的方法了 调用的的实际上是服务端的对外接口。</p>
<h2 id="Feign超时预警"><a href="#Feign超时预警" class="headerlink" title="Feign超时预警"></a>Feign超时预警</h2><img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220626150939581.png" class="" title="image-20220626150939581">

<p>当设置服务端的controller 的对外方法为超过1秒的时候 Feign消费端调用这个方法便会出现以上错误。</p>
<p>但是有些服务的运行时间就是大于一秒 ，为了避免这种情况， 需要设置Feign客户端的超时控制。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment">#读取超时时间 指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#连接超时时间 指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="什么是Hystrix？"><a href="#什么是Hystrix？" class="headerlink" title="什么是Hystrix？"></a>什么是Hystrix？</h2><p><a href="https://github.com/Netflix/Hystrix">GitHub - Netflix&#x2F;Hystrix: Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">How it Works · Netflix&#x2F;Hystrix Wiki · GitHub</a></p>
<h2 id="服务降级：系统有限的资源的合理协调"><a href="#服务降级：系统有限的资源的合理协调" class="headerlink" title="服务降级：系统有限的资源的合理协调"></a>服务降级：<strong>系统有限的资源的合理协调</strong></h2><ul>
<li><p>概念：服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而<strong>释放服务器资源的资源以保证核心业务的正常高效运行。</strong></p>
</li>
<li><p>原因： 服务器的资源是有限的，而请求是无限的。在用户使用即并发高峰期，会影响整体服务的性能，严重的话会导致宕机，以至于某些重要服务不可用。故高峰期为了保证核心功能服务的可用性，就需要对某些服务降级处理。可以理解为舍小保大</p>
</li>
<li><p>应用场景： 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时（比如双11、6.18等活动或者秒杀活动）</p>
</li>
<li><p>服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。</p>
</li>
<li><p>需要考虑的问题：</p>
</li>
<li><ul>
<li>区分那些服务为核心？那些非核心</li>
<li>降级策略（处理方式，一般指如何给用户友好的提示或者操作）</li>
<li>自动降级还是手动降</li>
</ul>
</li>
</ul>
<h2 id="服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况"><a href="#服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况" class="headerlink" title="服务熔断：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况"></a>服务熔断<strong>：应对雪崩效应的链路自我保护机制。可看作降级的特殊情况</strong></h2><ul>
<li>概念：应对微服务雪崩效应的一种链路保护机制，类似股市、保险丝</li>
<li>原因： 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应</li>
<li>服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</li>
<li>服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</li>
</ul>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p>
<ul>
<li>应用场景：微服务架构中，多个微服务相互调用出使用</li>
<li>需要考虑问题：</li>
<li><ul>
<li>如何所依赖的服务对象不稳定</li>
<li>失败之后如何快速恢复依赖对象，如何探知依赖对象是否恢复</li>
</ul>
</li>
</ul>
<h2 id="服务降级和服务熔断区别"><a href="#服务降级和服务熔断区别" class="headerlink" title="服务降级和服务熔断区别"></a><strong>服务降级和服务熔断区别</strong></h2><ul>
<li><p>触发原因不一样，服务熔断由链路上某个服务引起的，服务降级是从整体的负载考虑</p>
</li>
<li><p>管理目标层次不一样，服务熔断是一个框架层次的处理，服务降级是业务层次的处理</p>
</li>
<li><p>实现方式不一样，服务熔断一般是自我熔断恢复，服务降级相当于人工控制</p>
</li>
<li><p>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</p>
</li>
</ul>
<p>一句话：</p>
<p>服务熔断是应对系统服务雪崩的一种保险措施，给出的一种特殊降级措施。而服务降级则是更加宽泛的概念，主要是对系统整体资源的合理分配以应对压力。</p>
<p>服务熔断是服务降级的一种特殊情况，他是防止服务雪崩而采取的措施。系统发生异常或者延迟或者流量太大，都会触发该服务的服务熔断措施，链路熔断，返回兜底方法。这是对局部的一种保险措施。</p>
<p>服务降级是对系统整体资源的合理分配。区分核心服务和非核心服务。对某个服务的访问延迟时间、异常等情况做出预估并给出兜底方法。这是一种全局性的考量，对系统整体负荷进行管理。</p>
<p>限流：限制并发的请求访问量，超过阈值则拒绝；</p>
<p>降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；</p>
<p>熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复</p>
<h2 id="服务服务限流"><a href="#服务服务限流" class="headerlink" title="服务服务限流"></a>服务服务限流</h2><p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。</p>
<h2 id="关于JMeter的使用和测试"><a href="#关于JMeter的使用和测试" class="headerlink" title="关于JMeter的使用和测试"></a>关于JMeter的使用和测试</h2><h3 id="压测的使用"><a href="#压测的使用" class="headerlink" title="压测的使用"></a>压测的使用</h3><h2 id="Springboot自己集成的Tomcat服务器的默认线程数目"><a href="#Springboot自己集成的Tomcat服务器的默认线程数目" class="headerlink" title="Springboot自己集成的Tomcat服务器的默认线程数目"></a>Springboot自己集成的Tomcat服务器的默认线程数目</h2><p>因为默认只有是个线程数，所以当多个请求打到一个对外服务的接口的时候，就会有很多的资源分配到这个接口上，其他的对外接口的资源分配就不会很平均。所以一个微服务会将更多的资源分配到需要资源的位置上，这样的话，就会导致这个微服务的所有对外接口都会多少变慢，而假如此时消费者访问这个微服务那么就不会得到满意的反馈。</p>
<p>springboot继承的tomcat的线程数和调优。	</p>
<p><a href="https://blog.csdn.net/qq_31086797/article/details/110523079">(40条消息) springboot内置tomcat调优并发线程数_CRUD的W的博客-CSDN博客_springboot tomcat线程池</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>首先再pom.xml引入</p>
<p>然后application.yaml设置支持Hystrix</p>
<p>主启动类添加@EnableHystrix</p>
<h2 id="Hystrix的抽象类-HystrixCommandProperties-为属性集合"><a href="#Hystrix的抽象类-HystrixCommandProperties-为属性集合" class="headerlink" title="Hystrix的抽象类 HystrixCommandProperties 为属性集合"></a>Hystrix的抽象类 HystrixCommandProperties 为属性集合</h2><h2 id="服务降级："><a href="#服务降级：" class="headerlink" title="服务降级："></a>服务降级：</h2><p><strong>出现服务降级的几种情况：</strong></p>
<p>1）<strong>超时降级</strong>：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</p>
<p>2）<strong>失败次数降级</strong>：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</p>
<p>3）<strong>故障降级</strong>：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</p>
<p>4）<strong>限流降级</strong>：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<h3 id="局部降级"><a href="#局部降级" class="headerlink" title="局部降级"></a>局部降级</h3><p>首先对于以上可能出现问题的单个服务，我们在提供服务的接口上进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//在Mapping的下面进行指定fallbackMethod 既有哪个方法提供降级的服务 commandProperties可以进行线程超时时间等的设置 更多设置请参考代码下方文档</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处是提供服务降级的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/acmman/article/details/100595666">(40条消息) 【Spring Cloud总结】18.Hystrix的commandProperties配置_光仔December的博客-CSDN博客</a></p>
<p>既然在业务层这样设置了 那么在主启动类就应该添加支持其的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure>

<p>关于@EnableHystrix注解与@EnableCircuitBreaker的区别：需要在服务启动类加入@EnableHystrix注解即可，无须增加@EnableCircuitBreaker注解，本身**@EnableHystrix注解已经涵盖了EnableCircuitBreaker的功能。**</p>
<h3 id="全局降级"><a href="#全局降级" class="headerlink" title="全局降级"></a>全局降级</h3><p>1.如果都使用以上的方法，将所有提供服务的接口都进行服务降级保护,那未免太过于冗余和臃肿以及繁琐，我们就可以设置全局的服务降级的方法。</p>
<p>在业务类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span></span><br></pre></td></tr></table></figure>

<p>再将其中可能出现问题的接口添加@HystrixCommand注解</p>
<p>其中注解指定的方法就是在这个业务接口实现方法出现问题的时候，指定的默认的一个业务类中的处理方法。</p>
<p>把具体的实现举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">payment_Global_FallbackMethod</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是当服务端整个宕机后，我们应该在客户端就进行处理。</p>
<p>2.因为在客户端，我们经常的使用的是将服务端的对外方法创建一个接口，然后将这个接口添加Feign的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-provider-hystrix-payment&quot;,fallback = PaymentFallbackService.class)</span></span><br></pre></td></tr></table></figure>

<p>代表着在客户端这个接口中定义的方法应该在哪个集群中寻找@RequestMapping()接口地址相同的服务方法，既绝大多数的客户端的业务实现都来自于这个接口的定义的方法，所以我们实现这个接口的所有方法，将其实现方法使用@Componet注解添加到SpringBoot中，之后在接口处添加，fallback &#x3D; 实现类类名.class，再依次实现其中的方法，便是当服务端宕机后的实现了。</p>
<h2 id="服务熔断："><a href="#服务熔断：" class="headerlink" title="服务熔断："></a>服务熔断：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNumber</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> + id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于@HystrixCommand注解内的配置 除了第一个外 总体意味着：再在某个固定的时间段（时间窗口期）内，当请求次数为10的时候，失败的请求次数（失败率）占比高达60%的时候，进行服务的熔断。</p>
<h3 id="服务熔断的三种状态"><a href="#服务熔断的三种状态" class="headerlink" title="服务熔断的三种状态"></a>服务熔断的三种状态</h3><img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628172737991.png" class="" title="image-20220628172737991">

<p>熔断打开：</p>
<p>熔断关闭：不会对微服务进行熔断</p>
<p>熔断半开：</p>
<h2 id="搭建服务监控"><a href="#搭建服务监控" class="headerlink" title="搭建服务监控"></a>搭建服务监控</h2><p> 创建一个新的微服务，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>被监控的服务应该添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>被监控的主启动类添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>启动，输入需要被监控的地址参数：</p>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628182404648.png" class="" title="image-20220628182404648">

<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220628182532190.png" class="" title="image-20220628182532190">

<h1 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h1><p><a href="https://spring.io/projects/spring-cloud-gateway">Spring Cloud Gateway</a></p>
<p>服务网关方面 我们有zull和gateway两种选择 选择gateway </p>
<p>内部组件：Spring WebFlux+netty  &#x2F;&#x2F;TODO</p>
<p>Gateway实现了负载均衡<a href="https://blog.csdn.net/qq_25861361/article/details/89875942">(42条消息) GateWay负载均衡_神绮H亚里亚的博客-CSDN博客_gateway负载均衡</a></p>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220629090424236.png" class="" title="image-20220629090424236">

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加该依赖后 应该移除以下两个依赖，否则报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p><strong>application.yaml的路由相关配置：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,zzyy</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br></pre></td></tr></table></figure>



<h2 id="路由routes"><a href="#路由routes" class="headerlink" title="路由routes:"></a>路由routes:</h2><h2 id="断言predicate"><a href="#断言predicate" class="headerlink" title="断言predicate"></a>断言predicate</h2><p>是一个针对http协议的封装使用 		</p>
<h3 id="测试的curl命令"><a href="#测试的curl命令" class="headerlink" title="测试的curl命令"></a>测试的curl命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9527/payment/lb --cookie &quot;username=zzyy&quot;//本次测试使用语句</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/07c4dddae43a">curl 命令详解 - 简书 (jianshu.com)</a></p>
<p>如果不满足断言条件：返回编码404</p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>虽然SpringCould提供了很多过滤器 但是通常我们都自己定义过滤器的业务逻辑</p>
<p>创建filter业务类 实现GlobalFilter,Ordered接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***********come in MyLogGateWayFilter:  &quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//      判断http请求是否带有uname的一个key 既是否带有这样的一个参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;</span>);</span><br><span class="line"><span class="comment">//            设置为不可接受的http状态码</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代表优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多过滤条件通过ServerWebExchange的API获取&#x2F;&#x2F;TODO</p>
<h1 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h1><p>在分布式微服务系统中，几乎所有服务的运行都离不开配置文件的支持，这些配置文件通常由各个服务自行管理，以 properties 或 yml 格式保存在各个微服务的类路径下，例如 application.properties 或 application.yml 等。</p>
<p>这种将配置文件散落在各个服务中的管理方式，存在以下问题：</p>
<ul>
<li><strong>管理难度大</strong>：配置文件散落在各个微服务中，难以管理。</li>
<li><strong>安全性低</strong>：配置跟随源代码保存在代码库中，容易造成配置泄漏。</li>
<li><strong>时效性差</strong>：微服务中的配置修改后，必须重启服务，否则无法生效。</li>
<li><strong>局限性明显</strong>：无法支持动态调整，例如日志开关、功能开关。</li>
</ul>
<p>简单点说就是，Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</p>
<p>Spring Cloud <strong>Config 包含服务端和客户端</strong>以下两个部分：</p>
<ul>
<li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li>
<li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li>
</ul>
<img src="/2022/06/25/SpringCloud%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20220630092926542.png" class="" title="image-20220630092926542">

<h3 id="通过Config客户端访问Config服务端"><a href="#通过Config客户端访问Config服务端" class="headerlink" title="通过Config客户端访问Config服务端"></a>通过Config客户端访问Config服务端</h3><p>Pom文件：</p>
<p>1.服务端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        图形化监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.客户端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        图形化监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/shuaiqiwudi/springcloud-config</span>  <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">####读取分支 如果url不指定分支进行配置的访问 浏览器默认使用master</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>此时如果单独启动3344服务端，尝试访问端口号，会获取到仓库里配置文件的端口号。</p>
<p>访问的url：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:3344/main/config-dev.yaml</span><br><span class="line">		端口号/分支名称/name/profile</span><br></pre></td></tr></table></figure>

<p>当然，<strong>不指定分支的时候，默认是master分支，但现在的github上默认是main分支</strong>					</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过服务调用仓库进行查看 既为config的服务端</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigCenterMain3344</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Config客户端</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3355</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意的是，Config的客户端的配置文件不再是application.yaml,而是<strong>bootstrap.yml</strong></p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>当修改仓库的配置信息的时候 ，服务端相关配置的获取是随着仓库的文件而修改的，但客户端通过服务端获取到的配置不再是更新的了，所以我们需要将客户端的配置信息设置为动态获取的。</p>
<p>1、首先在pom文件修改配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点 客户端动态获取</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.在业务逻辑的类上添加注解@RefreshScope</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/serverPort&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServerPort</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时仍然不能完成客户端的动态刷新 需要发送一个post请求到3355客户端</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://localhost:<span class="number">3355</span>/actuator/refresh&quot;</span><br></pre></td></tr></table></figure>

<p>然后再次通过客户端获取成功。（idea的例子是获取到本地bootstrap.yaml的端口号)</p>
<p>这样获取就不再需要重启客户端。</p>
<p>需要仔细再次阅读的：</p>
<p><a href="https://blog.csdn.net/li1669852599/article/details/120665809">(40条消息) 微服务架构 | Hystrix的资源隔离策略该如何选择？_码农架构的博客-CSDN博客</a></p>
<p>巨人的肩膀：</p>
<p>[服务降级与服务熔断区别 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/341939685#:~:text=%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E6%98%AF%E5%BA%94%E5%AF%B9%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E3%80%82">https://zhuanlan.zhihu.com/p/341939685#:~:text=服务熔断是应对雪崩效应的一种微服务链路保护机制。</a> 例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。 同样，在微服务架构中，熔断机制也是起着类似的作用。 当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。,当检测到该节点微服务调用响应正常后，恢复调用链路。 服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。 在Spring Cloud框架里，熔断机制通过Hystrix实现。 Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。)</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Write blog using markdown01</title>
    <url>/2022/05/07/Write-blog-using-markdown01/</url>
    <content><![CDATA[<h4 id="预览界面"><a href="#预览界面" class="headerlink" title="预览界面"></a>预览界面</h4><p><strong>hexo g</strong><br><strong>hexo s</strong></p>
<h4 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h4><p><em>hexo clean</em><br><em>hexo g</em><br><em>hexo d</em></p>
<p>[md文档教程]<a href="https://www.imooc.com/wiki/markdownlesson/markdownlink.html">14 Markdown 超链接丨慕课网教程 (imooc.com)</a></p>
<p>值得深究的文档：</p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事 (youzan.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/05/28/SpringMVC/</url>
    <content><![CDATA[<img src="/2022/05/28/SpringMVC/image-20220528102032212.png" class="" title="image-20220528102032212">

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><span id="more"></span>

<h2 id="什么是SpringMVC？"><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h2><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>SpringMVC属于Spring 的一部分</p>
<p><img src="https://img-blog.csdnimg.cn/20190328153606755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="SpringMVC的核心架构："><a href="#SpringMVC的核心架构：" class="headerlink" title="SpringMVC的核心架构："></a>SpringMVC的核心架构：</h2><p><img src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>具体流程：</p>
<p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
<p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p>
<p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>
<p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>
<p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p>
<p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p>
<p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>
<img src="/2022/05/28/SpringMVC/wps1.jpg" class="" title="img">

<h2 id="组件分析"><a href="#组件分析" class="headerlink" title="组件分析"></a>组件分析</h2><ol>
<li><p><strong>前端控制器：DispatcherServlet</strong></p>
<p> 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
</li>
<li><p><strong>处理器映射器：HandlerMapping HandlerMapping</strong></p>
<p>负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。        </p>
</li>
<li><p><strong>处理器适配器：HandlerAdapter</strong>     </p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。        </p>
</li>
<li><p><strong>处理器：Handler</strong>     </p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。        </p>
</li>
<li><p><strong>视图解析器：View Resolver</strong>     </p>
<p> View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即 具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>视图：View</strong><br>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最 常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程 序员根据业务需求开发具体的页面</p>
</li>
</ol>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p> Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。将拦截器按一定的顺序联结成<strong>一条链</strong>，这条链称为<strong>拦截器链（Interceptor Chain）</strong>。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前<strong>定义的顺序被调用</strong>。拦截器也是AOP思想的具体实现。</p>
<p>拦截器的方法声明：</p>
<p><img src="https://img-blog.csdnimg.cn/4561be39258343c3acf60145af40f4dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="自定义拦截器进行资源拦截"><a href="#自定义拦截器进行资源拦截" class="headerlink" title="自定义拦截器进行资源拦截"></a>自定义拦截器进行资源拦截</h3><p>​        <em>① 创建拦截器类实现HandlerInterceptor接口</em></p>
<p>​        <em>② 配置拦截器</em></p>
<p>​        <em>③ 测试拦截器的拦截效果</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在目标方法执行之后 视图对象返回之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">         <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">         <span class="comment">//设置需要的程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h2><h3 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h3><p>​        系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后 者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<pre><code>    系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交 由异常处理器进行异常处理，如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/d4d82dfe8933400d99919f904d5d56bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h3 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h3><p>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver<br>实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p>
<h3 id="简单异常处理器SimpleMappingExceptionResolver"><a href="#简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="简单异常处理器SimpleMappingExceptionResolver"></a>简单异常处理器SimpleMappingExceptionResolver</h3><p>  SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p>
<p><img src="https://img-blog.csdnimg.cn/b61441bc5b3a4d12933d910d07bc3de9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASkFWQeaIkOelng==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<img src="/2022/05/28/SpringMVC/70.png" class="" title="img">

<p><a href="https://blog.csdn.net/litianxiang_kaola/article/details/79169148">(32条消息) SpringMVC框架理解_椰子Tyshawn的博客-CSDN博客_springmvc</a></p>
<p><a href="https://blog.csdn.net/qq_58168493/article/details/122634493">(32条消息) 黑马程序员–SpringMVC详细教程_JAVA成神的博客-CSDN博客_springmvc教程</a></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>equals()与HashCode()的爱恨情仇</title>
    <url>/2022/05/12/equals-%E4%B8%8EHashCode%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
    <content><![CDATA[<h4 id="‘-x3D-x3D-’和equals"><a href="#‘-x3D-x3D-’和equals" class="headerlink" title="‘&#x3D;&#x3D;’和equals"></a>‘&#x3D;&#x3D;’和equals</h4><p>“&#x3D;&#x3D;”运算符用来比较两个变量的值是否相等。也就是说，该运算符用于比较变量对应的内存中所存储的数值是否相同。</p>
<p>对于基本数据类而言，可以直接使用“&#x3D;&#x3D;”运算符来比较其对应的值是否相等。但是对于引用类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure>

<p>此时的两个引用变量所对应内存中存储的数值就是对象占用的那块内存的首地址。如果要比较两个对象的是否是同一个对象，</p>
<p>则可以使用”&#x3D;&#x3D;“，如果要比较两个对象的内容是否相同，则不可以使用”&#x3D;&#x3D;“实现了。</p>
<p>equals是Object类提供的方法之一。每一个Java类都集成自Object类，所以每一个对象都具有equals这个方法。</p>
<p>相比“&#x3D;&#x3D;”运算符，equals(Object)方法的特殊之处就在于它可以被覆盖，所以可以通过覆盖的方法让它不是比较引用而是比较数据内容。</p>
<p>那么equals()是如何比较引用类型的内容的？</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//		generate生成的equals和hashcode</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (Human) o;</span><br><span class="line">            <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= human.age &amp;&amp;</span><br><span class="line">                    Objects.equals(name, human.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashCode和equals"><a href="#HashCode和equals" class="headerlink" title="HashCode和equals"></a>HashCode和equals</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数.</p>
<h4 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals() 的相关规定"></a><strong>hashCode()<strong>与</strong>equals()</strong> <strong>的相关规定</strong></h4><p>如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的。</p>
<h4 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h4><p>第一种 不会创建“类对应的散列表”<br> 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”没有关系。<br> 这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p>
<p>第二种 会创建“类对应的散列表”<br> 这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：<br> 1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br> 这里的相等是指，通过equals()比较两个对象时返回true。<br> 2)、如果两个对象hashCode()相等，它们并不一定相等。<br> 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。<br> <strong>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。</strong></p>
<p>[(51条消息) Java 中的 &#x3D;&#x3D;, equals 与 hashCode 的区别与联系_书呆子Rico的博客-CSDN博客_equal和hashcode](<a href="https://blog.csdn.net/justloveyou_/article/details/52464440#:~:text=1%E3%80%81%E6%A6%82%E5%BF%B5">https://blog.csdn.net/justloveyou_/article/details/52464440#:~:text=1、概念</a> %3D%3D ： 该操作符生成的是一个boolean结果，它计算的是 操作数的值之间的关系 equals ： Object,hashCode ： Object 的 native方法%2C 获取对象的 哈希值 ，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数)</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/05/16/git/</url>
    <content><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><img src="/2022/05/16/git/image-20220516150930144.png" class="" title="image-20220516150930144">

<ul>
<li><p>workspace：工作区</p>
</li>
<li><p>staging area：暂存区&#x2F;缓存区</p>
</li>
<li><p>local repository：版本库或本地仓库</p>
</li>
<li><p>remote repository：远程仓库</p>
<span id="more"></span></li>
</ul>
<p>合作开发第一个项目的时候 就感觉到git的强大 同时也被git上了一课 多版本的来回混合 以及多个操作 搞得有点乱 从空间和操作命令上来结合了解以下git到底如何使用 执行命令后哪里的代码跑到哪里了？</p>
<p>与远程仓库建立连接</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:shuaiqiwudi/...（具体仓库地址）</span><br></pre></td></tr></table></figure>

<p>首先要初始化一个仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git add .    </span><br><span class="line">$ git commit  </span><br></pre></td></tr></table></figure>

<p>创建分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch (branchname) //不加名字 为查看分支</span><br></pre></td></tr></table></figure>

<p>切换分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure>

<p>合并分支：</p>
<p>需要先切换到主分支下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge (想要合并的分支)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2022/05/20/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库逻辑架构"><a href="#数据库逻辑架构" class="headerlink" title="数据库逻辑架构"></a>数据库逻辑架构</h2><img src="/2022/05/20/mysql/image-20220522131409069.png" class="" title="image-20220522140130072">

<h3 id="连接层-Connection-Pool"><a href="#连接层-Connection-Pool" class="headerlink" title="连接层 Connection Pool"></a>连接层 Connection Pool</h3><p>系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证</p>
<p><strong>TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池</strong></p>
<h4 id="连接池（线程池）"><a href="#连接池（线程池）" class="headerlink" title="连接池（线程池）"></a>连接池（线程池）</h4><p>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。</p>
<span id="more"></span>

<details>
<summary>点击查看线程池详细内容</summary>
<b>为什么使用连接池？</b><br>
对于数据库建立连接对象，对应一个实际的物理连接，每次使用都打开一个连接，再关闭一个连接，这样会造成书库的性能低下。解决方案是，应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池**(简单说：在一个“池”里放了好多半成品的数据库联接对象)**，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。这样一来，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率。<br>
<b>不使用连接池 执行一条sql的过程：</b><br><br>
<img src="/2022/05/20/mysql/image-20220522133151857.png" class="" title="image-20220522133151857">
<br>
1. TCP建立连接的三次握手<br>
2. MySQL认证的三次握手<br>
3. 真正的SQL执行<br>
4. MySQL的关闭<br>
5. TCP的四次握手关闭<br>
<b>使用连接池 执行一条sql的过程：</b><br>
<img src="/2022/05/20/mysql/image-20220522133456976.png" class="" title="image-20220522133456976"><br>
第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。<br>
<b>线程池工作的原理</b><br>
建立连接 管理链接 删除连接 <br>
第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。<br>
第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：<br>
当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>
当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。<br>
第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。
<b>主流的几个连接池</b>
数据库连接池有三种：</b>
1、DBCP:</b>
DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。</b>
2、C3P0:</b>
c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。</b>
3、Druid:</b>
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个 SQL Parser。</b>
支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。</b>
Druid针对Oracle和MySql做了特别优化，比如Oracle的PS Cache内存占用优化，MySql的ping检测优化。</b>
Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。</b>
简单SQL语句用时10微秒以内，复杂SQL用时30微秒。通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。</b>
Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析语义实现的。</b>
<img src="/2022/05/20/mysql/image-20220522134845235.png" class="" title="image-20220522134845235"></b>
参考链接
原文链接：https://blog.csdn.net/weixin_43871678/article/details/116571499</b>
原文链接：https://blog.csdn.net/CrankZ/article/details/82874158</b>
</details>



<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p><strong>SQL Interface: SQL</strong> <strong>接口</strong></p>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface . MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
<p><strong>Parser:</strong> <strong>解析器</strong></p>
<p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 </p>
<p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。<strong>这个执行计划表明应该 使用哪些索引 进行查询</strong>（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真的执行查询，并将查询结果返回给用户。</p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
<p><strong>Caches &amp; Buffers</strong> <strong>： 查询缓存组件</strong></p>
<p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。这个查询缓存可以在 不同客户端之间共享 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </p>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了</strong> <strong>MySQL</strong> <strong>中数据的存储和提取，对物理服务器级别</strong> <strong>维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<img src="/2022/05/20/mysql/image-20220522140130072.png" class="" title="image-20220522140130072">

<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>作为数据真正的物理存储位置，所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。</p>
<p><strong>MyISAM</strong>存储文件后缀为—– <strong>.myd(数据) 和.myi (索引)</strong> </p>
<p><strong>Innodb</strong>的索引和数据是集中存储的 —– <strong>.ibd</strong></p>
<h3 id="整个执行流程"><a href="#整个执行流程" class="headerlink" title="整个执行流程"></a><strong>整个执行流程</strong></h3><img src="/2022/05/20/mysql/image-20220522141658938.png" class="" title="image-20220522141658938">

<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a><strong>数据库三大范式</strong></h2><p><strong>第一范式</strong>：每个列都不可以再拆分。</p>
<p><strong>第二范式</strong>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p><strong>第三范式</strong>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>详解：</p>
<p>第二范式(Second Normal Form,2nd NF)是指每个表必须有一个(而且仅有一个)数据元素为主关键字(Primary key),其他数据元素与主关键字一一对应。通常称这种关系为函数依赖(Functional dependence)关系，即表中其他数据元素都依赖于主关键字,或称该数据元素惟一地被主关键字所标识。（但是其他字段之间可能还会存在依赖关系）</p>
<p>第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="两大存储引擎"><a href="#两大存储引擎" class="headerlink" title="两大存储引擎"></a>两大存储引擎</h2><img src="/2022/05/20/mysql/image-20220520170817159.png" class="" title="image-20220520170817159">

<img src="/2022/05/20/mysql/image-20220520170840162.png" class="" title="image-20220520170840162">

<p>InnoDB的B+树索引的注意事项</p>
<p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>
<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<h3 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h3><p>索引的存在 就是为了<strong>减少磁盘的IO次数</strong> 增加读取的效率 </p>
<p><strong>什么是索引</strong>：MySQL官方对索引的定义为：<strong>索引（</strong>Index<strong>）是帮助</strong>MySQL<strong>高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<p><strong>优点</strong>：1 ）提高数据检索的效率，降低 数据库的IO成本</p>
<p>​			2 ）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</p>
<p>​			3）在实现数据的参考完整性方面，可以 加速表和表之间的连接 。</p>
<p>​			4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</p>
<p><strong>缺点</strong>：</p>
<p>1）<strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<p>2）<strong>时间上的代价</strong></p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h3 id="设计索引和数据的存储形式"><a href="#设计索引和数据的存储形式" class="headerlink" title="设计索引和数据的存储形式"></a>设计索引和数据的存储形式</h3><p>当我们使用命令创建一个表的时候 数据会以特定的形式存在于表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test(</span><br><span class="line">	number int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">)ROW_FORMAT = Compact;//指定行格式</span><br></pre></td></tr></table></figure>

<p>行数据究竟怎么存储的？Compact的行格式:</p>
<img src="/2022/05/20/mysql/1097754-20210719234605417-2013635397.png" class="" title="img">

<p>DB_ROW_ID(row_id)：如果表中没有显式定义主键列，mysql会默认生成一个row_id作为隐式主键，且row_id是全局概念，每一次有一行新数据insert，都会获取Max Row ID再加1就形成了一个新的row_id<br>DB_TRX_ID： 事务有关，跟回滚指针有关，6个字节<br>DB_ROLL_PTR ：事务有关，跟回滚指针有关， 7个字节</p>
<p>delete mask : 标记为是否被delete语句commit，也就是mysql不会真正物理删除一行记录，在页面上重新组装一个新链表，称为垃圾链表，如果垃圾链表占用空间可重用的话就会重用。</p>
<p>record type：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过。</p>
<p>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>
<img src="/2022/05/20/mysql/image-20220523095656639.jpg" class="" title="image-20220523095656639">

<p>从数据的连接角度来简略展示行数据 每一行数据如此 那么把多数的数据连接起来呢？</p>
<img src="/2022/05/20/mysql/image-20220523095757181.jpg" class="" title="image-20220523095757181">

<p>多行数据进行连接 形成一个页 每一页存放多行数据 页的第一个位置和最后一个位置不存放数据 用来表示该页的最小记录和最大记录。</p>
<p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<img src="/2022/05/20/mysql/image-20220523100525991.jpg" class="" title="image-20220523100525991">

<p>在根据该页的最小记录和最大记录 将每一页的位置进行定位</p>
<p><strong>InnoDB中的索引方案</strong> </p>
<p><strong>① 迭代1次：目录项记录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101301936.jpg" class="" title="image-20220523101301936">



<p><strong>② 迭代2次：多个目录项记录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101831703.jpg" class="" title="image-20220523101831703">



<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101951740.jpg" class="" title="image-20220523101951740">

<p><strong>④</strong> <strong>B+Tree</strong></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：</p>
<ul>
<li><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</p>
</li>
<li><p>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</p>
</li>
<li><p>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</p>
</li>
<li><p>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！！！</p>
</li>
</ul>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</p>
<h3 id="索引的类型和特点"><a href="#索引的类型和特点" class="headerlink" title="索引的类型和特点"></a>索引的类型和特点</h3><p><strong>1.聚簇索引</strong></p>
<p>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据；<strong>主键索引是聚簇索引的一种</strong>。通常情况下 我们使用主键作为自增的唯一id 但是如果没有主键 那么会默认使用row_id作为主键 </p>
<p>1）使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<p><strong>页内的记录</strong>是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</p>
<p>各个 <strong>存放用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个<strong>双向链表</strong> 。</p>
<p><strong>存放目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。 </p>
<p>2）B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p><strong>2.非聚簇索引</strong></p>
<p>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。简单理解：在聚簇索引上建立的索引就是非聚簇索引。对于主键索引和非主键索引，使用的数据结构都是 B+Tree，唯一的区别在于叶子结点中存储的内容不同：</p>
<ul>
<li>主键索引的叶子结点存储的是一行完整的数据。</li>
<li>非主键索引的叶子结点存储的则是主键值。</li>
</ul>
<p>在innodb中，在聚簇索引上建立的都是辅助索引，即非聚簇索引也叫辅助索引。一张表中只能有一个聚簇索引。其余索引都是非聚簇索引。辅助索引叶子节点存储的是主键值，访问数据总是要先查到主键值，再通过主键值访问到数据。即辅助索引访问数据总是需要二次查找 通常也成为回表</p>
<p><strong>回表：</strong></p>
<p>我们根据某个列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据该列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据非聚簇索引列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方想让books的书籍编号字段和价格字段索引联合创建索引的索引：首先按照书籍编号进行排序 然后在书籍编号的基础上按照价格进行排序。</p>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p><strong>1.最左前缀匹配原则</strong></p>
<p>非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p><strong>2.&#x3D;和in可以乱序</strong></p>
<p>比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p><strong>3.尽量选择区分度高的列作为索引</strong></p>
<p><strong>4.索引列不能参与计算</strong></p>
<p>保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</p>
<p><strong>5.尽量的扩展索引，不要新建索引。</strong></p>
<p>比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
<p><strong>6．选择唯一性索引</strong></p>
<p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
<p><strong>7．为经常需要排序、分组和联合操作的字段建立索引</strong></p>
<p>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p>
<p><strong>8．为常作为查询条件的字段建立索引</strong></p>
<p><strong>9．限制索引的数目</strong></p>
<p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p>
<p><strong>10．尽量使用数据量少的索引</strong></p>
<p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</p>
<p><strong>11．删除不再使用或者很少使用的索引</strong></p>
<p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
<h4 id="哪些字段适合创建索引"><a href="#哪些字段适合创建索引" class="headerlink" title="哪些字段适合创建索引"></a>哪些字段适合创建索引</h4><p><strong>1.字段的数值具有唯一性的限制</strong></p>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
<p><strong>2.频繁作为Where查询字段的字段</strong></p>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p><strong>3.经常GroupBy和Order BY的字段</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。 </p>
<p><strong>4.UPDATE,DELETE 的WHERE条件列</strong></p>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。在实际情况中 还有多种情景适合创建索引 凡是需要重复在聚簇索引中查找某一个列的字段 都可以创建索引</strong></p>
<h4 id="哪些字段不适合创建索引"><a href="#哪些字段不适合创建索引" class="headerlink" title="哪些字段不适合创建索引"></a>哪些字段不适合创建索引</h4><ol>
<li>在where中使用不到的字段，不要设置索引</li>
<li>数据量小的表最好不要使用索引</li>
<li>有大量重复数据的列上不要建立索引  比如男性女性这种很高几率重复的字段</li>
<li>避免对经常更新的表进行索引的创建</li>
<li>删除不再使用或者很少使用的索引</li>
<li>不要定义重复和冗余的索引</li>
</ol>
<h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3><ol>
<li><p>最左匹配原则：最左的索引条件需要满足</p>
</li>
<li><p>使用select*：</p>
</li>
<li><p>索引列参与运算：<strong>explain select * from t_user where id + 1 &#x3D; 2 ;</strong></p>
</li>
<li><p>使用函数：<strong>explain select * from t_user where SUBSTR(id_no,1,3) &#x3D; ‘100’;</strong></p>
</li>
<li><p>使用or：**explain select * from t_user where id &#x3D; 2 or username &#x3D; ‘Tom2’;**（在使用or关键字时，切记两个条件都要添加索引，否则会导致索引失效。）</p>
</li>
<li><p>is not null：<strong>explain select * from t_user where id_no is not null;</strong></p>
</li>
<li><p>order by（就是主键使用<code>order by</code>时，可以正常走索引。）</p>
</li>
</ol>
<h2 id="数据库的调优策略"><a href="#数据库的调优策略" class="headerlink" title="数据库的调优策略"></a>数据库的调优策略</h2><h3 id="SQL进行优化"><a href="#SQL进行优化" class="headerlink" title="SQL进行优化"></a>SQL进行优化</h3><p>首先查看慢查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like &#x27;%slow%&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后使用explain 这个sql语句进行查看这个sql的具体情况 具体走了哪个索引等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from test1;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220720202620445.png" class="" title="image-20220720202620445">



<h3 id="进行数据库的优化"><a href="#进行数据库的优化" class="headerlink" title="进行数据库的优化"></a>进行数据库的优化</h3><p>分库分表</p>
<p><a href="https://www.cnblogs.com/peng19920430/p/10231864.html#:~:text=%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B0%B1%E6%98%AF%E6%8C%89%E7%85%A7,%E5%AD%98%E5%82%A8%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%A1%A8%E4%B8%8A%E3%80%82">数据库分库分表 - 树_先_森 - 博客园 (cnblogs.com)</a></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在数据库中事务是什么</p>
<p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务处理原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><strong>原子性（atomicity）：</strong></p>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
<p><strong>一致性（</strong>consistency<strong>）：</strong></p>
<p>事务前后数据的完整性必须保持一致。保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态。</p>
<p><strong>隔离型（</strong>isolation<strong>）：</strong>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p><strong>持久性（</strong>durability<strong>）：</strong>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h4 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h4><p>显示事务：手动开启事务 begin 或 start transaction</p>
<p>隐式事务：MySql中有一个系统变量autocommit </p>
<img src="/2022/05/20/mysql/image-20220523195028484.jpg" class="" title="image-20220523195028484">

<p>该变量设置数据库执行语句是否自动提交 可以将该变量设置为不自动提交 </p>
<img src="/2022/05/20/mysql/image-20220523195555772.png" class="" title="image-20220523195555772">

<h4 id="数据库并发和隔离级别"><a href="#数据库并发和隔离级别" class="headerlink" title="数据库并发和隔离级别"></a>数据库并发和隔离级别</h4><p>事务的四种并发问题：</p>
<p><strong>1.脏写（ Dirty Write ）</strong>：</p>
<p>对于SessionA和SessionB 如果SessionA修改了另一个未提交事务SessionB修改过的数据 ，那就意味着脏写</p>
<p><strong>2.脏读（ Dirty Read）：</strong></p>
<p>SessionA已经读取了SessionB更新但还没有被提交到的字段，之后若SessionB回滚，SessionA读到的数据并不是真实数据，该数据就是临时且无效的脏读数据。</p>
<p><strong>3.不可重复读（Non</strong>-<strong>Repeatable Read）：</strong></p>
<p>SessionA开启事务并读取数据，但是此时SessionB将数据修改并提交，SessionA再查看数据值不同了，就意味着出现了不可重复读。</p>
<p><strong>4.幻读（Phantom）</strong>：</p>
<p>两个事务SessionA，SessionB SessionA从表中读取了一个字段后，SessionB向表中插入了一些新的行，之后，如果SessionA再次读取同一个表，就会出现几条新的数据（幻影记录），我们称之为幻读。</p>
<p>对于这四种现象 按照严重程度：</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>分别对应<strong>四种隔离级别</strong>：</p>
<p><strong>1.READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</p>
<p>不能避免脏读、不可重复读、幻读。</p>
<p><strong>2.READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>3.REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，</p>
<p>读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</p>
<p>4.<strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、</p>
<p>更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
<p>一张图：</p>
<img src="/2022/05/20/mysql/image-20220523201143065.jpg" class="" title="image-20220523201143065">

<p>5.7.36的隔离级别</p>
<img src="/2022/05/20/mysql/image-20220720204837621.png" class="" title="image-20220720204837621">

<p>8.0.29的隔离级别</p>
<img src="/2022/05/20/mysql/image-20220523201736656.jpg" class="" title="image-20220523201736656">

<h3 id="数据库事务日志"><a href="#数据库事务日志" class="headerlink" title="数据库事务日志"></a>数据库事务日志</h3><p>事务的四种特性是基于什么实现的？ </p>
<p><strong>隔离性</strong>根据<strong>锁机制</strong>实现事务的<strong>原子性，一致性和持久性</strong>由事务的<strong>redo日志和undo日志</strong>保证</p>
<p><strong>REDO LOG</strong> 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</p>
<p><strong>UNDO LOG</strong> 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</p>
<h4 id="为什么使用日志？"><a href="#为什么使用日志？" class="headerlink" title="为什么使用日志？"></a>为什么使用日志？</h4><p>redo log是事务持久性的保证</p>
<h4 id="REDO日志"><a href="#REDO日志" class="headerlink" title="REDO日志"></a>REDO日志</h4><p>一方面 缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面 由于数据库具有持久性的特点 就是说 对于一个已经提交的事务，再提交事务后即使发生了宕机或其他突发意外而奔溃，这个数据库所修改的数据也不会丢失。就使用到了日志，因为在每次提交事务的时候，我们都没必要去刷新一下磁盘，只需要记录一下哪些数据修改了就好。这就是redo日志。</p>
<img src="/2022/05/20/mysql/image-20220524201029477.jpg" class="" title="image-20220524201029477">

<h4 id="REDO日志的优点和特点"><a href="#REDO日志的优点和特点" class="headerlink" title="REDO日志的优点和特点"></a>REDO日志的优点和特点</h4><p>优点																											特点</p>
<p>降低了磁盘的刷新次数																			redo日志是顺序写入磁盘的			</p>
<p>redo日志占用空间小																				事务执行的过程中 redo log 不断记录</p>
<p>redolog分为以下两个部分</p>
<p>1.重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</p>
<p>2.重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p>redo log buffer 和 redo log file</p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<img src="/2022/05/20/mysql/image-20220524212211626.png" class="" title="image-20220524212211626">

<h4 id="REDO日志的刷盘策略"><a href="#REDO日志的刷盘策略" class="headerlink" title="REDO日志的刷盘策略"></a>REDO日志的刷盘策略</h4><p>redolog不是直接写入到磁盘当中的 而是先写入到redologbuffer  然后再以一定频率 写入到redologfile 这里的频率就涉及到了刷盘策略：</p>
<p>redologbuffer 刷盘到 redologfile 中并不是真正的写入到磁盘 只是刷入到 文件系统缓存（page cache） 中 （操作系统对写入文件的一个优化策略）真正的写入时机会交给系统去操作 这里就涉及到了如果系统出现宕机等问题 那么数据库则没有保证持久性 。此处可以设置刷盘策略的参数 innodb_flush_log_at_trx_commit ：</p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p>
<h4 id="UNDO日志"><a href="#UNDO日志" class="headerlink" title="UNDO日志"></a>UNDO日志</h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log 。 </p>
<h5 id="UNDO日志的理解"><a href="#UNDO日志的理解" class="headerlink" title="UNDO日志的理解"></a>UNDO日志的理解</h5><p>为了保证数据可以回滚到出现问题或执行事务失败之前的数据状态 使用undo日志记录事务开始前的一个数据状态</p>
<h5 id="UNDO日志的作用"><a href="#UNDO日志的作用" class="headerlink" title="UNDO日志的作用"></a>UNDO日志的作用</h5><p> 1.回滚 2.MVCC</p>
<h5 id="回滚段和undo页"><a href="#回滚段和undo页" class="headerlink" title="回滚段和undo页"></a>回滚段和undo页</h5><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了1024 个 undo log segment ，而在每个undo log segment段中进行 undo页 的申请。</p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 。</p>
<p>回滚段中的数据分类：</p>
<ol>
<li><p>未提交的回滚数据(uncommitted undo information) </p>
</li>
<li><p>已经提交但未过期的回滚数据(committed undo information) </p>
</li>
<li><p>事务已经提交并过期的数据(expired undo information)</p>
</li>
</ol>
<p>查看undo日志参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_undo%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525100351318.png" class="" title="image-20220525100351318">

<p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<p>1.将undo log放入列表中，以供之后的purge操作</p>
<p>2.判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
<p><strong>undo日志的类型</strong></p>
<p>1.insert undo log</p>
<p>2.update undo log</p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</p>
<img src="/2022/05/20/mysql/image-20220525101151835.png" class="" title="image-20220525101151835">



<p>undolog 回滚或回复数据库状态 并不是根据一开始的状态 把新数据进行update覆盖操作 而是生成一个undolog链表</p>
<p><strong>undo日志从对数据进行修改到回滚到事务执行之前的状态的过程：</strong></p>
<p>看一下compact数据行格式</p>
<img src="/2022/05/20/mysql/image-20220525101954686.png" class="" title="image-20220525101954686">

<ol>
<li><p>row_id:如果没有主键,unique的列,那么就会自动添加一个row_id行号.</p>
</li>
<li><p>trx_id:谁对该条记录最近一次修改就会记录某个事务的ID.</p>
</li>
<li><p>roll_pointer:一个指向该条记录修改对应的undo日志的指针.</p>
<p>开始修改事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into user(name) values (&#x27;tom&#x27;);</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102303992.jpg" class="" title="image-20220525102303992">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set name=&#x27;Sun&#x27; where id=1;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102439823.jpg" class="" title="image-20220525102439823"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set id=2 where id=1;//设置删除参数deletemark</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102725176.png" class="" title="image-20220525102725176">

<p>对于这个例子 如果回滚则rollback的流程如下:</p>
<ol>
<li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p>
</li>
<li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p>
</li>
<li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p>
</li>
<li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p>
</li>
</ol>
<p>针对于insert undo log：</p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>针对于update undo log ：</p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>事物的隔离性 通过锁来进行体现</p>
<h3 id="多用户访问数据操作"><a href="#多用户访问数据操作" class="headerlink" title="多用户访问数据操作"></a>多用户访问数据操作</h3><p>1.读-读操作</p>
<p>即并发事务相继读取相同位置数据内容，读数据本身对数据库不会有什么影响</p>
<p>2.写-写操作</p>
<p>在这种情况下可能会出现<strong>脏写</strong>的情况，任何隔离级别都不允许脏写的发生，所以在多个未提交事务相继对一条数据进行改动的时候，</p>
<p>首先会看看内存中有没有与这条记录相关联的锁结构，当没有的时候，就会在内存中生成一个锁结构与之关联。即一个事务对应一个锁结构。</p>
<p>事务T1对这条记录进行修改</p>
<img src="/2022/05/20/mysql/image-20220525144131876.png" class="" title="image-20220525144131876">

<p>事务T2同时想要修改这条记录</p>
<img src="/2022/05/20/mysql/image-20220525144355014.png" class="" title="image-20220525144355014">

<p>3.读-写 或 写-读</p>
<p>当一个事务进行数据读取操作，另一个事务进行改动操作，这种情况下可能发生<strong>脏读，不可重复读，幻读</strong>等问题</p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>1.MVCC 性能更高</p>
<p>2.读写都进行加锁的方式 性能较低</p>
<h3 id="Mysql中锁的不同种类"><a href="#Mysql中锁的不同种类" class="headerlink" title="Mysql中锁的不同种类"></a>Mysql中锁的不同种类</h3><img src="/2022/05/20/mysql/image-20220525145305850.png" class="" title="image-20220525145305850">

<h3 id="从操作类型分-读锁和写锁"><a href="#从操作类型分-读锁和写锁" class="headerlink" title="从操作类型分 读锁和写锁"></a>从操作类型分 读锁和写锁</h3><p>读锁：又称为共享锁，使用S表示，针对一份数据，多个事务同时进行不会进行阻塞，互相之间不会影响。</p>
<p>写锁：又称为排他锁，使用X表示，当前写操作没有完成之前，会阻断其他事务的读取和写入，这样只要会由一个事务进行操作。</p>
<h3 id="从操作数据的粒度上划分-表级锁，页级锁，行锁"><a href="#从操作数据的粒度上划分-表级锁，页级锁，行锁" class="headerlink" title="从操作数据的粒度上划分 表级锁，页级锁，行锁"></a>从操作数据的粒度上划分 表级锁，页级锁，行锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>1.表级别的X，S锁 </p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。</p>
<p>在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、</p>
<p>DELETE、UPDATE的语句会生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中</p>
<p>对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通在 server层 使用一种称之为 元数据锁 （英文名： Metadata Locks ，简称 MDL ）结构来实现的。</p>
<p>表锁的并发度太低 也分为表的写锁和读锁	：表共享读锁（Table Read Lock）                    表独占写锁（Table Write Lock） </p>
<img src="/2022/05/20/mysql/image-20220525151404962.png" class="" title="image-20220525151404962">

<p>2.意向锁</p>
<p>InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁 与 表级锁 共存，而<strong>意向锁</strong>就是其中的一种 表锁 。</p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 </span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>EX：开启一个事务 并向其中添加一条数据，在事务中查看意向锁：</p>
<img src="/2022/05/20/mysql/image-20220525152611363.png" class="" title="image-20220525152611363">



<p>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p>3.自增锁</p>
<p>4.元数据锁</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>1.记录锁（Record Locks）</p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。</p>
<p>仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<img src="/2022/05/20/mysql/image-20220525153413146.png" class="" title="image-20220525153413146">

<img src="/2022/05/20/mysql/image-20220525154333587.png" class="" title="image-20220525154333587">

<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。</p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</p>
</li>
</ul>
<p>2.<strong>间隙锁（Locks）</strong> </p>
<p><strong>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。</strong>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。</p>
<img src="/2022/05/20/mysql/image-20220525155754456.png" class="" title="image-20220525155754456">

<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<ul>
<li><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><img src="/2022/05/20/mysql/image-20220525160130933.png" class="" title="image-20220525160130933">

<ol>
<li>锁所在的事务信息 ：</li>
</ol>
<p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。此锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<ol start="2">
<li>索引信息 ：</li>
</ol>
<p>对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<ol start="3">
<li>表锁／行锁信息 ：</li>
</ol>
<p>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
<p>行锁：</p>
<p>记载了三个重要的信息：</p>
<p>Space ID ：记录所在表空间。</p>
<p>Page Number ：记录所在页号。</p>
<p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
<ol start="4">
<li>type_mode ：</li>
</ol>
<p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</p>
<img src="/2022/05/20/mysql/image-20220525160724571.png" class="" title="image-20220525160724571">

<p><strong>锁的模式（ lock_mode ）</strong>，占用低4位，可选的值如下：</p>
<p>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </p>
<p>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。 </p>
<p>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </p>
<p>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </p>
<p>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。 </p>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<p><strong>锁的类型（ lock_type ）</strong>，占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<p>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</p>
<p>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</p>
<p><strong>行锁的具体类型（ rec_lock_type ）</strong>，使用其余的位来表示。只有在 lock_type 的值为</p>
<p>   LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p>
<ul>
<li><p>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</p>
</li>
<li><p>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </p>
</li>
<li><p>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。</p>
</li>
<li><p>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。</p>
</li>
</ul>
<p>​      其他的类型：还有一些不常用的类型我们就不多说了。</p>
<p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：</p>
<p>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也就是当前事务尚未获取到锁，处在等待状态；</p>
<p>当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</p>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题</p>
<h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>mvcc（Multiversion Concurrency Control）是多版本并发控制，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。</p>
<p>换言之，<strong>就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</strong></p>
<p>普通的SELECT语句在<strong>READ COMMITTED和REPEATABLE READ</strong>隔离级别下会使用到<strong>MVCC读取记录</strong>：</p>
<ol>
<li><p>在 <strong>READ COMMITTED</strong> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就是避免了脏读现象；</p>
</li>
<li><p>在 <strong>REPEATABLE READ</strong> 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。</p>
</li>
</ol>
<h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ，非阻塞并发读 ，而这个读指的就是 <strong>快照读</strong> , 而非 <strong>当前读</strong> 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="存储函数与函数"><a href="#存储函数与函数" class="headerlink" title="存储函数与函数"></a>存储函数与函数</h2><h2 id="游标-，变量-，流程控制"><a href="#游标-，变量-，流程控制" class="headerlink" title="游标 ，变量 ，流程控制"></a>游标 ，变量 ，流程控制</h2><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>&#x2F;&#x2F;TODO</p>
<p><a href="https://zhuanlan.zhihu.com/p/265852739">SQL优化最干货总结 - MySQL（2020最新版） - 知乎 (zhihu.com)</a></p>
<h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><p>&#x2F;&#x2F;TODO</p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h1 id="MySQL常见问题"><a href="#MySQL常见问题" class="headerlink" title="MySQL常见问题"></a>MySQL常见问题</h1><p><a href="https://imysql.com/">iMySQL | 老叶茶馆 – Oracle MySQL ACE Director，专注MySQL</a></p>
<p><a href="https://mp.weixin.qq.com/s/5037NgbeJd69CAo_3snmrA">count(*)为什么会慢？ (qq.com)</a></p>
<h2 id="1、为什么-select-count-from-table，在-InnoDB-引擎中比-MyISAM-慢？"><a href="#1、为什么-select-count-from-table，在-InnoDB-引擎中比-MyISAM-慢？" class="headerlink" title="1、为什么 select count(*) from table，在 InnoDB 引擎中比 MyISAM 慢？"></a>1、为什么 select count(*) from table，在 InnoDB 引擎中比 MyISAM 慢？</h2><p>不一定。分两种情况。<br>1.如果在查询语句中带有where 条件的话。两种表的操作是一样的。<br>2.如果查询SQL语句不带有where 条件的话。MyISAM 比InnoDB 快。因为在MyISAM 引擎中把一张表的总行数存储在了磁盘上，查询的时候直接返回就行了。而InnoDB 需要全表扫描，计算总行数，所以慢。</p>
<p><strong>为什么 InnoDB不能和MyISAM一样呢？因为事务特性决定，多版本并发控制（MVCC）存在，导致不同时刻看到的结果是不一样的。</strong></p>
<p>count(*) 的具体实现是由存储引擎实现的，也就是说不同的存储引擎实现的方式不一样。</p>
<p>InnoDB和MyISAM 是我们常用的 MySQL 存储引擎，所以主要对比一下 count(*) 在 InnoDB 和 MyISAM 中的实现：</p>
<p>统计SQL不带where 条件时：<br>在MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select cout() from t 时，直接返回总数据的数量。<br>在InnoDB 存储引擎中，并没有存储总行数在磁盘上，当执行 select cout() from t 时，会先把数据读出来，一行一行的累加。最后返回总数量。</p>
<p>统计SQL带where 条件时：<br>都是一行一行累加。最后返回数量。</p>
<p><strong>InnoDB为什么不记录总行数到磁盘上？这和InnoDB的事务特性有关，由于多版本并发控制(MVCC)原因</strong>，InnoDB表在查询的时候“应该返回多少行”是不确定的。</p>
<p>不妨用一个例子来说明一下，假设现在 t 表中有 10000 条数据，现在有三个用户同时访问的会话：</p>
<p>会话 A 先启动事务并查询一次表的总行数。<br>会话 B 启动事务，插入一行后记录后，查询表的总行数。<br>会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。</p>
<img src="/2022/05/20/mysql/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNzk2MjM3,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p>假如从上到下是按照时间顺序执行的，同一行语句是在同一时间执行的。可以看出在最后时刻。三个回话返回的总行数不一样。<br>出现不一样的结果跟InnoDB存储引擎有关。<strong>在默认隔离级别 可重复读的情况下，通过多版本并发控制(MVCC)来实现，每一行记录都需要判断自己是否对这个会话可见，因此在统计总数量时，InnoDB引擎只有把数据一行一行的读取出来判断，只有当前会话可见才被统计进去。所以同一时刻不同会话查询到的数量就不一样。</strong><br><a href="https://blog.csdn.net/qq_20796237/article/details/105577415">(54条消息) InnoDB 引擎中 count(*)速度？_zhouyt6的博客-CSDN博客</a></p>
<h1 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h1><h3 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h3><p>跳过密码验证： 在mysql的my.cnf配置文件中的  [mysql Id]  下面添加这么一句话 就可以跳过密码验证 </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>

<p>直接登录</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure>

<p>登陆mysql后就可以修改密码了（针对mysql5.7）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> authentication_string=PASSWORD(&#x27;<span class="number">123456</span>&#x27;) where User=&#x27;root&#x27;; </span><br></pre></td></tr></table></figure>

<p>重新刷一下磁盘内容</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">flush privileges; </span><br></pre></td></tr></table></figure>


<p>然后改回my.cnf的 skip-grant-tables 是其变为注释或删除</p>
<p>然后重启mysql。</p>
<hr>
<p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<hr>
<p>查看引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<hr>
<p>查看默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<hr>
<p>创建表时指定存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改表的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<hr>
<p>查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名 \G;</span><br></pre></td></tr></table></figure>

<hr>
<p>开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">#或</span><br><span class="line">START transaction 添加的修饰符;（ READ ONLY） （ READ WRITE）</span><br></pre></td></tr></table></figure>

<hr>
<p>查看数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<hr>
<p>查看正在等待的锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<hr>
<p>根据查询到的锁 进行详情的查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br></pre></td></tr></table></figure>

<p>原文链接：</p>
<p><a href="https://blog.csdn.net/xfcy1990/article/details/90026089">(35条消息) 建索引的几大原则_烂笔头.的博客-CSDN博客_索引创建原则</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>yolov5</title>
    <url>/2023/05/09/yolov5%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="基于卷积神经网络的"><a href="#基于卷积神经网络的" class="headerlink" title="基于卷积神经网络的"></a>基于卷积神经网络的</h1><p>2022世界杯 法国vs摩洛哥</p>
<img src="/2023/05/09/yolov5%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/wps1-16847559295141.png" class="" title="img">

<img src="/2023/05/09/yolov5%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/wps2.jpg" class="" title="img">

<span id="more"></span>

<h2 id="识别目标在图片中的位置"><a href="#识别目标在图片中的位置" class="headerlink" title="识别目标在图片中的位置"></a>识别目标在图片中的位置</h2><p><a href="https://blog.csdn.net/weixin_47381639/article/details/123739115">(138条消息) yolov5获取边框坐标_yolov5输出预测框的坐标_我有个想法~不，你不想的博客-CSDN博客</a></p>
<p>在detect文件中 找到save_one_box方法 点进去进入到plots.py 在crop参数下添加输出</p>
<p>终端命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python detect.py --source data/images/ --weights ./yolov5s.pt --save-crop</span><br></pre></td></tr></table></figure>

<h2 id="识别指定位置的目标颜色"><a href="#识别指定位置的目标颜色" class="headerlink" title="识别指定位置的目标颜色"></a>识别指定位置的目标颜色</h2><p><a href="https://blog.csdn.net/qq_41895190/article/details/82791426">(138条消息) Python3 识别判断图片主要颜色，提取指定颜色的方法_python判断图片颜色_qq_41895190的博客-CSDN博客</a></p>
<h2 id="Train-py-文件的各个参数"><a href="#Train-py-文件的各个参数" class="headerlink" title="Train.py 文件的各个参数"></a>Train.py 文件的各个参数</h2><p><a href="https://blog.csdn.net/m0_61729640/article/details/126996027">(138条消息) YOLOv5 训练train参数解读_yolov5训练参数说明_车大划水冠军%的博客-CSDN博客</a></p>
<p>将队员分为两个队伍的思路</p>
<ol>
<li>获取正常的数据集 labels文件存放不分开的球员位置</li>
<li>获取labels文件的坐标位置 </li>
<li>将坐标位置转化为截图能识别的像素位置</li>
<li>截取所有目标队员 保存到文件夹中</li>
<li>根据文件夹中的截取的图品内容 识别出截取的球员颜色 </li>
<li>根据颜色进行分类 如果是白色 则在该txt文件中获取对应的坐标</li>
<li>修改这个坐标的分类为对应颜色球员</li>
<li>将更改过的labels内容进行train训练</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/15/vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h1 id="Vue的启动"><a href="#Vue的启动" class="headerlink" title="Vue的启动"></a>Vue的启动</h1><ol>
<li>初始化vue项目</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init vue@lastest</span><br></pre></td></tr></table></figure>

<p>运行项目</p>
<p>npm install</p>
<p>npm run dev</p>
]]></content>
  </entry>
  <entry>
    <title>中间件及容器管理</title>
    <url>/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20230416140654506.png" class="" title="image-20230416140654506">

<p>Sender拉取消息的两个条件只需要<strong>满足其中一个</strong>：</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv7rlicu.png" alt="img"></p>
<p><a href="https://docs.docker.com/get-started/overview/">Docker overview | Docker Documentation</a></p>
<h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><p>镜像</p>
<p>容器:容器是具体镜像文件的运行环境</p>
<p>仓库:集中存放镜像的地方</p>
<span id="more"></span>

<p>Docker 中 docker run命令到底干了什么？</p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220711204926292.png" class="" title="image-20220711204926292">

<h3 id="docker-的客户端-服务端"><a href="#docker-的客户端-服务端" class="headerlink" title="docker 的客户端 服务端"></a>docker 的客户端 服务端</h3><h3 id="为什么docker比Vmware快"><a href="#为什么docker比Vmware快" class="headerlink" title="为什么docker比Vmware快"></a>为什么docker比Vmware快</h3><p>docker时服用了宿主机操作系统的内核，而Vmware是宿主机的 </p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>docker 全部帮助命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">help</span> </span><br></pre></td></tr></table></figure>

<p>dokcer 加上指定命令 帮助提示参数</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>docker 所有本地镜像文件的信息 ()</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220713204827510.png" class="" title="image-20220713204827510">

<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220713204754241.png" class="" title="image-20220713204754241">

<p>如果不指定tag（版本号） 则自动拉去最新版镜像</p>
<p>拉取镜像</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker pull name</span><br></pre></td></tr></table></figure>



<p>查找远程hub仓库的镜像文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker search name</span><br></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>端口映射</p>
<p>从docker外部的端口 映射到docker内部的容器内部镜像的端口</p>
<p>启动交互式容器</p>
<p>docker的镜像pull到宿主机后 可以运行这个镜像并进行交互式操作</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it 镜像名称 /bin/bash</span><br></pre></td></tr></table></figure>

<p>也可以给镜像指定容器名称进行运行 不指定则直接碎金分配一个容器中运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --name=容器名 镜像名称 /bin/bash</span><br></pre></td></tr></table></figure>

<p>退出交互界面</p>
<p>① 退出镜像 容器停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<p>② 退出但是 容器不停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ctrl+q+p</span><br></pre></td></tr></table></figure>



<p>批量操作</p>
<p>批量删除容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure>



<p>停止容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>



<p>启动已经停止的容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">start</span> 容器ID</span><br></pre></td></tr></table></figure>



<p>启动守护式容器</p>
<p>大部分场景下 我们希望docker容器在后台运行 可以通过-d指定容器的后台模式</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu </span><br></pre></td></tr></table></figure>

<p>docker容器后台运行 就必须要有一个前台进程</p>
<p>容器运行的命令如果不是那些一直挂起的命令（比如top，tail） 就会自动退出</p>
<p>查看容器内部进程</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<p>重新进入正在运行的容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>

<p>使用attach 退出的时候 会导致容器停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>



<h3 id="docker-分层原理"><a href="#docker-分层原理" class="headerlink" title="docker 分层原理"></a>docker 分层原理</h3><h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><p>将整个容器进行备份</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker export 容器id &gt; 文件名.tar</span><br></pre></td></tr></table></figure>

<p>这个tar包就会在宿主机的内部存放</p>
<p>再将tar包转化为docker的镜像文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat 文件名.tar | docker import - 镜像文件包名/镜像名:镜像版本号</span><br></pre></td></tr></table></figure>

<p>docker内部就会存在这个镜像文件 就可以运行了</p>
<p>查看容器日志</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker logs 容器id </span><br></pre></td></tr></table></figure>



<p>Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层容器被加载到镜像的顶部，这一层通常被称为容器层 容器层之下的都是镜像层。</p>
<h4 id="制作本地镜像并将镜像进行提交"><a href="#制作本地镜像并将镜像进行提交" class="headerlink" title="制作本地镜像并将镜像进行提交"></a>制作本地镜像并将镜像进行提交</h4><p>docker commit 提交容器副本使之成为一个新的镜像</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者信息&quot; 容器ID 包名:标签名</span><br><span class="line">docker commit -m=&quot;带有vim的ubuntu&quot; -a=&quot;zsr&quot; 容器ID zsr:ubuntuTEST</span><br></pre></td></tr></table></figure>

<h3 id="docker-仓库"><a href="#docker-仓库" class="headerlink" title="docker 仓库"></a>docker 仓库</h3><p>开源则选择阿里云仓库 闭源可以选自私服仓库</p>
<h4 id="将镜像提交到阿里云以及操作总结"><a href="#将镜像提交到阿里云以及操作总结" class="headerlink" title="将镜像提交到阿里云以及操作总结"></a>将镜像提交到阿里云以及操作总结</h4><img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220715101912679.png" class="" title="image-20220715101912679">

<p>在阿里云开通个人镜像仓库 然后通过阿里云的脚本命令进行pull和push操作</p>
<p><a href="https://cr.console.aliyun.com/repository/cn-hangzhou/zsr_namespace_01/myubuntu1.3/details">容器镜像服务 (aliyun.com)</a></p>
<h5 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=悲伤豆角南瓜汤 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>您可以在访问凭证页面修改凭证密码。</p>
<h5 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h5 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=悲伤豆角南瓜汤 registry.cn-hangzhou.aliyuncs.com$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]$ docker push registry.cn-hangzhou.aliyuncs.com/zsr_namespace_01/myubuntu1.3:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<h4 id="将镜像添加到私服仓库"><a href="#将镜像添加到私服仓库" class="headerlink" title="将镜像添加到私服仓库"></a>将镜像添加到私服仓库</h4><p>首先将 镜像文件——registry pull到docker本地镜像 并在后台启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /shuaiqiwudi/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>



<p>然后将镜像放到私人仓库中</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker tag 镜像名称:版本号 开启registry机器的ip:对应端口号/存放该镜像的镜像名:设置版本</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p>当我们在docker上运行容器的时候 ，以防意外情况（容器小时，容器停止等）我们需要将容器的数据进行备份和管理。存储这些数据的介质就是所谓的<strong>容器数据卷</strong>，容器内的数据 <strong>备份+持久化—&gt;宿主机</strong> 的目录内。 </p>
<p><strong>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</strong></p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220718102537537.png" class="" title="image-20220718102537537">

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>



<p>在容器内部进行数据的更改或添加 宿主机磁盘内部也会随之更改 是实时的</p>
<p>在宿主机磁盘进行更改 在重新启动docker容器 其容器回自动加载新的磁盘文件</p>
<p>设置参数以 <strong>限制docker容器</strong> 在 宿主机的容器数据卷的 读写权限</p>
<p>读写均可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rm 镜像名</span><br></pre></td></tr></table></figure>

<p>只读不写</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>



<p>查看docker容器的详细信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h3 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes from 父类 --name 新名字 镜像名</span><br></pre></td></tr></table></figure>

<p>父类的容器进行更改的时候 在其挂载的子类下面也会随之更改。</p>
<h2 id="Docker-集群的搭建"><a href="#Docker-集群的搭建" class="headerlink" title="Docker 集群的搭建"></a>Docker 集群的搭建</h2><p>redis集群：哈希算法支持redis的信息存储</p>
<p>查看结点之间的关系和集群各个节点的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<h3 id="Docker-FIle"><a href="#Docker-FIle" class="headerlink" title="Docker FIle"></a>Docker FIle</h3><p>是用来构建镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本</p>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220720131638459.png" class="" title="image-20220720131638459">

<p>构建的三个步骤：</p>
<ol>
<li><p>编写Dockefile文件</p>
</li>
<li><p>docker build命令构建镜像</p>
</li>
<li><p>docke run 镜像</p>
</li>
</ol>
<img src="/2022/07/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/image-20220720132425854.png" class="" title="image-20220720132425854">



<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>docker compose是堆docker容器的管理项目，类似于spring容器对bean对象的管理，docker-compose.yml文件定义了所有docker容器的加载顺序等等，所以比如有业务需求的时候，需要固定的容器启动顺序，就是使用docker compose。</p>
<p>只需要</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker compose up</span><br></pre></td></tr></table></figure>

<p> 就可以运行docker-compose.yml定义好的所有docker容器，也简化了我们的操作内容。</p>
<p>使用docker compose也是让我们可以不指定固定ip地址 就可以访问服务。在jar包里的项目配置文件的固定ip地址写成容器的名称。</p>
<p>使用 Dockerfile 创建镜像。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像名称 .</span><br></pre></td></tr></table></figure>

<p>创建docker-compose.yml文件(案例)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">microService:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zzyy_docker:1.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6001:6001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/microService:/data</span></span><br><span class="line">    <span class="string">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="string">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0.8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span></span><br><span class="line">    <span class="string">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"> </span><br><span class="line"><span class="string">networks:</span> </span><br><span class="line">   <span class="string">atguigu_net:</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使docker-compose.yml 和 jar包在同一个文件夹</p>
<p>在docker-compose.yml 所在文件夹运行该命令<strong>查看编排文件是否正确</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker-compose config -q</span><br></pre></td></tr></table></figure>

<p>然后执行docker-compose 项目就会启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="Portainer-docker可视化管理工具"><a href="#Portainer-docker可视化管理工具" class="headerlink" title="Portainer docker可视化管理工具"></a>Portainer docker可视化管理工具</h2><p>Portianer是一款轻量级应用，提供了图形界面，方便我们管理docker环境，包括单机和集群环境。</p>
<p>下载命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">9000</span>:<span class="number">9000</span> --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data --name prtainer-libai portainer/portainer</span><br></pre></td></tr></table></figure>

<p>该命令使用的是9000端口映射 所以直接访问	ip:9000  就进入到登陆界面了。</p>
<h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1><p><a href="https://www.kubernetes.org.cn/k8s">Kubernetes（k8s）中文文档 Kubernetes概述_Kubernetes中文社区</a></p>
<p><a href="https://www.kubernetes.org.cn/"><strong>Kubernetes</strong></a>是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。</p>
<h2 id="三大核心组件"><a href="#三大核心组件" class="headerlink" title="三大核心组件"></a>三大核心组件</h2><h3 id="1-Pod"><a href="#1-Pod" class="headerlink" title="1.Pod"></a>1.Pod</h3><p>是K8s最小的数据单元；一组容器的集合；相互之间网络共享；短暂的生命周期</p>
<h3 id="2-Controller"><a href="#2-Controller" class="headerlink" title="2. Controller"></a>2. Controller</h3><p>确保预期的pod副本数量；可以分为有状态部署和无状态部署；确保所有的node运行同一个pod；一次性任务和定时任务</p>
<h3 id="3-Service"><a href="#3-Service" class="headerlink" title="3.Service"></a>3.Service</h3><p>定义一组pod的访问规则</p>
<h2 id="集群搭载方式"><a href="#集群搭载方式" class="headerlink" title="集群搭载方式"></a>集群搭载方式</h2><p>目前生产部署Kubernetes集群主要有两种方式</p>
<p>1.Kubeadm</p>
<p>Kubeadm是一个K8s部署工具 提供</p>
<p>2.二进制包</p>
]]></content>
      <categories>
        <category>项目环境搭建及中间件</category>
      </categories>
  </entry>
  <entry>
    <title>乐观锁和悲观锁</title>
    <url>/2022/05/17/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p><a href="https://zhuanlan.zhihu.com/p/95296289">摘自文章1</a></p>
<p>[摘自文章2](<a href="https://zhuanlan.zhihu.com/p/34556594">面试必问的CAS，你懂了吗？ - 知乎 (zhihu.com)</a>)</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<span id="more"></span>

<p><strong>乐观锁测试</strong></p>
<p>不使用乐观锁的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个例子很简单：我们定义了一个变量a，初始值是0，然后使用5个线程去增加，每个线程增加10，</span></span><br><span class="line"><span class="comment">    按道理来说5个线程一共增加了50，但是运行一下就知道答案不到50，原因就在于里面那个加一操作：</span></span><br><span class="line"><span class="comment">    a++;</span></span><br><span class="line"><span class="comment">    对于a++的操作，其实可以分解为3个步骤。</span></span><br><span class="line"><span class="comment">    （1）从主存中读取a的值</span></span><br><span class="line"><span class="comment">    （2）对a进行加1操作</span></span><br><span class="line"><span class="comment">    （3）把a重新刷新到主存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//一个变量a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//定义5个线程，每个线程加10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(a++);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。<br>​    AtomicInteger的作用就是为了保证原子性。如何保证原子性呢？我们使用案例说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="comment">//使用AtomicInteger定义a</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//使用getAndIncrement函数进行自增操作</span></span><br><span class="line">                        System.out.println(a.incrementAndGet());</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="comment">//CAS</span></span><br><span class="line">    <span class="comment">//getAndIncrement()实现的自增操作是自旋CAS操作：在循环中进行compareAndSet，如果执行成功则退出，否则一直执行。</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；</p>
<p>除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类。</p>
<p>下面看一下AtomicInteger的源码，了解下它的自增操作getAndIncrement()是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe是用来帮助Java访问操作系统底层资源的类（如可以分配内存、释放内存,在netty中大量用到它,属于C++层面的native方法,我们一般使用反射获取），通过Unsafe，Java具有了底层操作能力，可以提升运行效率；</p>
<p>valueOffset可以理解为value在内存中的偏移量，对应了CAS三个操作数(V&#x2F;A&#x2F;B)中的V；偏移量的获得也是通过Unsafe实现的。</p>
<h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><p>CAS操作包括了3个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)</li>
</ul>
<p>CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p>
<p>这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？</p>
<p>答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p>
<p>但是虽然保证将A值比较 然后转化为B值这一系列操作是原子性的 但是不能确定这个A值就是预期的A值 这就是ABA问题</p>
<p>ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</p>
<p>这时候就需要一个版本号来进行限制。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，</p>
<p>它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>其实大多是的乐观锁是由CAS+版本号进行实现的 但是通过版本号也可以实现乐观锁</p>
<p>和CAS大致思想相同 将想要更改的信息添加一个版本号 在对数据进行修改的时候 首先查询版本号 如果版本号相同 则继续操作修改数据 之后再将版本号加1（或者加其他数值，总之是修改版本号）</p>
<p><strong>乐观锁加锁了吗？</strong></p>
<p>1.乐观锁本身是不加锁的，只是在修改数据的时候，判断一下是不是已经被其他线程更新了。</p>
<p>2.有一些乐观锁是加锁合作的，为了保证整个查看版本修改数据然后修改版本的原子性操作，</p>
<p>但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。</p>
<p><strong>乐观锁带来的问题</strong></p>
<p>1.首当其冲的是性能问题，当CAS操作自旋访问的时候，执行getAndAddInt方法时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<p>2.安全问题，就是上述的ABA问题，”你以为身边的那么她还是她，其实她早变心了，已经不是以前的那个她了“。</p>
<p>3.共享，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修</p>
<p>改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲</p>
<p>观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观</p>
<p>锁，如 RetreenLock。</p>
<p>数据库中就经常使用悲观锁以保证数据的安全，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h3 id="悲观锁和乐观锁的使用场景"><a href="#悲观锁和乐观锁的使用场景" class="headerlink" title="悲观锁和乐观锁的使用场景"></a>悲观锁和乐观锁的使用场景</h3><p>乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。</p>
<ul>
<li><strong>功能限制 与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</strong></li>
</ul>
<p>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。</p>
<p>再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p>
<ul>
<li><strong>竞争激烈程度 如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</strong></li>
</ul>
<p>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</p>
<p>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>双重检验锁</title>
    <url>/2022/05/08/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81/</url>
    <content><![CDATA[<h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> TheClass theclass;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TheClass</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Track <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(TheClass.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">                    theclass=<span class="keyword">new</span> <span class="title class_">TheClass</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theclass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><span id="more"></span>

<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/20210710220330858.png" class="" title="img">

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是⽀持严格的ACID特性，⾼效，可靠，状态可以只在资源管理器中维护，⽽且应⽤编程模型简单，隔离的最⼩单位受限于资源管理器。</p>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>当事务由全局事务管理器进⾏全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的⼀致提交回滚。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>WEB服务⽆法同时满⾜⼀下3个属性：</p>
<p><strong>⼀致性(Consistency)</strong> ： ⼀致性是指多个副本之间能否保持⼀致的特性。在⼀致性的需求下，当⼀个系统在数据⼀致的状态下执⾏更新操作后，应该保证系统的数据仍然处理⼀致的状态。</p>
<p>数据⼀致性分为<strong>强⼀致性、弱⼀致性、最终⼀致性</strong>。</p>
<p>如果的确能像上⾯描述的那样时刻保证客户端看到的数据都是⼀致的，那么称之为强⼀致性。</p>
<p>如果允许存在中间状态，只要求经过⼀段时间后，数据最终是⼀致的，则称之为最终⼀致性。</p>
<p>此外，如果允许存在部分数据不⼀致，那么就称之为弱⼀致性。</p>
<p><strong>可⽤性(Availability)</strong> ： 系统提供的服务必须⼀直处于可⽤的状态，对于⽤户的每⼀个操作请求总是能够在有限的时间内返回结果。</p>
<p><strong>分区容错性(Partition tolerance)</strong> ： 即分布式系统在遇到任何⽹络分区故障时，仍然需要能够对外保证提供满⾜⼀致性或可⽤性的服务，除⾮是整个⽹络环境都发⽣了故障。</p>
<p>任何⼀个分布式系统都⽆法同时满⾜⼀致性、可⽤性和分区容错性，最多只能同时满⾜两项。在互联⽹领域的绝⼤多数的场景中，都需要<strong>牺牲强一致性来换取系统的高可用性</strong>，系统往往只需要保证最终⼀致性。<strong>所以只能在CP和AP之间进行抉择。</strong></p>
<h3 id="为什么C和A不可以同时存在？"><a href="#为什么C和A不可以同时存在？" class="headerlink" title="为什么C和A不可以同时存在？"></a>为什么C和A不可以同时存在？</h3><p>如果保证了⼀致性（C）：对于节点N1和N2，当往N1⾥写数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对N2进⾏读写请求，在N2被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可⽤性是相悖的。</p>
<p>如果保证了可⽤性（A）：那就不能暂停N2的读写操作，但同时N1在写数据的话，这就违背了⼀致性的要求。</p>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>CAP是分布式系统设计理论，BASE是CAP理论中<strong>AP⽅案</strong>的延伸，对于C我们采⽤的⽅式和策略就是保证最终⼀致性；</p>
<p><strong>Basically Available（基本可⽤）、Soft state（软状态）和Eventually consistent（最终⼀致性）</strong></p>
<p>BASE的三个短语的缩写。BASE基于CAP定理演化⽽来，核⼼思想是即时⽆法做到强⼀致性，但每个应⽤都可以根据⾃身业务特点，采⽤适当的⽅式来使系统达到最终⼀致性。</p>
<h3 id="Basically-Available（基本可⽤）"><a href="#Basically-Available（基本可⽤）" class="headerlink" title="Basically Available（基本可⽤）"></a><strong>Basically Available（基本可⽤）</strong></h3><p>基本可⽤是指分布式系统在出现不可预知的故障的时候，允许损失部分可⽤性，但不等于系统不可⽤</p>
<ol>
<li>响应时间上的损失：当出现故障时，响应时间增加</li>
<li>功能上的损失：当流量⾼峰期时，屏蔽⼀些功能的使⽤以保证系统稳定性（服务降级）</li>
</ol>
<h3 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h3><p>指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可⽤性。</p>
<p>即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可⽤性，即允许系统在不同节点的数据副本之间进⾏数据同步的过程存在延时。</p>
<h3 id="Eventually-consistent（最终⼀致性）"><a href="#Eventually-consistent（最终⼀致性）" class="headerlink" title="Eventually consistent（最终⼀致性）"></a>Eventually consistent（最终⼀致性）</h3><p>强调系统中所有的数据副本，在经过⼀段时间的同步后，最终能够达到⼀个⼀致的状态。其本质是需要系统保证最终数据能够达到⼀致，⽽不需要实时保证系统数据的强⼀致性。</p>
<p>最终⼀致性可分为如下⼏种：</p>
<p>（1）因果⼀致性（Causal consistency）</p>
<p>即进程A在更新完数据后通知进程B，那么之后进程B对该项数据的范围都是进程A更新后的最新值。 当流量⾼峰期时，屏蔽⼀些功能的使⽤以保证系统稳定性（服务降级）最终⼀致性可分为如下⼏种：</p>
<p>（2）读⼰之所写（Read your writes）</p>
<p>进程A更新⼀项数据后，它⾃⼰总是能访问到⾃⼰更新过的最新值。</p>
<p>（3）会话⼀致性（Session consistency）</p>
<p>将数据⼀致性框定在会话当中，在⼀个会话当中实现读⼰之所写的⼀致性。即执⾏更新后，客户端在同⼀个会话中始终能读到该项数据的最新值</p>
<p>（4）单调读⼀致性（Monotonic read consistency）</p>
<p>如果⼀个进程从系统中读取出⼀个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</p>
<p>（5）单调写⼀致性（Monotoic write consistency）</p>
<p>⼀个系统需要保证来⾃同⼀个进程的写操作被顺序执⾏。</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>为了使得基于分布式架构的所有节点可以在进⾏事务处理时能够保持原⼦性和⼀致性。绝⼤部分关系型数据库，都是基于2PC完成分布式的事务处理。</p>
<p>顾名思义，2PC分为两个阶段处理：</p>
<p>阶段⼀：提交事务请求<br>阶段⼆：执⾏事务提交; 如果阶段⼀超时或者出现异常，2PC的阶段⼆：中断事务</p>
<h3 id="阶段⼀：提交事务请求"><a href="#阶段⼀：提交事务请求" class="headerlink" title="阶段⼀：提交事务请求"></a><strong>阶段⼀：提交事务请求</strong></h3><ol>
<li><p>事务询问。协调者向所有参与者发送事务内容，询问是否可以执⾏提交操作，并开始等待各参与者进⾏响应；</p>
</li>
<li><p>执⾏事务。各参与者节点，执⾏事务操作，并将Undo和Redo操作计⼊本机事务⽇志；</p>
</li>
<li><p>各参与者向协调者反馈事务问询的响应。成功执⾏返回Yes，否则返回No</p>
</li>
</ol>
<h3 id="阶段⼆：执⾏事务提交"><a href="#阶段⼆：执⾏事务提交" class="headerlink" title="阶段⼆：执⾏事务提交"></a><strong>阶段⼆：执⾏事务提交</strong></h3><p>协调者在阶段⼆决定是否最终执⾏事务提交操作。这⼀阶段包含两种情形：</p>
<h4 id="执⾏事务提交"><a href="#执⾏事务提交" class="headerlink" title="执⾏事务提交"></a><strong>执⾏事务提交</strong></h4><p>所有参与者reply Yes，那么执⾏事务提交。</p>
<ol>
<li><p>发送提交请求。协调者向所有参与者发送Commit请求；</p>
</li>
<li><p>事务提交。参与者收到Commit请求后，会<strong>正式执⾏事务提交操作</strong>，并在完成提交操作之后，释放在整个事务执⾏期间占⽤的资源；</p>
</li>
<li><p>反馈事务提交结果。参与者在完成事务提交后，写协调者发送Ack消息确认；</p>
</li>
<li><p>完成事务。协调者在收到所有参与者的Ack后，完成事务。</p>
</li>
</ol>
<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/692462-20190407131001597-1193625164.png" class="" title="img">

<h3 id="阶段⼆：中断事务"><a href="#阶段⼆：中断事务" class="headerlink" title="阶段⼆：中断事务"></a><strong>阶段⼆：中断事务</strong></h3><p>事情总会出现意外，当存在某⼀参与者向协调者发送No响应，或者等待超时。协调者只要⽆法收到所有参与者的Yes响应，就会中断事务。</p>
<ol>
<li><p>发送回滚请求。协调者向所有参与者发送Rollback请求；</p>
</li>
<li><p>回滚。参与者收到请求后，利⽤本机Undo信息，执⾏Rollback操作。并在回滚结束后释放该事务所占⽤的系统资源；</p>
</li>
<li><p>反馈回滚结果。参与者在完成回滚操作后，向协调者发送Ack消息；</p>
</li>
<li><p>中断事务。协调者收到所有参与者的回滚Ack消息后，完成事务中断</p>
</li>
</ol>
<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/692462-20190407131017854-1201369651.png" class="" title="img">

<h3 id="关于2PC"><a href="#关于2PC" class="headerlink" title="关于2PC"></a>关于2PC</h3><p>两阶段提交在处理分布式事务时分为两个阶段：voting（投票阶段，有的地⽅会叫做prepare阶段）和commit阶段。2pc中存在两个⻆⾊，<strong>事务协调者</strong>（seata、atomikos、lcn（都是些框架））和<strong>事务参与者</strong>，事务参与者通常是指应⽤的数据库。</p>
<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1c2VkZXhpbmdmdQ==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h3 id="2PC优缺点"><a href="#2PC优缺点" class="headerlink" title="2PC优缺点"></a>2PC优缺点</h3><p>优点主要体现在实现原理简单；</p>
<p>缺点⽐较多：</p>
<p>2PC的提交在执⾏过程中，所有参与事务操作的逻辑都处于阻塞状态，也就是说，各个参与者都在等待其他参与者响应，⽆法进⾏其他操作；</p>
<p>协调者是个单点，⼀旦出现问题，其他参与者将⽆法释放事务资源，也⽆法完成事务操作；</p>
<p>数据不⼀致。当执⾏事务提交过程中，如果协调者向所有参与者发送Commit请求后，发⽣局部⽹络异常或者协调者在尚未发送完Commit请求，即出现崩溃，最终导致只有部分参与者收到、执⾏请求。于是整个系统将会出现数据不⼀致的情形；</p>
<p>效率保守。2PC没有完善的容错机制，当参与者出现故障时，协调者⽆法快速得知这⼀失败，只能严格依赖超时设置来决定是否进⼀步的执⾏提交还是中断事务</p>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>针对2PC的缺点，研究者提出了3PC，即Three-Phase Commit。</p>
<p>作为2PC的改进版，3PC将原有的两阶段过程，重新划分为<strong>can_commit，pre_commit，do_commit</strong>三个阶段。</p>
<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/692462-20190407142856081-1418301502.png" class="" title="img">



<p><strong>阶段⼀：CanCommit</strong></p>
<ol>
<li><p>事务询问。协调者向所有参与者发送包含事务内容的canCommit的请求，询问是否可以执⾏事务提交，并等待应答；</p>
</li>
<li><p>各参与者反馈事务询问。正常情况下，如果参与者认为可以顺利执⾏事务，则返回Yes，否则返回No。</p>
</li>
</ol>
<p><strong>阶段⼆：PreCommit</strong></p>
<p>在本阶段，协调者会根据上⼀阶段的反馈情况来决定是否可以执⾏事务的PreCommit操作。有以下两种可能：</p>
<p><strong>执⾏事务预提交</strong></p>
<ol>
<li><p>发送预提交请求。协调者向所有节点发出PreCommit请求，并进⼊prepared阶段；</p>
</li>
<li><p>事务预提交。参与者收到PreCommit请求后，会执⾏事务操作，并将Undo和Redo⽇志写⼊本机事务⽇志；</p>
</li>
<li><p>各参与者成功执⾏事务操作，同时将反馈以Ack响应形式发送给协调者，同事等待最终的Commit或Abort指令。</p>
</li>
</ol>
<p><strong>中断事务</strong></p>
<p>加⼊任意⼀个参与者向协调者发送No响应，或者等待超时，协调者在没有得到所有参与者响应时，即可以中断事务：</p>
<ol>
<li><p>发送中断请求。 协调者向所有参与者发送Abort请求；</p>
</li>
<li><p>中断事务。⽆论是收到协调者的Abort请求，还是等待协调者请求过程中出现超时，参与者都会中断事务；</p>
</li>
</ol>
<p><strong>阶段三：doCommit</strong></p>
<p>在这个阶段，会真正的进⾏事务提交，同样存在两种可能。</p>
<p><strong>执⾏提交</strong></p>
<ol>
<li><p>发送提交请求。假如协调者收到了所有参与者的Ack响应，那么将从预提交转换到提交状态，并向所有参与者，发送doCommit请求；</p>
</li>
<li><p>事务提交。参与者收到doCommit请求后，会正式执⾏事务提交操作，并在完成提交操作后释放占⽤资源；</p>
</li>
<li><p>反馈事务提交结果。参与者将在完成事务提交后，向协调者发送Ack消息；</p>
</li>
<li><p>完成事务。协调者接收到所有参与者的Ack消息后，完成事务。</p>
</li>
</ol>
<p><strong>中断事务</strong>在该阶段，假设正常状态的协调者接收到任⼀个参与者发送的No响应，或在超时时间内，仍旧没收到反馈消息，就会中断事务：</p>
<ol>
<li><p>发送中断请求。协调者向所有的参与者发送abort请求；</p>
</li>
<li><p>事务回滚。参与者收到abort请求后，会利⽤阶段⼆中的Undo消息执⾏事务回滚，并在完成回滚后释放占⽤资源；</p>
</li>
<li><p>反馈事务回滚结果。参与者在完成回滚后向协调者发送Ack消息；</p>
</li>
<li><p>中端事务。协调者接收到所有参与者反馈的Ack消息后，完成事务中断。</p>
</li>
</ol>
<img src="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1c2VkZXhpbmdmdQ==,size_16,color_FFFFFF,t_70-16816948943496.png" class="" title="img">

<p>在doCommit阶段，如果参与者⽆法及时接收到来⾃协调者的doCommit或者abort请求时，会在等待超时之后，继续进⾏事务的提交。（其实这个应该是基于概率来决定的，当进⼊第三阶段时，说明参与者在第⼆阶段已经收到了PreCommit请求，那么协调者产⽣PreCommit请求的前提条件是他在第⼆阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（⼀旦参与者收到了PreCommit，意味他知道⼤家其实都同意修改了）所以，⼀句话概括就是，当进⼊第三阶段时， <strong>由于⽹络超时等原因，虽然参与者<strong><strong>没有收到</strong></strong>commit<strong><strong>或者</strong></strong>abort<strong><strong>响应，但是他有理由相信：成功提交的⼏率很</strong></strong>⼤</strong>。 ）</p>
<h3 id="2PC和3PC的区别："><a href="#2PC和3PC的区别：" class="headerlink" title="2PC和3PC的区别："></a><strong>2PC</strong>和3PC的区别：</h3><p>三阶段提交协议在协调者和参与者中都引⼊ <strong>超时机制</strong>，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。</p>
<p>3PC有效降低了2PC带来的参与者阻塞范围，并且能够在出现单点故障后继续达成⼀致；但3PC带来了新的问题，在参与者收到preCommit消息后，如果⽹络出现分区，协调者和参与者⽆法进⾏后续的通信，这种情况下，参与者在等待超时后，依旧会执⾏事务提交，这样会导致数据的不⼀致。</p>
<h3 id="“3PC相对于2PC⽽⾔到底优化了什么地⽅呢-”"><a href="#“3PC相对于2PC⽽⾔到底优化了什么地⽅呢-”" class="headerlink" title="“3PC相对于2PC⽽⾔到底优化了什么地⽅呢?”"></a><strong>“3PC相对于2PC⽽⾔到底优化了什么地⽅呢?”</strong></h3><p>相⽐较2PC⽽⾔，3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，⽽2PC只有协调者才拥有超时机制。这解决了⼀个什么问题呢？这个优化点，主要是避免了参与者在⻓时间⽆法与协调者节点通讯（协调者挂掉了）的情况下，⽆法释放资源的问题，因为参与者⾃身拥有超时机制会在超时后，⾃动进⾏本地commit从⽽进⾏释放资源。⽽这种机制也侧⾯降低了整个事务的阻塞时间和范围。</p>
<p>另外，通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC⽽⾔，多设置了⼀个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是⼀致的。以上就是3PC相对于2PC的⼀个提⾼（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不⼀致的问题。假如在 DoCommit过程，参与者A⽆法接收协调者的通信，那么参与者A会⾃动提交，但是提交失败了，其他参与者成功了，此时数据就会不⼀致。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java的多线程和并发"><a href="#Java的多线程和并发" class="headerlink" title="Java的多线程和并发"></a>Java的多线程和并发</h1><p>java的尽头是服务开发，既然是服务开发，就需要保证为多个用户同时进行服务，那么如何保证资源的正常分配或每个用户正常的体验呢？</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>程序（program）</strong></p>
<p>程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码（还没有运行起来），静态对象。</p>
<p><strong>进程（process）</strong></p>
<p>进程是程序的一次执行过程，也就是说程序运行起来了，加载到了内存中，并占用了cpu的资源。这是一个动态的过程：有自身的产生、存在和消亡的过程，这也是进程的生命周期。</p>
<p>进程是系统资源分配的单位，系统在运行时会为<strong>每个进程分配不同的内存区域</strong>。</p>
<p>进程与程序的区别是：1、进程是<strong>动态</strong>的，而程序是<strong>静态</strong>的；2、进程有一定的生命期，而程序是指令的集合，程序本身没有生命期。</p>
<p><strong>线程（thread）</strong></p>
<p>进程可进一步细化为线程，是一个程序内部的执行路径。</p>
<p>若一个进程同一时间并行执行多个线程，那么这个进程就是支持多线程的。</p>
<p>线程是cpu调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。</p>
<p>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间——&gt; 他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得相互间通信更简便、高效。但<strong>多个线程操作共享的系统资源可能就会带来安全隐患</strong>（隐患为到底哪个线程操作这个数据，可能一个线程正在操作这个数据，有一个线程也来操作了这个数据）。</p>
<p><strong>CPU单核和多核的理解</strong></p>
<p><strong>单核</strong>的CPU是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。同时间段内有多个线程需要CPU去运行时，CPU也只能交替去执行多个线程中的一个线程，但是由于其执行速度特别快，因此感觉不出来。</p>
<p><strong>多核</strong>的CPU才能更好的发挥多线程的效率。</p>
<p>对于<strong>Java</strong>应用程序java.exe来讲，至少会存在三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。如过发生异常时会影响主线程。</p>
<p><strong>并行</strong>：多个cpu同时执行多个任务。比如，多个人做不同的事。</p>
<p><strong>并发</strong>：一个cpu（采用时间片）同时执行多个任务。比如，一个人在不同的时间做不同的事情。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220530172524328.png" class="" title="image-20220530172524328">

<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230530102433282.png" class="" title="image-20230530102433282">

<h1 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h1><h2 id="1-多线程实现的原理"><a href="#1-多线程实现的原理" class="headerlink" title="1. 多线程实现的原理"></a>1. 多线程实现的原理</h2><ul>
<li>Java语言的JVM允许程序运行多个线程，多线程可以通过Java中的java.lang.Thread类来体现。</li>
<li>Thread类的特性<ul>
<li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。</li>
<li>通过Thread方法的start()方法来启动这个线程，而非直接调用run()。</li>
</ul>
</li>
</ul>
<h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h2><p>​		线程的创建有很多种方式：</p>
<p>1.继承Thread类 重写run()方法</p>
<p>2.实现Runnable接口 重写run()方法</p>
<p>3.使用Callable和Future创建线程</p>
<p>4.使用线程池例如用Executor框架</p>
<h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1) 继承Thread类"></a>1) 继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">//继承Thread类 重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何开启</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread1</span>.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在方法中定义一个匿名线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;<span class="comment">//调用该方法即可启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="2）实现Runnable接口"><a href="#2）实现Runnable接口" class="headerlink" title="2）实现Runnable接口"></a>2）实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现接口 实现run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3) 线程池"></a>3) 线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        指定创建的线程池数</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//代表线程总个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//代表线程执行次数</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p><strong>线程池的本质：</strong></p>
<p>通过调用方法，实际上调用线程工厂，实际上也是使用第一种方式创建线程，指定创建的线程数，这里首先在方法中设定静态属性值，然后 Executors.defaultThreadFactory()创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//核心池大小</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,//最大池大小 ；两者相等</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">       DefaultThreadFactory() &#123;</span><br><span class="line">           <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">           group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                 Thread.currentThread().getThreadGroup();</span><br><span class="line">           namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                         poolNumber.getAndIncrement() +</span><br><span class="line">                        <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                 namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                 <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">               t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">               t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过源码发现，我们通过 <code>DefaultThreadFactory</code> 线程工厂来创建的。它可以设置线程的一些属性，比如：是否守护线程、优先级、线程名、等等，而创建线程使用newThread()方法，实际上也是new Thread()构造方法创建线程。</p>
<h3 id="4）实现Callable-接口"><a href="#4）实现Callable-接口" class="headerlink" title="4）实现Callable 接口"></a>4）实现Callable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这是就需要用到 Callable 接口。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Thread4</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//重写call()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">        <span class="comment">//方法一：使用线程池</span></span><br><span class="line">        <span class="comment">//1.创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    	<span class="comment">// 2、提交任务，并用 Future提交返回结果</span></span><br><span class="line">    	Future&lt; Integer &gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法二：使用FutureTask 实现类的支持</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Thread4</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread4</span>();</span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(td);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();  <span class="comment">//FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Callable和Runnable类似，区别在于Runnable是没有返回值的，<strong>它们的本质都是定义线程要做的任务（call 或 run 方法里面的逻辑），而不是说他们本身就是线程</strong>。但无论有无返回值，它们都是需要被线程执行。</p>
<p>Callable可以提交到线程池执行，通过 sumbit 方法提交。</p>
<h3 id="创建线程方式总结："><a href="#创建线程方式总结：" class="headerlink" title="创建线程方式总结："></a>创建线程方式总结：</h3><p>Thread类的run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么多创建线程方式，实际上的创建线程只有一种方式，就是继承Thread类,而Thread实际上也是实现了Runnable接口，而<strong>Runnable接口，实际上是定义了一个线程的任务阶段的执行内容，并不是创建了一个完整的线程的生命周期（从新建到死亡）</strong>，而run()方法，就是执行的内容，可Runnable方式，它启动线程还是需要调用 start 方法（因为是 Native 方法我们看不到具体逻辑）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(Runnable target).start()</span><br></pre></td></tr></table></figure>

<p>所以，当我们使用Thread类去重写run()方法的时候，才是创建一个线程的完整生命周期。</p>
<h2 id="3-线程停止的方式"><a href="#3-线程停止的方式" class="headerlink" title="3. 线程停止的方式"></a>3. 线程停止的方式</h2><p>线程结束的方式很多，最常用的就是<strong>run方法结束</strong>，无论是return结束，还是抛异常结束</p>
<p><strong>interrupt方式：</strong></p>
<p>线程内部的变量，线程标记位 interrupt	默认值false（未被打断） </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        thread.interrupt();</span><br></pre></td></tr></table></figure>

<p>线程休眠期间，如果修改标记位为true，那么就会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//异常</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-sleep-和wait-的区别"><a href="#4-sleep-和wait-的区别" class="headerlink" title="4. sleep()和wait()的区别"></a>4. sleep()和wait()的区别</h2><ol>
<li>sleep是Thread类中的static方法，wait是Object类的方法</li>
<li>sleep属于Time_wait 会自动唤醒 wait需要手动唤醒</li>
<li>sleep可以在持有锁或者不持有锁的情况下执行，wait必须在持有锁的情况下执行。（wait实际上的操作本质是：在synchronized将持有锁的线程 在ObjectMonitor对象中将owner扔到WaitSet集合中）</li>
</ol>
<h1 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h1><p>多线程往往会比单线程更快，更能够提高并发，但提高并发并不意味着启动更多的线程来执行。更多的线程意味着线程创建销毁开销加大、上下文非常频繁。</p>
<h3 id="不同的上下文切换"><a href="#不同的上下文切换" class="headerlink" title="不同的上下文切换"></a>不同的<strong>上下文切换</strong></h3><ul>
<li>线程切换，同一进程中的两个线程之间的切换</li>
<li>进程切换，两个进程之间的切换</li>
<li>模式切换，在给定线程中，用户模式和内核模式的切换</li>
<li>地址空间切换，将虚拟内存切换到物理内存</li>
</ul>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>上下文切换会导致额外的开销，常常表现为高并发执行时速度会慢串行，因此减少上下文切换次数便可以提高多线程程序的运行效率。</p>
<p><strong>直接消耗</strong>：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉<br><strong>间接消耗</strong>指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小</p>
<h2 id="上下文切换分类"><a href="#上下文切换分类" class="headerlink" title="上下文切换分类"></a><strong>上下文切换分类</strong></h2><p>（1）协同式调度：<br>    指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e2478f1e9aa474280f0b36727819732b.png" alt="img"></p>
<p>（2)抢占式调度:<br>指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p>
<p>java使用的线程调使用抢占式调度，Java中线程会按优先级分配CPU时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/97b36b8b157c2a6eb5e7f4eccc1238f4.png" alt="img"></p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><ol>
<li>newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool 创建一个<strong>定时线程池</strong>，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor 创建一个<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO,LIFO, 优先级)执行。</li>
</ol>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20190423104753143.png" class="" title="img">

<ol>
<li>corePoolSize 线程池<strong>核心线程大小</strong></li>
</ol>
<p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p>
<ol start="2">
<li>maximumPoolSize 线程池<strong>最大线程数量</strong></li>
</ol>
<p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</p>
<ol start="3">
<li>keepAliveTime <strong>空闲线程存活时间</strong></li>
</ol>
<p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</p>
<ol start="4">
<li>unit 空闲线程存活时间单位</li>
</ol>
<p>keepAliveTime的计量单位</p>
<ol start="5">
<li>workQueue 工作队列</li>
</ol>
<p>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>
<p>①ArrayBlockingQueue</p>
<p>基于数组的<strong>有界阻塞</strong>队列，按<strong>FIFO</strong>排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
<p>②LinkedBlockingQuene</p>
<p>基于链表的<strong>无界阻塞</strong>队列（其实最大容量为Interger.MAX），按照<strong>FIFO</strong>排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
<p>③SynchronousQuene</p>
<p>一个<strong>不缓存任务</strong>的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
<p>④PriorityBlockingQueue</p>
<p>具有<strong>优先级的无界阻塞队列</strong>，优先级通过参数Comparator实现。</p>
<ol start="6">
<li>threadFactory <strong>线程工厂</strong></li>
</ol>
<p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
<ol start="7">
<li>handler <strong>拒绝策略</strong></li>
</ol>
<p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：<br>①CallerRunsPolicy</p>
<p>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。</p>
<p>②AbortPolicy</p>
<p>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。</p>
<p>③DiscardPolicy</p>
<p>该策略下，直接丢弃任务，什么都不做。</p>
<p>④DiscardOldestPolicy</p>
<p>该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p>
<h1 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h1><p>当多个线程进行并发执行时，为了资源相互之间的抢占和确保资源分配的可靠，就衍生出了很多解决问题的办法。那么如果想解决问题，就得知道问题是如何出现的，这样问题就解决了一半，那么并发问题是如何产生的呢？下面一个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadStudy01</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TestThreadStudy01</span> <span class="variable">testThreadStudy01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThreadStudy01</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Th1</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Th1</span>();</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="type">Th2</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Th2</span>();</span><br><span class="line">        th2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Th1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (TestThreadStudy01.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TestThreadStudy01.count--;</span><br><span class="line">                System.out.println(TestThreadStudy01.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Th2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//模拟并发</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TestThreadStudy01.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TestThreadStudy01.count--;</span><br><span class="line">                System.out.println(TestThreadStudy01.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个静态变量为count，然后两个线程去共享消耗，然后模拟并发的场景，我们发现，会出现操作同一变量的情况。</p>
<details>   
    <summary>查看运行结果</summary>   
    <pre>
    <code>
结束
count=100
99
98
97
96
95
94
93
93
92
91
90
90
89
88
87
86
85
85
84
84
83
83
82
82
80
81
79
79
78
77
76
76
75
74
73
73
72
71
70
69
68
67
66
65
64
63
61
61
59
60
58
58
57
56
54
55
53
52
51
51
50
50
49
49
48
47
46
45
44
43
42
42
41
41
40
39
38
37
36
36
35
34
33
32
31
31
30
29
28
27
26
26
25
24
23
22
21
21
20
20
19
19
18
18
17
16
15
14
13
12
11
11
10
9
8
7
6
6
5
4
3
3
1
2
0
0  
    </code>
    </pre> 
</details>

<p>出现这样的问题是绝对不允许的，那么我们该如何解决呢？</p>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全 - 如果线程执行过程中不会产生共享资源的冲突，则线程安全。</p>
<p>线程不安全 - 如果有多个线程同时在操作主内存中的变量，则线程不安全。</p>
<h2 id="为什么会出现线程不安全问题？"><a href="#为什么会出现线程不安全问题？" class="headerlink" title="为什么会出现线程不安全问题？"></a>为什么会出现线程不安全问题？</h2><ul>
<li>不满足原子性：一个或者多个操作在 CPU 执行的过程中被中断</li>
<li>不满足可见性：一个线程对共享变量的修改，另外一个线程不能立刻看到</li>
<li>不满足有序性：程序执行的顺序没有按照代码的先后顺序执行</li>
</ul>
<h2 id="原子性解决"><a href="#原子性解决" class="headerlink" title="原子性解决"></a>原子性解决</h2><ol>
<li>synchronized</li>
<li>CAS</li>
<li>Lock锁</li>
<li>ThreadLocal</li>
</ol>
<h2 id="可见性解决"><a href="#可见性解决" class="headerlink" title="可见性解决"></a>可见性解决</h2><ol>
<li>volatile</li>
<li>synchronized</li>
<li>Lock</li>
<li>final</li>
</ol>
<h2 id="有序性解决"><a href="#有序性解决" class="headerlink" title="有序性解决"></a>有序性解决</h2><ol>
<li>volatile</li>
</ol>
<h2 id="实现线程安全的几种方式"><a href="#实现线程安全的几种方式" class="headerlink" title="实现线程安全的几种方式"></a>实现线程安全的几种方式</h2><p><strong>1.互斥同步锁（悲观锁）</strong></p>
<p>1）Synchorized</p>
<p>2）ReentrantLock</p>
<p>互斥同步锁也叫做阻塞同步锁，特征是会对没有获取锁的线程进行阻塞。要理解互斥同步锁，首选要明白什么是互斥什么是同步。简单的说互斥就是非你即我，同步就是顺序访问。互斥同步锁就是以互斥的手段达到顺序访问的目的。操作系统提供了很多互斥机制比如信号量，互斥量，临界区资源等来控制在某一个时刻只能有一个或者一组线程访问同一个资源。Java里面的互斥同步锁就是Synchorized和ReentrantLock，前者是由语言级别实现的互斥同步锁，理解和写法简单但是机制笨拙，在JDK6之后性能优化大幅提升，即使在竞争激烈的情况下也能保持一个和ReentrantLock相差不多的性能，所以JDK6之后的程序选择不应该再因为性能问题而放弃synchorized。</p>
<p>ReentrantLock是API层面的互斥同步锁，需要程序自己打开并在finally中关闭锁，和synchorized相比更加的灵活，体现在三个方面：等待可中断，公平锁以及绑定多个条件。但是如果程序猿对ReentrantLock理解不够深刻，或者忘记释放lock，那么不仅不会提升性能反而会带来额外的问题。另外synchorized是JVM实现的，可以通过监控工具来监控锁的状态，遇到异常JVM会自动释放掉锁。而ReentrantLock必须由程序主动的释放锁。</p>
<p>互斥同步锁都是可重入锁，好处是可以保证不会死锁。但是因为涉及到核心态和用户态的切换，因此比较消耗性能。JVM开发团队在JDK5-JDK6升级过程中采用很多锁优化机制来优化同步无竞争情况下锁的性能。比如：<strong>自旋锁和适应性自旋锁，轻量级锁，偏向锁，锁粗化和锁消除。</strong></p>
<p><strong>2.非阻塞同步锁（乐观锁）</strong></p>
<ol>
<li>原子类（CAS）</li>
</ol>
<p>非阻塞同步锁也叫乐观锁，相比悲观锁来说，它会先进行资源在工作内存中的更新，然后根据与主存中旧值的对比来确定在此期间是否有其他线程对共享资源进行了更新，如果旧值与期望值相同，就认为没有更新，可以把新值写回内存，否则就一直重试直到成功。它的实现方式依赖于处理器的机器指令：</p>
<p>CAS（Compare And Swap）</p>
<p>JUC中提供了几个Automic类以及每个类上的原子操作就是乐观锁机制不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p>
<p>非阻塞锁是不可重入的，否则会造成死锁。</p>
<p><strong>3.无同步方案</strong></p>
<p>1）可重入代码</p>
<p>在执行的任何时刻都可以中断-重入执行而不会产生冲突。特点就是不会依赖堆上的共享资源</p>
<p>2）ThreadLocal&#x2F;Volaitile</p>
<p>线程本地的变量，每个线程获取一份共享变量的拷贝，单独进行处理。</p>
<p>3）线程本地存储</p>
<p>如果一个共享资源一定要被多线程共享，可以尽量让一个线程完成所有的处理操作，比如生产者消费者模式中，一般会让一个消费者完成对队列上资源的消费。典型的应用是基于请求-应答模式的web服务器的设计。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>&#x2F;&#x2F;TODO</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p><a href="https://www.jianshu.com/p/f1f2cd289205?u_atoken=2aade26c-0edd-4aac-92ee-13128f0ba48b&u_asession=01LBHAYdN2EbrzUUFkkscGKIdGt13vnsP1voCwrqIjS6-wk7J6XMstjWp7vtr3KKZxX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K-MgPPhx3K_RlPe0mOWiRUAPMqDvQo0pEVbhSjSW3HVJmBkFo3NEHBv0PZUm6pbxQU&u_asig=0544d1nAGeRC20Zu086zLa48E-1MtIp0Lyx__jKg1odIUXCV6dnY7RQFKe3pXZCxT8szM6hqH8lqN42cHePjTQKtLKJGWWv_PWI5VneZPX10NEZmkXYPGkubytG1DaeIe69-GV8SBhz_OE0dMzJBo5LtR1_BhmVhmWE9ThVV4hydP9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzffXTnRuyn-0adgZFi3xA6ml9WJJAeUNrNHQBDY4eEMIOF33MttdlYrQH7V14NMYIe3h9VXwMyh6PgyDIVSG1W8WSpGuwu1JqIkteEJQgXFedE0UI5VVl-pTG1AR4XnM0J_l2nrcFvKdd8T3sApcUCf6SaCCARuuOnHU9owlht4omWspDxyAEEo4kbsryBKb9Q&u_aref=Yo8Swf4AoUV5N4Y58m1jtOPUlJY=">LockSupport的用法及原理 - 简书 (jianshu.com)</a></p>
<h1 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h1><h2 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a>相似点</h2><p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
<h2 id="功能区别："><a href="#功能区别：" class="headerlink" title="功能区别："></a>功能区别：</h2><p>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p>
<p>ReentrantLock类提供了一些高级功能，主要有以下3项：</p>
<p>①等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。</p>
<p>②公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p>
<p>③锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>
<h2 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h2><p>很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<h2 id="性能的区别："><a href="#性能的区别：" class="headerlink" title="性能的区别："></a>性能的区别：</h2><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>Synchorized和ReentrantLock的性能比较</p>
<h3 id="关于Synchorized的锁升级"><a href="#关于Synchorized的锁升级" class="headerlink" title="关于Synchorized的锁升级"></a>关于Synchorized的锁升级</h3><p>synchronized的锁升级，说白了，就是当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级。<br>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把<strong>锁就是存在Java对象头里的</strong>。得到锁的线程能访问同步资源。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/0952a8ddcd04a30ab16345a543403b74.png" class="" title="image.png">

<h4 id="Java对象头中的MarkWord"><a href="#Java对象头中的MarkWord" class="headerlink" title="Java对象头中的MarkWord"></a>Java对象头中的MarkWord</h4><p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/bVcO4cm.png" class="" title="image.png">

<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>CAS</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p>
<h6 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h6><p>一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。偏向锁的偏是指会偏向第一个获得锁的线程。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>当一个线程访问同步代码块并获取锁时，会通过对象头里存储锁偏向的线程ID。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测对象头里是否存储着指向当前线程的偏向锁。<br>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的锁执行操作。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h6 id="适用情况-1"><a href="#适用情况-1" class="headerlink" title="适用情况"></a>适用情况</h6><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，适用在多线程交替执行同步块的情况</p>
<h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>当一个线程访问同步代码块并获取锁时，会通过CAS操作修改对象头里锁的状态位标记为轻量级锁</p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><p>在多线程交替执行同步块的情况下，用CAS进行加锁和解锁而不是直接用重量级锁，避免性能消耗</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>monitor锁</p>
<p><strong>各种锁的优缺点</strong></p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/v2-40688b504f5b1e0d4a4f33e4ec10be72_720w.jpg" class="" title="img">

<h5 id="锁升级自己的一些理解："><a href="#锁升级自己的一些理解：" class="headerlink" title="锁升级自己的一些理解："></a>锁升级自己的一些理解：</h5><p>偏向锁是一段同步代码一直被一个线程所访问，只需要第一次用CAS存储在Mark Word里存储锁偏向的线程ID，后续就直接判断这个线程ID在不在，不需要再使用CAS了。<br>轻量级锁就是多线程交替执行同步块的情况下，每次都是用CAS操作尝试将对象的MarkWord更新为指向LockRecord的指针，而不是使用重量级锁阻塞其他线程。</p>
<h3 id="性能比较结果："><a href="#性能比较结果：" class="headerlink" title="性能比较结果："></a>性能比较结果：</h3><p>无可置疑，synchronized的性能确实要比ReentrantLock差个20%-30%</p>
<p>Synchronized适合于并发竞争低的情况，因为Synchronized的锁升级如果最终升级为重量级锁在使用的过程中是没有办法消除的，意味着每次都要和cpu去请求锁资源，而ReentrantLock主要是提供了阻塞的能力，<strong>通过在高并发下线程的挂起，来减少竞争，提高并发能力</strong></p>
<h2 id="是否可手动释放："><a href="#是否可手动释放：" class="headerlink" title="是否可手动释放："></a><strong>是否可手动释放：</strong></h2><p>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。</p>
<h2 id="锁是否可以被中断："><a href="#锁是否可以被中断：" class="headerlink" title="锁是否可以被中断："></a><strong>锁是否可以被中断：</strong></h2><p>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
<h3 id="ReentrantLock不可打断模式与可打断模式"><a href="#ReentrantLock不可打断模式与可打断模式" class="headerlink" title="ReentrantLock不可打断模式与可打断模式"></a>ReentrantLock不可打断模式与可打断模式</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="上锁的内容："><a href="#上锁的内容：" class="headerlink" title="上锁的内容："></a><strong>上锁的内容：</strong></h2><p>synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢。</p>
<ul>
<li>Synchronized修饰实例方法：为当前实例this加锁</li>
<li>Synchronized修饰静态方法：为当前Class实例加锁</li>
<li>Synchronized修饰代码块：为Synchronized后面括号里修饰的实例加锁<br>注意：</li>
<li>同一个类的不同实例拥有不同的锁，因此不会相互阻塞。</li>
<li>使用Synchronized修饰Class和实例时，由于Class和实例分别拥有不同的锁，因此不会相互阻塞。</li>
<li>如果一个线程正在访问实例的一个Synchronized修饰的实例方法时，其它线程不仅不能访问该Synchronized修饰的实例方法，该实例的其它ynchronized修饰的实例方法也不能访问，因为一个实例只有一个监视器锁，但是其它线程可以访问该实例的无Synchronized修饰的实例方法或Synchronized修饰的静态方法。</li>
</ul>
<h2 id="二者原理："><a href="#二者原理：" class="headerlink" title="二者原理："></a>二者原理：</h2><h3 id="1-Synchronized上锁过程"><a href="#1-Synchronized上锁过程" class="headerlink" title="1.Synchronized上锁过程"></a>1.Synchronized上锁过程</h3><img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/v2-e411138c62b82128f475e3e999c30632_1440w.jpg" class="" title="img">
<p>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h3><p><strong>ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁，并且使用了AQS队列。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态</strong>。</p>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>的缩写，这个是个内部实现了两个队列的抽象类，分别是<strong>同步队列</strong>和<strong>条件队列</strong>。其中<strong>同步队列</strong>是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而<strong>条件队列</strong>是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，<code>AQS</code>所做的就是管理这两个队列里面线程之间的<strong>等待状态-唤醒</strong>的工作。</p>
<p>ReentrantLock通过设置参数调整是否为公平锁和非公平锁</p>
<p>内部结构：</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/169aa1836d0ac5b0tplv-t2oaga2asx-zoom-in-crop-mark3024000.webp" class="" title="img">

<p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中<code>Sync</code>内部类继承自<code>AQS</code>，另外的两个内部类继承自<code>Sync</code>，这两个类分别是用来<strong>公平锁和非公平锁</strong>的。</p>
<p>通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，**<code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁**。</p>
<p>ReentrantLock的lock() 和 unlock() 方法的流程：</p>
<h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol>
<li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li>
<li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>这是<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li>
</ol>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/169aab7befb2e5detplv-t2oaga2asx-zoom-in-crop-mark3024000.webp" class="" title="img">

<h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol>
<li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li>
<li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li>
<li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li>
<li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li>
</ol>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/169aad4a8e578933tplv-t2oaga2asx-zoom-in-crop-mark3024000.webp" class="" title="img">



<p>公平锁的实现原理：</p>
<h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol>
<li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li>
<li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li>
<li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li>
</ol>
<p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/169aaf5a27ee58d5tplv-t2oaga2asx-zoom-in-crop-mark3024000.webp" class="" title="img">



<p>对比表：</p>
<table>
<thead>
<tr>
<th></th>
<th>ReentrantLock</th>
<th>Synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>通过<code>AQS</code>实现</td>
<td>通过<code>JVM</code>实现，其中<code>synchronized</code>又有多个类型的锁，除了重量级锁是通过<code>monitor</code>对象(操作系统mutex互斥原语)实现外，其它类型的通过对象头实现。</td>
</tr>
<tr>
<td>是否可重入</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>公平锁</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>非公平锁</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>锁的类型</td>
<td>悲观锁、显式锁</td>
<td>悲观锁、隐式锁(内置锁)</td>
</tr>
<tr>
<td>是否支持中断</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否支持超时等待</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否自动获取&#x2F;释放锁</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="Java中锁的四种粒度"><a href="#Java中锁的四种粒度" class="headerlink" title="Java中锁的四种粒度"></a>Java中锁的四种粒度</h1><ol>
<li>ThreadLocal</li>
<li>volatile</li>
<li>synchronized</li>
<li>Atomic</li>
</ol>
<h2 id="一、ThreadLocal"><a href="#一、ThreadLocal" class="headerlink" title="一、ThreadLocal"></a>一、ThreadLocal</h2><h3 id="具体作用："><a href="#具体作用：" class="headerlink" title="具体作用："></a>具体作用：</h3><p>ThreadLocal类提供线程局部变量。这些变量与正常的变量不同，每个线程访问一个(通过它的get或set方法)都有它自己的、独立初始化的变量副本。</p>
<p>ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，如下图所示。</p>
<p>使用场景也很多：</p>
<ul>
<li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>2、线程间数据隔离</li>
<li>3、进行事务操作，用于存储线程事务信息。</li>
<li>4、数据库连接，<code>Session</code>会话管理。</li>
</ul>
<p><strong>使用才能理解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,local:&quot;</span> + local.get());</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">线程：Thread-<span class="number">0</span>,local:Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">线程：Thread-<span class="number">1</span>,local:Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">线程：Thread-<span class="number">2</span>,local:Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">线程：Thread-<span class="number">3</span>,local:Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">线程：Thread-<span class="number">4</span>,local:Thread-<span class="number">4</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>泛型用来记录每个Thread存储的值的类型。</p>
<p>既每次新的线程都会set一个属于他自己的i值，当这个线程想要get的时候，ThreadLocal会找到属于这个thread的自己的值。</p>
<h3 id="理解方式："><a href="#理解方式：" class="headerlink" title="理解方式："></a>理解方式：</h3><p><strong>从thread角度看：</strong></p>
<p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p><strong>从threadLocal角度看：</strong></p>
<p>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，hreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置，继承自弱引用，用来保存ThreadLocal和Value之间的对应关系，之所以用弱引用，是为了解决线程与ThreadLocal之间的强绑定关系，会导致如果线程没有被回收，则GC便一直无法回收这部分内容。</p>
<h3 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<span class="comment">//继承了弱引用 </span></span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);<span class="comment">//所以map添加的key是ThreadLocal的弱引用</span></span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1368768-20190614105112553-1657649661.png" class="" title="img">

<ol>
<li><strong>set</strong>方法源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程（调用者线程）</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果map不为null，就直接添加本地变量，key为当前定义的ThreadLocal变量的this引用，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="comment">//(4)如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)的方法详进</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>get</strong>方法源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)获取当前线程的threadLocals变量</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>remove</strong>方法的实现</p>
<p>remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程绑定的threadLocals</span></span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">//如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>总结</p>
<p>如下图所示：每个线程内部有一个名为threadLocals的成员变量，该变量的类型为ThreadLocal.ThreadLocalMap类型（类似于一个HashMap），其中的key为当前定义的ThreadLocal变量的this引用，value为我们使用set方法设置的值。每个线程的本地变量存放在自己的本地内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量就会一直存在（所以可能会导致内存溢出），因此使用完毕需要将其remove掉。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1368768-20190614011044060-2111473950.png" class="" title="img"></li>
</ol>
<h3 id="理解ThreadLocal中的内存泄漏问题"><a href="#理解ThreadLocal中的内存泄漏问题" class="headerlink" title="理解ThreadLocal中的内存泄漏问题"></a>理解ThreadLocal中的内存泄漏问题</h3><p>我们之前提到过，当前ThreadLocal的引用k被传递给WeakReference的构造函数，所以T<strong>hreadLocalMap中的key为ThreadLocal的弱引用</strong>。当一个线程调用ThreadLocal的set方法设置变量的时候，当前线程的ThreadLocalMap就会存放一个记录，这个记录的key值为ThreadLocal的弱引用，value就是通过set设置的值。如果当前线程一直存在且没有调用该ThreadLocal的remove方法，如果这个时候别的地方还有对ThreadLocal的引用，那么当前线程中的ThreadLocalMap中会存在对ThreadLocal变量的引用和value对象的引用，是不会释放的，就会造成内存泄漏。</p>
<p>　　考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在的这就可能造成内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p>
<p>　　总结：THreadLocalMap中的Entry的key使用的是ThreadLocal对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉，但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项，这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</p>
<p><a href="https://www.cnblogs.com/fsmly/p/11020641.html">Java中的ThreadLocal详解 - 夏末秋涼 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/102744180">ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/518764555">深入理解ThreadLocal - 知乎 (zhihu.com)</a></p>
<h2 id="二、volatile"><a href="#二、volatile" class="headerlink" title="二、volatile"></a>二、volatile</h2><h2 id="三、synchronized"><a href="#三、synchronized" class="headerlink" title="三、synchronized"></a>三、synchronized</h2><h2 id="四、Atomic"><a href="#四、Atomic" class="headerlink" title="四、Atomic"></a>四、Atomic</h2><p>在JDK1.5之后，JDK的（concurrent包）并发包里提供了一些类来支持原子操作，如AtomicBoolean,AtomicInteger,AtomicLong等都是用原子的方式来更新指定类型的值。<br>从多线程并行计算乐观锁 和 悲观锁 来讲，JAVA中的synchronized 属于悲观锁，即是在操作某数据的时候总是会认为多线程之间会相互干扰，属于阻塞式的加锁；Atomic系列则属于乐观锁系列，即当操作某一段数据的时候，线程之间是不会相互影响，采用非阻塞的模式，直到更新数据的时候才会进行版本的判断是否值已经进行了修改，即CAS操作。</p>
<h1 id="volatile、ThreadLocal的使用场景和原理"><a href="#volatile、ThreadLocal的使用场景和原理" class="headerlink" title="volatile、ThreadLocal的使用场景和原理"></a>volatile、ThreadLocal的使用场景和原理</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="什么是重排序？"><a href="#什么是重排序？" class="headerlink" title="什么是重排序？"></a>什么是重排序？</h3><p>CPU运行效率 相比缓存、内存、硬盘IO之间效率有着指数级的差别，CPU作为系统的宝贵资源，那么如何更好的优化和利用这个资源就能提升整个计算机系统的性能。它也会根据指令的类别做一些优化，目的就是把CPU的资源利用起来，这样就能就能提升整个计计算机的效率。</p>
<h3 id="为什么会要重排序？"><a href="#为什么会要重排序？" class="headerlink" title="为什么会要重排序？"></a>为什么会要重排序？</h3><p>提高运行效率。</p>
<h3 id="重排序原则"><a href="#重排序原则" class="headerlink" title="重排序原则"></a>重排序原则</h3><p><strong>指令重排序的原则：as-if-serial语义</strong></p>
<p>编译器和处理指令也并非什么场景都会进行指令重排序的优化，而是会遵循一定的原则，只有在它们认为重排序后不会对程序结果产生影响的时候才会进行重排序的优化，如果重排序会改变程序的结果，那这样的性能优化显然是没有意义的。而遵守as-if-serial 语义规则就是重排序的一个原则（<strong>as-if-serial</strong> ：可以允许编译器和处理器进行重排序，但是有一个条件，就是不管怎么重排序都<strong>不能改变单线程执行程序的结果</strong>。）</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p><strong>as-if-serial</strong>表示所有的程序指令都可以因为优化而被重排序，但是在优化的过程中必须要保证是在单线程环境下，重排序之后的运行结果和程序代码本身预期的执行结果一致，Java编译器、CPU指令重排序都需要保证在单线程环境下的as-if-serial语义是正确的。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/b14f0d552b908851973d9f2ec34c1898.png" class="" title="b14f0d552b908851973d9f2ec34c1898.png">

<h3 id="编译器重排序："><a href="#编译器重排序：" class="headerlink" title="编译器重排序："></a>编译器重排序：</h3><p>这个阶段发生在.java文件编译成.class文件的阶段。</p>
<p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;	对比			<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">1</span>;				 a=a+<span class="number">1</span>;</span><br><span class="line">a=a+<span class="number">1</span>;					 <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line">b=b+<span class="number">1</span>;					 b=b+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>目的</strong>是减少CPU和内存的交互，重排序之后尽可能保证CPU从寄存器或缓存行中读取数据。CPU计算的时候要访问值，如果常常利用到寄存器中已有的值就不用去内存读取了，所以避免了重复读取的操作。</p>
<h3 id="指令级并行重排序："><a href="#指令级并行重排序：" class="headerlink" title="指令级并行重排序："></a>指令级并行重排序：</h3><p>并行指令集重排序，这是处理器优化的一种，处理器可以改变指令的执行顺序。</p>
<p>样例演示：</p>
<p><a href="https://blog.csdn.net/weixin_46232441/article/details/122428352">(36条消息) 流水线指令重排序，指令级并行_神秘的W同学的博客-CSDN博客</a></p>
<h4 id="什么是并行指令集？"><a href="#什么是并行指令集？" class="headerlink" title="什么是并行指令集？"></a>什么是并行指令集？</h4><p>在处理器内核中一般会有多个执行单元，比如算术逻辑单元、位移单元等。</p>
<ul>
<li>在引入并行指令集之前，CPU在每个时钟周期内只能执行单条指令，也就是说只有一个执行单元在工作，其他执行单元处于空闲状态；</li>
<li>在引入并行指令集之后，CPU在一个时钟周期内可以同时分配多条指令在不同的执行单元中执行。</li>
</ul>
<h4 id="那么什么是并行指令集的重排序呢？"><a href="#那么什么是并行指令集的重排序呢？" class="headerlink" title="那么什么是并行指令集的重排序呢？"></a>那么什么是并行指令集的重排序呢？</h4><p>如下图所示，假设某一段程序有多条指令，不同指令的执行实现也不同。</p>
<p><a href="https://img2020.cnblogs.com/blog/2465789/202111/2465789-20211129124345659-2038741022.png"><img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2465789-20211129124345659-2038741022.png" class="" title="img"></a></p>
<p>对于一条从内存中读取数据的指令，CPU的某个执行单元在执行这条指令并等到返回结果之前，按照CPU的执行速度来说它足够处理几百条其他指令，而CPU为了提高执行效率，会根据单元电路的空闲状态和指令能否提前执行的情况进行分析，把那些指令地址顺序靠后的指令提前到读取内存指令之前完成。</p>
<p>实际上，这种优化的本质是通过提前执行其他可执行指令来填补CPU的时间空隙，然后在结束时重新排序运算结果，从而实现指令顺序执行的运行结果。</p>
<h3 id="内存级别的重排序"><a href="#内存级别的重排序" class="headerlink" title="内存级别的重排序"></a>内存级别的重排序</h3><p><strong>举例</strong></p>
<table>
<thead>
<tr>
<th align="left">CPU0</th>
<th align="left">CPU1</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X&#x3D;1 &#x2F;&#x2F;S1</td>
<td align="left">Y&#x3D;1 &#x2F;&#x2F;S2</td>
</tr>
<tr>
<td align="left">r1&#x3D;Y &#x2F;&#x2F;S3</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">r2&#x3D;X &#x2F;&#x2F;S4</td>
</tr>
</tbody></table>
<p>当前系统共2个CPU，CPU0和CPU1，上面是2个CPU执行的指令序列，其中X和Y为共享变量，r1和r2为局部变量。</p>
<p>上述CPU1执行S4处的指令后r2应该为1， r1应该为1，但有时间可能是r2为0，r1是1，即在CPU1看来好像S1的指令没有执行，但S3的指令已经执行了。这个不是由于指令排序造成的，是因为内存相关指令引起的，所以叫内存重排序。</p>
<p>具体原因：CPU1执行到S4时，由于S1的执行结果可能还存留在写缓存中，因此CPU1无法感知到，所以执行S4的时候，CPU1读取到X的值还是未初始化的0。</p>
<p><strong>介绍</strong></p>
<p>CPU执行指令的速度和访问内存指令速度是不匹配的，CPU执行速度太快，而访问内存的指令相对来说要慢些，为了加快快访问速度，硬件设计者们在每个CPU内部加入了高速缓存（Store Buffer）：</p>
<p>内存系统重排序，这是处理器引入Store Buffer缓冲区延时写入产生的指令执行顺序不一致的问题。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220802142516240.png" class="" title="image-20220802142516240">

<p><strong>总结：</strong></p>
<p>内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。<br>由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</p>
<p>1、内存重排序实际上并不是真的相关操作被排序了，而是因为CPU引入缓存还没来得及刷新导致；</p>
<p>2、每个CPU都有自己的缓存，为了提高共享变量的写操作，CPU把整个操作变成异步的了，如果写入操作还没来的及同步到其它CPU，就有可能发生其它CPU读取到的是旧的值，因此看起来这条指令还没执行一样。</p>
<h2 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a><strong>禁止重排序</strong></h2><p>如果我们使用内存屏障，那么JMM的处理器，会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为 Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h2 id="什么是-Memory-Barrier（内存屏障）？"><a href="#什么是-Memory-Barrier（内存屏障）？" class="headerlink" title="什么是 Memory Barrier（内存屏障）？"></a>什么是 Memory Barrier（内存屏障）？</h2><p>内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令： 1、保证特定操作的执行顺序。 2、影响某些数据（或则是某条指令的执行结果）的内存可见性。</p>
<p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。<br>———————————————————————————————————————————————</p>
<h2 id="vloatile关键字"><a href="#vloatile关键字" class="headerlink" title="vloatile关键字"></a>vloatile关键字</h2><p>重排序会带来可见性问题，所以在多线程开发中必须要关注并规避重排序</p>
<h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><ul>
<li><strong>可见性：</strong> 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入</li>
<li><strong>原子性：</strong> 对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
</ul>
<h3 id="volatile工作原理"><a href="#volatile工作原理" class="headerlink" title="volatile工作原理"></a>volatile工作原理</h3><p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220802141547162.png" class="" title="image-20220802141547162">

<p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p><font color="red">而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</font></p>
<h3 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h3><p>volatile可以保证可见性和顺序性 但不能保证原子性</p>
<p>Java中<strong>只有对基本类型变量的赋值和读取是原子操作</strong>，如i &#x3D; 1的赋值操作，但是<strong>像j &#x3D; i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作</strong>，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<p>所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</p>
<p>举例说明：</p>
<p>Java中只有对基本类型变量的赋值和读取是原子操作，如i &#x3D; 1的赋值操作，但是像j &#x3D; i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<p>所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</p>
<h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ol>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ol>
<h3 id="Java-内存模型中的可见性、原子性和有序性。"><a href="#Java-内存模型中的可见性、原子性和有序性。" class="headerlink" title="Java 内存模型中的可见性、原子性和有序性。"></a><strong>Java 内存模型中的可见性、原子性和有序性。</strong></h3><p><strong>可见性：</strong></p>
<p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，<strong>volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性</strong>。比如 volatile int a &#x3D; 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p>
<p>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<p><strong>原子性：</strong></p>
<p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p>
<p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<p><strong>有序性：</strong></p>
<p>　　Java 语言<strong>提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性</strong>，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220802104931779.png" class="" title="image-20220802104931779">



<h2 id="什么是JIT？"><a href="#什么是JIT？" class="headerlink" title="什么是JIT？"></a>什么是JIT？</h2><p>1、<em>动态编译</em>（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫<em>静态编译</em>（static compilation）。</p>
<p>2、<em>JIT</em> 编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。<em>JIT编译是动态编译的一种特例</em>。JIT编译一词后来被<em>泛化</em>，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。<br>3、<em>自适应动态编译</em>（adaptive dynamic compilation）也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化。</p>
<h2 id="为什么HotSpot虚拟机要使用解释器与编译器并存的架构？"><a href="#为什么HotSpot虚拟机要使用解释器与编译器并存的架构？" class="headerlink" title="为什么HotSpot虚拟机要使用解释器与编译器并存的架构？"></a>为什么HotSpot虚拟机要使用解释器与编译器并存的架构？</h2><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。</p>
<p>解释器与编译器两者各有优势：**当程序需要 <em>迅速启动和执行</em> 的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取 <em>更高的执行效率</em>  ** 。当程序运行环境中 <em>内存资源限制较大</em> （如部分嵌入式系统中），可以使用 <em>解释器执行节约内存</em> ，反之可以使用 <em>编译执行来提升效率</em> 。此外，如果编译后出现“罕见陷阱”，可以通过逆优化退回到解释执行。</p>
<p>HotSpot虚拟机中内置了两个即时编译器：Client Complier和Server Complier，简称为C1、C2编译器，分别用在客户端和服务端。目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个编译器，取决于虚拟机运行的模式。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>用Client Complier获取更高的<em>编译速度</em>，用Server Complier 来获取更好的<em>编译质量</em>。为什么提供多个即时编译器与为什么提供多个<a href="https://www.cnblogs.com/zwtblog/p/15205383.html#gc-%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">垃圾收集器</a>类似，都是为了适应不同的应用场景。</p>
<p>巨人的肩膀：</p>
<p>原文链接：<a href="https://cloud.tencent.com/developer/article/1684031">创建线程到底有多少种方式？ - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://blog.csdn.net/fuyuwei2015/article/details/83719444">(31条消息) ReentrantLock原理_孙悟空2015的博客-CSDN博客_reentrantlock原理</a></p>
<p><a href="https://blog.csdn.net/xindoo/article/details/103637547">(28条消息) ReentrantLock源码解析_xindoo的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/263762343">Java并发编程——深入理解自旋锁 - 知乎 (zhihu.com)</a></p>
<p><a href="https://juejin.cn/post/6844903805683761165">https://juejin.cn/post/6844903805683761165</a></p>
<p>[Synchronized原理和锁升级 - SegmentFault 思否](<a href="https://segmentfault.com/a/1190000039301200#:~:text=">https://segmentfault.com/a/1190000039301200#:~:text=</a> synchronized的锁升级，说白了，就是当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级。,synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。 得到锁的线程能访问同步资源。)</p>
<p><a href="https://cloud.tencent.com/developer/article/1447345">偏向锁、轻量级锁、重量级锁、自旋锁原理讲解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事 (youzan.com)</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1420278?from=article.detail.1447345">一文讲解重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等各种锁 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html">Java中Volatile关键字详解 - 郑斌blog - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/zwtblog/p/15619334.html#%E4%B8%BA%E4%BB%80%E4%B9%88hotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A6%81%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%B9%B6%E5%AD%98%E7%9A%84%E6%9E%B6%E6%9E%84">什么是指令重排？ - ML李嘉图 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/326260623">指令重排序、内存屏障很难？看完这篇你就懂了！ - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_36324960/article/details/114604391">(36条消息) java 编译器重排序_Java并发读书笔记：JMM与重排序_Everlasting Cold的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/xiaolyuh123/article/details/103289570">(36条消息) Java中的指令重排_xiaolyuh123的博客-CSDN博客</a> 未完成</p>
<p><a href="https://www.cnblogs.com/xmzJava/p/11417943.html">cpu缓存和volatile - XuMinzhe - 博客园 (cnblogs.com)</a> 未完成 ！</p>
<p><a href="https://zhuanlan.zhihu.com/p/102744180">ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/hhx626/p/7534613.html">【java基础 14】锁的粒度：ThreadLocal、volatile、Atomic和Synchronized - 何红霞 - 博客园 (cnblogs.com)</a> 未完成</p>
<p><a href="https://blog.csdn.net/xdzhouxin/article/details/81236356">https://blog.csdn.net/xdzhouxin/article/details/81236356</a></p>
<p><a href="https://blog.csdn.net/suifeng3051/article/details/52611233">https://blog.csdn.net/suifeng3051/article/details/52611233</a></p>
<p><a href="https://blog.csdn.net/ye17186/article/details/89467919">(143条消息) Java线程池七个参数详解_线程池七大核心参数_ye17186的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="读者前言"><a href="#读者前言" class="headerlink" title="读者前言"></a>读者前言</h2><p>本文章为《现代操作系统》原书第四版的读者笔记。读者旨在对操纵整个计算机层面的操作系统进行深刻理解。如有纰漏，敬请留言指正。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220901112908818.png" class="" title="image-20220901112908818">

<span id="more"></span>

<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><h3 id="总观"><a href="#总观" class="headerlink" title="总观"></a>总观</h3><p>现代计算机系统有一个或多个处理器，主存，磁盘，打印机，键盘，鼠标，显示器，网络接口以及各种其他输入&#x2F;输出设备组成。所以，<strong>操作系统是计算机上安装的一层管理软件</strong>，为用户程序提供一个更好，更简单，更清晰的计算机模型，并管理刚才提及到的所有设备。</p>
<p>与用户交互的程序，<strong>基于文本的通常称为shell</strong>，<strong>基于图标的成为图形用户界面（GUI）</strong>，它们其实并不属于操作系统的一部分。</p>
<p>图1-1为简化视图，多数计算机有两种运行模式：<strong>内核态</strong> 和 <strong>用户态</strong>。软件中最基础的部分是操作系统，运行在内核态。这个模式中，操作系统具有对所有硬件的<ins>完全访问权</ins>。软件的其他应用在用户态下，只是用了机器指令中的一个<ins>子集</ins>。（特别的，那些会影响机器的控制或进行I&#x2F;O操作的指令，在用户态的程序中是禁止的）。</p>
<p>操作系统（内核态）和普通软件（用户态）之间的主要区别是，如果用户不喜欢某个特定的电子邮件阅读器，它可以自己写一个，但是不能自行写一个属于操作系统一部分的时钟终端处理程序 ，这个程序由硬件保护，<ins>防止用户试图对其进行修改</ins>。</p>
<p>但是一些在内核外运行的程序又有争议地被认为是操作系统的一部分，或者至少与操作系统密切相关。所以在一些系统中，<strong>很难在内核态和用户态之间划分住一条明显的界限。</strong></p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220828125226111.png" class="" title="image-20220828125226111">



<p>操作系统是运行在内核态的软件。但我们还很难准确定义操作系统，因为还取决于从什么角度看待操作系统。</p>
<h3 id="作为扩展机器的操作系统"><a href="#作为扩展机器的操作系统" class="headerlink" title="作为扩展机器的操作系统"></a>作为扩展机器的操作系统</h3><p>是没有人想和硬件层面上的硬件打交道的，至少操作系统的编写人员是这样，所以他们使用的是一些叫做<ins>硬盘驱动</ins>的软件来和硬盘交互，这些软件提供了读写硬盘块的接口。真是的处理器，内存条，磁盘和其他设备都是非常复杂的，编写软件的人们来说，他们使用的是那些困难，可怕，复杂的接口。操作系统的一个主要人数是隐藏硬件，呈现给程序使用人员们，良好，清晰，优雅，一致的抽象，如图1-2。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220828125130745.png" class="" title="image-20220828125130745">

<h3 id="作为资源管理者的操作系统"><a href="#作为资源管理者的操作系统" class="headerlink" title="作为资源管理者的操作系统"></a>作为资源管理者的操作系统</h3><p>现代计算机包含多种设备，操作系统的任务是在互相竞争的程序之间有序地控制对处理器，存储器以及其他I&#x2F;O接口设备的分配。</p>
<p>当一个计算机（或网络）有多个用户时，用户通常不仅共享硬件，还要共享信息（文件，数据库等）。操作系统要记录哪个程序在使用什么资源，对资源请求进行分配，并未不同的程序和用户调解互相冲突的资源请求。</p>
<p>资源管理包括一下两种方式实现多路复用（共享）资源：在<strong>时间上复用</strong>和在<strong>空间上复用</strong>。</p>
<p>时间上复用：不同的程序或用户轮流使用资源（CPU）。例如单核CPu并发执行任务。</p>
<p>空间上复用：每个客户都得到了资源的一部分，从而取代了客户排队。例如，一个磁盘同时为多个用户保存文件。分配磁盘空间并记录谁正在使用哪个磁盘块。</p>
<h2 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h2><h4 id="1-处理器"><a href="#1-处理器" class="headerlink" title="1.处理器"></a>1.处理器</h4><h4 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2.存储器"></a>2.存储器</h4><h4 id="3-磁盘"><a href="#3-磁盘" class="headerlink" title="3.磁盘"></a>3.磁盘</h4><h4 id="4-I-x2F-O设备"><a href="#4-I-x2F-O设备" class="headerlink" title="4.I&#x2F;O设备"></a>4.I&#x2F;O设备</h4><h2 id="操作系统的一些基本概念"><a href="#操作系统的一些基本概念" class="headerlink" title="操作系统的一些基本概念"></a>操作系统的一些基本概念</h2><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><h4 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2.地址空间"></a>2.地址空间</h4><h4 id="3-I-x2F-O设备-输入输出"><a href="#3-I-x2F-O设备-输入输出" class="headerlink" title="3.I&#x2F;O设备 输入输出"></a>3.I&#x2F;O设备 输入输出</h4><h4 id="4-保护"><a href="#4-保护" class="headerlink" title="4.保护"></a>4.保护</h4><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><p>page 29</p>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><h3 id="层次式系统"><a href="#层次式系统" class="headerlink" title="层次式系统"></a>层次式系统</h3><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><h3 id="客户端–服务器模式"><a href="#客户端–服务器模式" class="headerlink" title="客户端–服务器模式"></a>客户端–服务器模式</h3><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>所有现代的计算机经常会在同一时间做许多件事情。现在考虑吧只有一个PC用户，当启动系统时，会秘密启动许多进程。例如，启动一个进程用来等待进入的 电子邮件；或者启动另一个防病毒进程周期性地检查是否由病毒库更新。这些活动都需要管理，于是一个支持多进程的<ins>多道程序系统</ins>在这里就显得非常有用了。</p>
<p>在任何多道程序设计系统中，CPU有一个进程快速切换到另一个进程，使得每个进程各运行几十或几百毫秒。严格地说，<ins>在某一个瞬间，CPU只能运行一个进程。但是在1秒钟内，他可能运行多个进程，这样就产生并行的错觉。</ins>有时人们所说的<strong>伪并行</strong>就是指这种情景，以此来区分多处理器系统（该系统有两个或多个CPU共享同一个物理内存）的真正硬件并行。</p>
<p>多道程序系统依赖于多道程序设计（系统在（伪）并行的情况下运行的程序集，这种方法要比试图跟踪CPU如何在程序之间来回切换简单得多）。</p>
<p>图2-1a可以看到，一个多道程序计算机的内存中有4道程序，在b中，这4道程序被抽象成4个各自拥有自己控制流程的进程，在c中看到，所有的进程都运行了，但在任何一个给定的瞬间仅有一个程序真正的在运行。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220828092304649.png" class="" title="image-20220828092304649">

<p>一个进程是某正类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>
<p>关于程序和进程：如果一个程序运行了两遍，则算作两个进程。</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>从技术上看，在所有这些情形中，<strong>新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的</strong>。这个进程可以是一个运行的用户进程、一个由键盘或鼠标启动的程序进程或者一个批处理管理进程。这个进程所做的工作是，执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序。</p>
<p>在unix系统中</p>
<p>在window中</p>
<p>&#x2F;&#x2F;TODO 两大系统类别的创建进程的步骤。page50</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在被创建之后，开始运行到完成工作，迟早这个进程会被终止，通常会由以下条件引起：</p>
<ol>
<li>正常退出（自愿）</li>
<li>出错退出（自愿）</li>
<li>严重错误（非自愿）</li>
<li>被其他进程杀死（非自愿）</li>
</ol>
<p><strong>正常退出：</strong>例如，当编译器完成给定程序的编译后，编译器执行一个系统调用，通知操作系统他的工作已经完成。大多数交互程序都有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p>
<p><strong>出错退出：</strong>比如我们要编译一个程序，但是该程序文件不存在，于是编译器就会退出，在给出错误参数的时候，面向屏幕的交互式进程通常并不退出，相反会让用户重试。</p>
<p><strong>严重错误：</strong>这是由进程引起的错误，通常是由于程序中的错误所致。例如执行了一条非法指令，引用不存在的内存（空指针），除数为0，数组越界等。在这类错误中，程序会被终端，而不是在这类错误出现时停止。</p>
<p><strong>被其他进程杀死：</strong>某个进程执行一个系统调用通知操作系统杀死某个其他进程。</p>
<p>当一个进程终止时，不论是自愿还是其他原因，由该进程所创建的其他所有进程也一律立即被杀死。</p>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>某些系统中，当一个进程创建了另一个继承后，父进程和子进程就医某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。</p>
<p>在UNIX中，进程和它的所有紫禁城以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前于键盘相关的进程组中的所有成员。每个进程可以分别捕获该信号，忽略该信号或采取默认的动作，既被该信号杀死。</p>
<p>相反在windows系统中没有进程层次的概念，所有的进程都是地位相同的。唯一类似于继承层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（成为句柄），该句柄可以用来控制子进程。但是。它有权把这个令牌传送给某个其他进程。</p>
<h3 id="进程的状态！"><a href="#进程的状态！" class="headerlink" title="进程的状态！"></a>进程的状态！</h3><ol>
<li>运行态（该时刻进程实际占用CPU）</li>
<li>就绪态（可运行，但因为其他进程正在运行而暂时停止）</li>
<li>阻塞态（除非某种外部事件发生，否则进程不能运行）</li>
</ol>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220828123428209.png" class="" title="image-20220828123428209">

<p>前两种状态在逻辑上是类似的，处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有CPU分配给它。第三种状态和前两种状态不同，处于该状态的进程不能运行（即使CPU空闲）。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>我们为什么需要线程？</p>
<p>在许多应用中同时发生这多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行的多个顺序线程，程序设计模型会更加简单。有了这个概念，并行实体就拥有共享同一个地址空间和所有可用数据的能力。第二个理由是，由于线程比进程更轻量级，所以他们比进程更容易创建和撤销（创建一个线程较创建一个进程的速度要快10~100倍）。第三方面的原因是涉及性能方面的讨论，若多个线程都是CPU密集型的，</p>
<h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已经调用的但是还没有从中返回的函数。（需要注意的是，每个线程都有属于自己的堆栈）</p>
<p>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间由较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是堆在同一台计算机种并行多个进程的模拟。在前一种情境下，多个线程共享同一个地址空间和其他资源。而在后一种场景中，多个线程共享物理内存、磁盘、打印机和其他资源。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程之间通信的问题，同样适用于线程，同样的问题可以用同样的方法解决，同样的解决办法也适用于线程。</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>两个或多个进程读写某些贡献数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>怎么避免竞争条件？实际上凡涉及到共享内训，共享文件以及共享在任何资源的情况都会引发于资源竞争的错误，要避免这种错误，关键是要找出某种途径来阻止多个进程同时读写共享的数据。我们需要的是互斥，既以某种手段确保当一个进程在使用一个共享变量后文件时，其他进程不能做同样操作。</p>
<p>我们把对共享内存进行访问的程序片段称为<strong>临界区域</strong>或<strong>临界区</strong>。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p>
<ol>
<li>任何两个进程不能同时处于其临界区。</li>
<li>不应该对CPU的速度和数量做任何假设。</li>
<li>临界区外运行的进程不得阻塞其他进程。</li>
<li>不得是进程无限期等待进入临界区。</li>
</ol>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220905093352066.png" class="" title="image-20220905093352066">

<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>几种实现互斥的方案，当一个进程在临界区中更新共享内存时，其他进程将不会进入其临界区。</p>
<h4 id="1-锁变量"><a href="#1-锁变量" class="headerlink" title="1. 锁变量"></a>1. 锁变量</h4><p>一种软件解决办法，设想有一个共享（锁）变量，其初始值为0，当一个进程想进入其临界区的时候，首先测试这把锁。如果这锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将的等待直到其值为0，于是0.就表示临界区内没有进程，1就表示已经某个进程进入临界区。</p>
<p>但是这种想法存在疏漏，假设一个进程读取锁变量的值并发现它为0，而恰好在他将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。当第一个进程再次运行时，他同样也将锁设置为1，则此时同时有两个进程进入到了临界区中。</p>
<h4 id="2-严格轮换法"><a href="#2-严格轮换法" class="headerlink" title="2. 严格轮换法"></a>2. 严格轮换法</h4><p>整形变量turn，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查turn，发现气质为0，于是进入临界区。进程1也发现气质为0，所以在一个等待循环中不停地测试turn，看其值合适变为1.连续测试一个变量直到某个值出现位置，由于这种方式浪费CPU的时间，所以通常应该避免，只有在有理由认为等待时间是非常短的情形下，才使用这样的忙等待，用于忙等待的锁，成为自旋锁。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220829152551842.png" class="" title="image-20220829152551842">

<h4 id="3-Peterson解法"><a href="#3-Peterson解法" class="headerlink" title="3. Peterson解法"></a>3. Peterson解法</h4><img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220905093412258.png" class="" title="image-20220905093412258">

<h4 id="4-TSL指令"><a href="#4-TSL指令" class="headerlink" title="4. TSL指令"></a>4. TSL指令</h4><p>需要一种硬件支持的解决方案，那些为多处理器设计的计算机，都有这样的一条指令：</p>
<p><strong>TSL RX，LOCK</strong> </p>
<p>称为测试并加锁，他将一个内存字lock读到寄存器RX中，然后再该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220829153810610.png" class="" title="image-20220829153810610">

<p>以上的方式都不能完美的解决进程之间的通信问题。</p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>Perterson解法和TSL都是正确的，但是他们都有忙的等待的缺点，这些解法在本质上是这样的：当一个进程想进入临界区的时候，先检查是否允许进入，如果不允许，则该线程将原地等待，直到允许为止。<ins>这样不仅浪费了CPU的时间，还会出现进程优先级的问题</ins>，当一台计算机H和L两个进程，调度规则规定，只要H处于就绪态就可以一直运行，这样L就不会被调度，H也就永远无法离开临界区，H一直忙等待，称为优先级反转问题。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h3><p>两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，将信息放入缓冲区，另一个是消费者，从缓冲区中读取信息。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当计算机系统是多道程序设计系统是，通常就会有多个进程或线程同时竞争CPU。当两个或多个进程同时准备就绪，那么就必须选择要一个要运行的进程操作CPU，完成选择工作的这一部分称为调度程序，使用的算法称为调度算法。</p>
<blockquote>
<p>关于中断：</p>
<p>中断指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。</p>
<p><a href="https://blog.csdn.net/Dm_canmeng/article/details/103538059">(54条消息) I&#x2F;O中断原理_Dm_canmeng的博客-CSDN博客_io中断是什么意思</a></p>
</blockquote>
<p>我们会讨论以下几个问题：</p>
<h3 id="1-进程行为"><a href="#1-进程行为" class="headerlink" title="1. 进程行为"></a>1. 进程行为</h3><p>几乎所有进程的（磁盘或网络）I&#x2F;O请求和计算都是交替突发的，如图2-39所示。典型地，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。在完成系统调用之后，CPU又开始计算，直到它需要读更多的数据或写更多的数据为止。请注意，某些I&#x2F;O活动可以看作计算。例如，当CPU向视频RAM复制数据以更新屏幕时，因为使用了CPU，所以这是计算，而不是I&#x2F;O活动。按照这种观点，当一个进程等待外部设备完成工作而被阻塞时，才是I&#x2F;O活动。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220830172959969.png" class="" title="image-20220830172959969">

<p>某些进程花费了大量的时间在计算上，而其他进程（图2-39b的进程）则在等待I&#x2F;O上花费了绝大多数时间。前者称为<strong>计算密集型</strong>，后者称为<strong>I&#x2F;O密集型</strong>。典型的计算密集型进程具有较长时间的CPU集中使用和较小频度的I&#x2F;O等待。I&#x2F;O密集型进程具有较短时间的CPU集中使用和频繁的I&#x2F;O等待。它是I&#x2F;O类的，因为这种进程在I&#x2F;O请求之间较少进行计算，并不是因为它们有特别长的I&#x2F;O请求。在I&#x2F;O开始后无论处理数据是多还是少，它们都花费同样的时间提出硬件请求读取磁盘块。</p>
<h3 id="2-何时调度"><a href="#2-何时调度" class="headerlink" title="2. 何时调度"></a>2. 何时调度</h3><p>在一个I&#x2F;O中断发生时，必须做出调度决策。如果中断来自I&#x2F;O设备，而该设备现在完成了工作，某些被阻塞的等待该I&#x2F;O的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，这取决于调度程序的决定，或者让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</p>
<p>如果硬件时钟提供50Hz、60Hz或其他频率的周期性中断，可以在每个时钟中断或者在每k个时钟中断时做出调度决策。根据如何处理时钟中断，可以把调度算法分为两类。</p>
<h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="**非抢占式调度算法: **"></a>**非抢占式调度算法: **</h4><p>挑选一个进程，然后让该进程运行直至被阻塞（阻塞在IO上或等待另一个进程），或者直到该进程自动释放CPU。即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。</p>
<h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法:"></a><strong>抢占式调度算法:</strong></h4><p>挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程 ）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是唯一的选择了。</p>
<h3 id="3-调度算法分类"><a href="#3-调度算法分类" class="headerlink" title="3. 调度算法分类"></a>3. 调度算法分类</h3><p>不同的环境需要不同的调度算法，在不同的系统中，调度程序的优化是不同的。这里有必要划分出三种环境∶</p>
<ol>
<li>批处理</li>
<li>交互式</li>
<li>实时</li>
</ol>
<p>批处理系统在商业领域仍在广泛应用，用来处理存货清单、账目收入、账目支出、利息计算（在银行）和其他的周期性的作业。在批处理系统中，不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此，非抢占式算法，或对每个进程都有长时间周期的抢占式算法，通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。</p>
<p>在交互式用户环境中，为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必需的。即便没有进程想永远运行，但是，某个进程由于一个程序错误也可能无限期地排斥所有其他进程。为了避免这种现象发生，抢占也是必要的。服务器也归于此类抢占式服务，因为通常它们要服务多个突发的（远程）用户。</p>
<p>在有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p>
<h3 id="4-调度算法的目标"><a href="#4-调度算法的目标" class="headerlink" title="4. 调度算法的目标"></a>4. 调度算法的目标</h3><p>调度算法在不同环境的操作系统的要求下，对该环境下运行的调度算法的度量方式也不同。</p>
<p><strong>所有系统</strong></p>
<p>公平——给每个进程公平的CPU份额（相似的进程享受相似的CPU服务）</p>
<p>策略强制执行———保证规定的策略被执行（规定安全系统的运行，即必须执行已经规定好的策略）</p>
<p>平衡————保持系统的所有部分都忙碌（通过不同的组合，尽量让CPU和磁盘同时保持工作）</p>
<p><strong>批处理系统</strong></p>
<p>吞吐量————每小时最大作业数</p>
<p>周转时间————从提交到终止间的平均等待时间（越小越好）</p>
<p>CPU利用率——保持CPU始终忙碌</p>
<p><strong>交互式系统</strong></p>
<p>响应时间————快速响应请求（给予用户最小的响应时间）</p>
<p>均衡性————满足用户的期望</p>
<p><strong>实时系统</strong></p>
<p>满足截止时间———避免丢失数据</p>
<p>可预测性————在多媒体系统中避免品质降低</p>
<h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3><h4 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1.先来先服务"></a>1.先来先服务</h4><p>在所有调度算法中，最简单的是非抢占式的先来先服务（first-come first-served）算法。使用该算法，进程按照它们请求CPU的顺序使用CPU。基本上，有一个就绪进程的单一队列。上午，当第一个作业从外部进入系统后，就立即开始并允许运行它所期望的时间长度，该作业不会因为运行太长时间而被中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程被阻塞时，就绪队列中的第一个进程接着运行。当在被阻塞的进程变为就绪时，就像一个新来到的作业一样，排到就绪队列的末尾，即排在所有进程最后。</p>
<h4 id="2-最短作业优先"><a href="#2-最短作业优先" class="headerlink" title="2.最短作业优先"></a>2.最短作业优先</h4><p>现在来看一种适用于运行时间可以预知的另一个非抢占式的批处理调度算法。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用<strong>最短作业优先</strong>（shortest jobfirst）算法，请看图2-41。这里有4个作业A、B、C、D，运行时间分别为8、4、4、4分钟。若按图中的次序运行，则A的周转时间为8分钟，B为12分钟，C为16分钟，D为20分钟，平均为14分钟。</p>
<p>现在考虑使用最短作业优先算法运行这4个作业，如图2-41b所示。目前周转时间分别为4、8、12和20分钟，平均为11分钟。可以证明最短作业优先是最优的。考虑有4个作业的情况，其运行时间分别为a，b、c、d。第一个作业在时间a结束，第二个在时间a＋b结束，以此类推。<ins>平均周转时间为（4a＋3b＋2c＋d）&#x2F;4。显然a对平均值影响最大，所以最短作业(a)应该最先被调度</ins>，其次是b，再次是c，最后的d只影响它自己的周转时间。<ins>对任意数目作业的情况，道理完全一样，所需时间最短的作业应该在最先完成。</ins></p>
<p><ins>有必要指出，只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。</ins></p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220831094638470.png" class="" title="image-20220831094638470">

<h4 id="3-最短剩余时间优先"><a href="#3-最短剩余时间优先" class="headerlink" title="3.最短剩余时间优先"></a>3.最短剩余时间优先</h4><p>最短作业优先的抢占式版本是<strong>最短剩余时间优先</strong>（shortest remaining time next）算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短作业获得良好的服务。</p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>现在考察用于交互式系统中的一些调度算法，它们在个人计算机、服务器和其他类系统中都是常用的。</p>
<h4 id="1-轮转调度"><a href="#1-轮转调度" class="headerlink" title="1.轮转调度"></a><strong>1.轮转调度</strong></h4><p>一种最古老、最简单、最公平且使用最广的算法是<strong>轮转调度</strong>（round robin）。每个进程被分配一个时间段，称为时间片（quantum），即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。时间片轮转调度很容易实现，调度程序所要做的就是维护一张可运行进程列表，如图2-42a所示。<ins>当一个进程用完它的时间片后，就被移到队列的末尾</ins>，如图2-42b所示。</p>
<p>拓展：关于时间片长度的取值</p>
<p>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要一定时间进行管理事务处理的————保存和装入寄存器值及内存映像、更新各种表格和列表、清除和重新调入内存高速缓存等。假如进程切换（process switch），有时称为上下文切换（context switch），需要1ms，包括切换内存映像、清除和重新调入高速缓存等。再假设时间片设为4ms。有了这些参数，则CPU在做完4ms有用的工作之后，CPU将花费（即浪费）Ims来进行进程切换。因此，<ins>CPU时间的20%浪费在管理开销上。</ins>很明显，管理时间太多了。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220831103708160.png" class="" title="image-20220831103708160">

<p>但是当我们将时间片设置为100ms时，这样浪费的时间只有1%，但是，如果有50个进程在可运行列表中，第51个进程需要等待至少5秒钟才会得到CPU的资源，对于用户来讲实在是太慢了，所以时间片的大小不宜过大或过小。</p>
<p><ins>可以归结如下结论∶时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20~50ms通常是一个比较合理的折中。</ins></p>
<h4 id="2-优先级调度"><a href="#2-优先级调度" class="headerlink" title="2. 优先级调度"></a>2. 优先级调度</h4><p>轮转调度做了一个隐含的假设，即所有的进程同等重要  。优先级调度基本思想很清楚，即每个进程都被赋予一个优先级，允许优先级最高的可运行进程先运行。（即使在只有一个用户的PC上，也会有多个进程，其中一些比另一些更重要。例如，与在屏幕上实时显示视频电影的进程相比，在后台发送电子邮件的守护进程应该被赋予较低的优先级。）</p>
<p>可以很方便地将一组进程按优先级分成若干类，并在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。图2-43给出了一个有4类优先级的系统，调度算法如下∶只要存在优先级为第4类的可运行进程，较低优先级的进程。若第4类进程为空，则按照轮转法运行第3类进程。若第4类和第3类均为空，则按轮转法运行第2类进程。如果不偶尔对优先级进行调整，则低优先级产生饥饿现象。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220831105157728.png" class="" title="image-20220831105157728">

<p>为了防止高优先级进程无休止地运行下去,低优先级进程产生饥饿现象，调度程序可能在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这一行为导致该进程的优先级低于次高优先级的进程，则进行进程切换。另一种方法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。</p>
<p>优先级可以是静态赋予或动态赋予。</p>
<p>静态赋予：固定某些进程的优先级大小。</p>
<p>动态赋予：例如，有些进程为I&#x2F;O密集型，其多数时间用来等待I&#x2F;O结束。当这样的进程需要CPU时，应立即分配给它CPU，以便启动下一个I&#x2F;O请求，这样就可以在另一个进程计算的同时执行IO操作。使这类I&#x2F;O密集型进程长时间等待CPU只会造成它无谓地长时间占用内存。使I&#x2F;O密集型进程获得较好服务的一种简单算法是，将其优先级设为1&#x2F;f，f为该进程在上一时间片中所占的部分。一个在其50ms的时间片中只使用1ms的进程将获得优先级50，而在阻塞之前用掉25ms的进程将具有优先级2，而使用掉全部时间片的进程将得到优先级1。</p>
<p>另外还有很多其他的调度算法 但我们很少用到，从实用考虑，轮转调度和优先级调度更为常用。</p>
<h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p>&#x2F;&#x2F;TODO</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>当若干进程都有多个线程时，就存在两个层次的并行∶进程和线程。在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<blockquote>
<p>运行时系统使用的调度算法可以是上面介绍的算法中的任意一种。从实用考虑，轮转调度和优先级调度更为常用。</p>
</blockquote>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为A，并给予A以时间片控制。<strong>A中的线程调度程序决定哪个线程运行</strong>，假设为A1。<ins>由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。</ins>如果该线程用完了进程的全部时间片，内核就会选择另一个进程运行。</p>
<p>具体例子：</p>
<p>在进程A终于又一次运行时，线程A1会接着运行。该线程会继续耗费A进程的所有时间，直到它完成工作。不过，该线程的这种不合群的行为不会影响到其他的进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程A内部所发生的事。</p>
<p>现在考虑A线程每次CPU计算的工作比较少的情况，例如，在50ms的时间片中有5ms的计算工作。于是，每个线程运行一会儿，然后把CPU交回给线程调度程序。这样在内核切换到进程B之前，就会有序列A1，A2，A3，A1，A2，A3，A1，A2，A3，A1。这种情形可用图2-44a表示。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220901133852016.png" class="" title="image-20220901133852016">

<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>内核选择一个特定的线程运行。它不用考虑该线程属于哪个进程，不过如果有必要的话，它可以这样做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在50ms的时间片内，5ms之后被阻塞，在30ms的时间段中，线程的顺序会是A1，B1，A2，B2，A3，B3，在这种参数和用户线程状态下，有些情形是不可能出现的。这种情形部分通过图2-44b刻画。</p>
<p>用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在I&#x2F;O上就不需要像在用户级线程中那样将整个进程挂起。</p>
<p><strong>关于线程切换的选择：</strong></p>
<p>从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程（因为必须修改内存映像，清除内存高速缓存的内容），内核对此是了解的，并可运用这些信息做出决定。例如，给定两个在其他方面同等重要的线程，其中一个线程与刚好阻塞的线程属于同一个进程，而另一个线程属于其他的进程，那么应该倾向前者。</p>
<h2 id="经典的IPC问题"><a href="#经典的IPC问题" class="headerlink" title="经典的IPC问题"></a>经典的IPC问题</h2><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者- 写者问题"></a>读者- 写者问题</h3><p>&#x2F;&#x2F;TODO</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存（RAM）是计算机中一种需要认真管理的重要资源。我们将讨论操作系统是怎样对存储器创建抽象模型以及怎样管理它们的。</p>
<h2 id="无存储抽象"><a href="#无存储抽象" class="headerlink" title="无存储抽象"></a>无存储抽象</h2><p>最简单的存储器抽象就是根本没有抽象，每一个程序都直接访问物理内存。</p>
<p>当一个程序执行如下指令∶</p>
<p>MOV REGISTER1,1000</p>
<p>计算机会将位置为1000的物理内存中的内容移到REGISTER1中。因此，呈现给编程人员的存储器模型就是简单的物理内存从0到某个上限的地址集合，每一个地址对应一个可容纳一定数目二进制位的存储单元，通常是8个。</p>
<p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在2000的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。</p>
<p>把物理地址暴露给进程会带来下面几个严重问题。第一，如果用户程序可以寻址内存的每个字节，它们就可以很容易地（故意地或偶然地）破坏操作系统，从而使系统慢慢地停止运行。即使在只有一个用户进程运行的情况下，这个问题也是存在的。第二，使用这种模型，想要同时运行（如果只有一个CPU就轮流执行）多个程序是很困难的。在个人计算机上，同时打开几个程序是很常见的（一个文字处理器，一个邮件程序，一个网络浏览器），其中一个当前正在工作，其余的在按下鼠标的时候才会被激活。在系统中没有对物理内存的抽象的情况下，很难实现上述情景，因此，我们需要其他办法。</p>
<h2 id="一种存储器抽象：地址空间"><a href="#一种存储器抽象：地址空间" class="headerlink" title="一种存储器抽象：地址空间"></a>一种存储器抽象：地址空间</h2><p>要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题∶保护和重定位。</p>
<p>一个好的办法是创造一个新的存储器抽象∶地址空间。就像进程的概念创造了一类抽象的CPU以运行程序一样，<strong>地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间</strong>，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。</p>
<p>比较难的是给每个程序一个自己独有的地址空间，使得一个程序中的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。</p>
<p>如何解决这个问题？</p>
<p>如果计算机物理内存足够大，可以保存所有进程，那我们的讨论也就没什么意义了，因此，把所有进程一直保存在内存中需要巨大的内存空间，如果内存不够，就做不到这一点。</p>
<p>有两种处理内存超载的通用方法。最简单的策略是<strong>交换（swapping）</strong>技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时就不会占用内存（尽管其中的一些进程会周期性地被唤醒以完成相关工作，然后就又进入睡眠状态）。另一种策略是<strong>虚拟内存（virtual memory）</strong>，该策略甚至能使程序在只有一部分被调入内存的情况下运行。</p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>尽管可以创建地址空间的抽象，还有另一个问题需要解决∶管理软件的膨胀（bloatware）。虽然存储器容量增长快速，但是软件大小的增长更快。这一发展的结果是，需要运行的程序往往大到内存无法容纳，而且必然需要系统能够支持多个程序同时运行，即使内存可以满足其中单独一个程序的需要，总体来看它们仍然超出了内存大小。交换技术并不是一个具有吸引力的解决方案。</p>
<p>在20世纪60年代所采取的解决方法是∶ 把程序分割成许多片段，称为覆盖（overlay）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。</p>
<p>采用的这个方法（Fotheringham，1961）称为<strong>虚拟内存</strong>（virtual memory）。虚拟内存的基本思想是∶每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面（page）。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>在任何一台计算机上，程序引用了一组内存地址。当程序执行指令</p>
<p>MOV REG, 1000</p>
<p>时，它把地址为1000的内存单元的内容复制到REG中（或者相反，这取决于计算机的型号）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>由程序产生的这些地址称为<strong>虚拟地址</strong>（virtual address），它们构成了一个虚拟地址空间（virtual address space）。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；<ins>而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到<strong>内存管理单元（Memory Management Unit，MMU）</strong>，MMU把虚拟地址映射为物理内存地址，如图3-8所示。</ins></p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220905114708270.png" class="" title="image-20220905114708270">



<p>图3-9所示的简单例子说明了这种映射是如何工作的。在这个例子中，有一台可以产生16位地址的计算机，地址范围从0到64K-1，且这些地址是虚拟地址。然而，这台计算机只有32KB的物理内存，因此，虽然可以编写64KB的程序，但它们却不能被完全调入内存运行。在磁盘上必须有一个最多64KB的程序核心映像的完整副本，以保证程序片段在需要时能被调入内存。</p>
<p>虚拟地址空间按照固定大小划分成被称为<strong>页面（page）</strong>的若干单元。在物理内存中对应的单元称为<strong>页框（page frame）</strong>。页面和页框的大小通常是一样的，在本例中是4KB，但实际系统中的页面大小从512字节到1GB。对应于64KB的虚拟地址空间和32KB的物理内存，可得到16个虚拟页面和8个页框。RAM和磁盘之间的交换总是以整个页面为单元进行的。很多处理器根据操作系统认为适合的方式，支持对不同大小页面的混合使用和匹配。</p>
<p>图3-9中的标记符号如下∶标记0K<del>4K的范围表示该页的虚拟地址或物理地址是0</del>4095，4K<del>8K的范围表示地址4096</del>8191，等等。每一页包含了4096个地址，起始于4096的整数倍位置，结束于4096倍数缺1的位置。</p>
<p>当程序试图访问地址0时，例如执行下面这条指令</p>
<p>MOV REG,0</p>
<p>将虚拟地址0送到MMU。MMU看到虚拟地址落在页面0（0<del>4095），根据其映射结果，这一页面对应的是页框2（8192</del>12 287），因此MMU把地址变换为8192，并把地址8192送到总线上。内存对MU一无所知，它只看到一个读或写地址8192的请求并执行它。MMU从而有效地把所有从0<del>4095的虚拟地址映射到了8192</del>12287的物理地址。</p>
<p>通过恰当地设置MMU，可以把16个虚拟页面映射到8个页框中的任何一个。但是这并没有解决虚拟地址空间比物理内存大的问题。在图3-9中只有8个物理页框，于是只有8个虚拟页面被映射到了物理内存中，在图3-9中用叉号表示的其他页面并没有被映射。在实际的硬件中，用一个**”在&#x2F;不在”**位（present&#x2F;absent bit）记录页面在内存中的实际存在情况。</p>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>当程序访问了一个未映射的页面，例如执行指令</p>
<p>MOV REG , 32780</p>
<p>将会发生什么情况呢?虚拟页面8（从32768开始）的第12个字节所对应的物理地址是什么呢?MMU注意到该页面没有被映射（在图中用叉号表示），于是使CPU陷入到操作系统，这个陷阱称为<strong>缺页中断</strong>。操作系统找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>作为一种最简单的实现，虚拟地址到物理地址的映射可以概括如下∶虚拟地址被分成虚拟页号（高位部分）和偏移量（低位部分）两部分。</p>
<p><ins>虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。</ins></p>
<p>页表的目的是把虚拟页面映射为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。通过这个函数可以把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220905115555248.png" class="" title="image-20220905115555248">

<p>图3-11中给出了页表项的一个例子。不同计算机的页表项大小可能不一样，但32位是一个常用的大小。最重要的域是页框号。毕竟页映射的目的是找到这个值，其次是“在&#x2F;不在”位。这一位是1时表示该表项是有效的，可以使用；如果是0，则表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个缺页中断。</p>
<p><strong>保护</strong>（protection）位指出一个页允许什么类型的访问。最简单的形式是这个域只有一位，0表示读&#x2F;写，1表示只读。一个更先进的方法是使用三位，各位分别对应是否启用读、写、执行该页面。</p>
<p>为了记录页面的使用状况，引入了<strong>修改</strong>（modified）位和<strong>访问</strong>（referenced）位。在写入一页时由硬件自动设置修改位。该位在操作系统重新分配页框时是非常有用的。如果一个页面已经被修改过（即它是“脏”的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是“干净”的），则只简单地把它丢弃就可以了，因为它在磁盘上的副本仍然是有效的。这一位有时也被称为脏位（dirty bit），因为它反映了该页面的状态。</p>
<p>不论是读还是写，系统都会在该页面被访问时设置访问位。它的值被用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。不再使用的页面要比正在使用的页面更适合淘汰。这一位在即将讨论的很多页面置换算法中都会起到重要的作用。</p>
<blockquote>
<p>在深入到更多应用实现问题之前，值得再次强调的是∶虚拟内存本质上是用来创造一个新的抽象概念————地址空间，这个概念是对物理内存的抽象，类似于进程是对物理处理器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。因此，本节的基本内容是操作系统创建的抽象，以及如何管理这个抽象。</p>
</blockquote>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本；如果该页面没有被修改过（如一个包含程序正文的页面），那么它在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖被淘汰的页面就可以了。</p>
<p><ins>当发生缺页中断时，虽然可以随机地选择一个页面来置换，但是如果每次都选择不常使用的页面会提升系统的性能。如果一个被频繁使用的页面被置换出内存，很可能它在很短时间内又要被调入内存，这会带来不必要的开销。人们已经从理论和实践两个方面对页面置换算法进行了深入的研究。</ins>下面我们将介绍几个最重要的算法。</p>
<p>有必要指出，“页面置换”问题在计算机设计的其他领域中也同样会发生。；例如Web服务器，服务器可以把经常访问的一些Web页面存放在存储器的高速缓存中。但是，当存储器高速缓存已满并且要访问一个不在高速缓存中的页面时，就必须要置换高速缓存中的某个Web页面。在高速缓存中的Web页面不会被修改，因此在磁盘中的Web页面的副本总是最新的，而在虚拟存储系统中，内存中的页面既可能是干净页面也可能是脏页面，除了这一点不同之外，置换Web页面和置换虚拟内存中的页面需要考虑的问题是类似的。</p>
<h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>很容易就可以描述出最好的页面置换算法，虽然此算法不可能实现。该算法是这样工作的∶在缺页中断发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要到10、100或1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。</p>
<p>最优页面置换算法规定应该置换标记最大的页面。如果一个页面在800万条指令内不会被使用，另外一个页面在600万条指令内不会被使用，则置换前一个页面，从而把因需要调入这个页面而发生的缺页中断推迟到将来，越久越好。计算机也像人一样，希望把不愉快的事情尽可能地往后拖延。</p>
<p>这个算法唯一的问题就是它是无法实现的。<ins>因为当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。</ins></p>
<h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><p>为使操作系统能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。<strong>当页面被访问（读或写）时设置R位；当页面被写入（即修改）时设置M位。</strong>这些位包含在每个页表项中，如图3-11所示。每次访问内存时更新这些位，因此由硬件来设置它们是必要的。</p>
<p>一旦设置某位为1，它就一直保持1直到操作系统将它复位。</p>
<p>如果硬件没有这些位，则可以使用操作系统的缺页中断和时钟中断机制进行以下的模拟∶当启动一个进程时，将其所有的页面都标记为不在内存；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置R位（在它的内部表中），修改页表项使其指向正确的页面，并设为READ ONLY模式，然后重新启动引起缺页中断的指令；如果随后对该页面的修改又引发一次缺页中断，则操作系统设置这个页面的M位并将其改为READ&#x2F;WRITE模式。</p>
<p>可以用R位和M位来构造一个简单的页面置换算法∶当启动一个进程时，它的所有页面的两个位都由操作系统设置成0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。</p>
<p>当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类∶</p>
<p>●第0类∶没有被访问，没有被修改。</p>
<p>●第1类∶没有被访问，已被修改。</p>
<p>●第2类∶已被访问，没有被修改。</p>
<p>●第3类已被访问，已被修改。</p>
<p>尽管第1类初看起来似乎是不可能的，但是一个第3类的页面在它的R位被时钟中断清零后就成了第1类。时钟中断不清除M位是因为在决定一个页面是否需要写回磁盘时将用到这个信息。清除R位而不清除M 位产生了第1类页面。</p>
<p><strong>NRU</strong> （Not Recently Used，最近未使用）算法随机地从类编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思是，<strong>在最近一个时钟滴答中（典型的时间是大约20ms）淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好。</strong>NRU的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。</p>
<h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><p>由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。当FIFO用在操作系统时，它可能会把进场读取的页面淘汰掉。由于这一原因，很少使用纯粹的FIFO算法。</p>
<h3 id="最近最少使用页面置换算法（LRU）"><a href="#最近最少使用页面置换算法（LRU）" class="headerlink" title="最近最少使用页面置换算法（LRU）"></a>最近最少使用页面置换算法（LRU）</h3><p>对最优算法的一个很好的近似是基于这样的观察∶在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。这个思想提示了一个可实现的算法∶在缺页中断发生时，置换未使用时间最长的页面。这个策略称为<strong>LRU（Least Recently Used，最近最少使用）页面置换算法。</strong></p>
<p>虽然LRU在理论上是可以实现的，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作，即使使用硬件实现也一样费时（假设有这样的硬件）。</p>
<p>然而，还是有一些使用特殊硬件实现LRU的方法。首先考虑一个最简单的方法，这个方法要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面。</p>
<p>用软件模拟LRU</p>
<p>前面一种LRU算法虽然在理论上是可以实现的，但只有非常少的计算机拥有这种硬件。因此，需要一个能用软件实现的解决方案。一种可能的方案称为<strong>NFU（Not Frequently Used，最不常用）算法</strong>。该算法将每个页面与一个软件计数器相关联，计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它的值是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。</p>
<p>幸运的是只需对NFU做一个小小的修改就能使它很好地模拟LRU。其修改分为两部分∶首先，在R 位被加进之前先将计数器右移一位；其次，将R位加到计数器最左端的位而不是最右端的位。</p>
<p>修改以后的算法称为<strong>老化（aging）算法</strong>，图3-17解释了它是如何工作的。假设在第一个时钟滴答后，页面0～5的R位值分别是1、0、1、0、1、1（页面0为1，页面1为0，页面2为1，以此类推）。换句话说，在时钟滴答0到时钟滴答1期间，访问了页0、2、4、5，它们的R位设置为1，而其他页面的R位仍然是0。对应的6个计数器在经过移位并把R位插入其左端后的值如图3-17a所示。图中后面的4列是在下4 个时钟滴答后的6个计数器的值。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220906103803450.png" class="" title="image-20220906103803450">



<p>发生缺页中断时，将置换计数器值最小的页面。如果一个页面在前面4个时钟滴答中都没有访问过，那么它的计数器最前面应该有4个连续的0，因此它的值肯定要比在前面三个时钟滴答中都没有被访问过的页面的计数器值小。</p>
<p>该算法与LRU有两个区别。如图3-17e中的页面3和页面5，它们都连续两个时钟滴答没有被访问过了，而在两个时钟滴答之前的时钟滴答中它们都被访问过。根据LRU，如果必须置换一个页面，则应该在这两个页面中选择一个。然而现在的问题是，我们不知道在时钟滴答1到时钟滴答2期间它们中的哪一个页面是后被访问到的。因为在每个时钟滴答中只记录了一位，所以无法区分在一个时钟滴答中哪个页面在较早的时间被访问以及哪个页面在较晚的时间被访问，因此，我们所能做的就是置换页面3，原因是页面5在更往前的两个时钟滴答中也被访问过而页面3没有。</p>
<p>LRU和老化算法的第二个区别是老化算法的计数器只有有限位数（本例中是8位），这就限制了其对以往页面的记录。如果两个页面的计数器都是0，我们只能在两个页面中随机选一个进行置换。实际上，有可能其中一个页面上次被访问是在9个时钟滴答以前，另一个页面是在1000个时钟滴答以前，而我们却无法看到这些。在实践中，如果时钟滴答是20ms，8位一般是够用的。假如一个页面已经有160ms没有被访问过，那么它很可能并不重要。</p>
<p><a href="https://blog.csdn.net/belongtocode/article/details/102989685">(46条消息) 全面讲解LRU算法_Apple_Web的博客-CSDN博客_lru算法</a></p>
<p><a href="https://blog.csdn.net/qq_44819554/article/details/123499439?ops_request_misc=&request_id=&biz_id=102&utm_term=lru%E7%AE%97%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-123499439.nonecase&spm=1018.2226.3001.4187">(59条消息) LRU缓存算法_猿系人生的博客-CSDN博客_lru算法</a></p>
<h3 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h3><p>&#x2F;&#x2F;TODO</p>
<h3 id="页面置换算法总结"><a href="#页面置换算法总结" class="headerlink" title="页面置换算法总结"></a>页面置换算法总结</h3><img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220906103128847.png" class="" title="image-20220906103128847">

<p>总之，最好的两种算法是老化算法和工作集时钟算法，它们分别基于LRU和工作集。它们都具有良好的页面调度性能，可以有效地实现。也存在其他一些算法，但在实际应用中，这两种算法可能是最重要的。</p>
<h2 id="分页系统中的设计和实现问题"><a href="#分页系统中的设计和实现问题" class="headerlink" title="分页系统中的设计和实现问题"></a>分页系统中的设计和实现问题</h2><p>&#x2F;&#x2F;TODO</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在进程对设备，文件等取得了排他性访问权的时候，有可能出现死锁。我们把这类需要排他性使用的对象称之为资源。资源就是随着时间的推移，必须能够获得，使用以及释放的任何东西。</p>
<h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源分为两类，可抢占性的和不可抢占性的。</p>
<p><strong>可抢占性资源</strong>可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占资源。</p>
<p><strong>不可抢占资源</strong>是指在不引起相关的计算失败的条件下，无法把它从占有它的进程处抢回来。</p>
<p>使用一个资源的过程大致如下：</p>
<p>1）请求资源</p>
<p>2）使用资源</p>
<p>3）释放资源</p>
<p>若请求时资源不可用，则请求进程被迫等待。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220913150751853.png" class="" title="image-20220913150751853">

<h2 id="死锁简介"><a href="#死锁简介" class="headerlink" title="死锁简介"></a>死锁简介</h2><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
<p>多数情况下，每个进程所等待的事件时释放进程集合中其他进程所占用的资源。一个死锁进程集合中的每一个进程都在等待另个死锁进程的进程已经占有的资源。但是由于所有进程都不能运行，他们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒。这类的死锁也成为资源死锁。</p>
<h3 id="形成死锁的条件"><a href="#形成死锁的条件" class="headerlink" title="形成死锁的条件"></a>形成死锁的条件</h3><ol>
<li><p>互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。</p>
</li>
<li><p>占有和等待条件。已经占有了某个资源的进程可以再请求新资源。</p>
</li>
<li><p>不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被持有它的进程显示的释放，</p>
</li>
<li><p>环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。</p>
</li>
</ol>
<p>死锁发生时，以上的四个条件都会满足，任何一个条件不成立，死锁就不会发生。</p>
<p>解决死锁的两种可行策略：</p>
<ol>
<li>仔细对资源进行分配，动态地避免死锁。</li>
<li>通过破坏引起死锁的四个必要条件之一，防止死锁的产生。</li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>大多数情况下，一个进程一次只请求一个资源，系统必须能够判断分配资源是否安全，并且在保证安全的前提下分配资源，问题是，是否存在一种算法总能做出正确选择从而避免死锁？答案是肯定的。接下来讨论一下避免死锁的几种办法。</p>
<h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>小镇的银行家承诺分发个一些客人贷款，但是他需要判断，在资源可分配的情况下，能否根据不同的顺序，以保证资源足够所有人分配？这里的客人比作进程，金额比作资源，银行家比作操作系统。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220913161245737.png" class="" title="image-20220913161245737">

<p>图6-11b所示，银行家将空闲的两个资源分配给c，满足了c的需求后，c将所有已持有的资源释放，就存在4个空闲的资源，再将着4个空闲的资源分配给b，b满足需求后也会释放，以此类推，直到所有客户都满足了他们的条件。图6-11c代表一个死锁的状态，剩余的资源无论分配给谁都无法让客户释放已有资源，所以所有客户都无法满足自己的需求。</p>
<p>如果所有投资都被收回，那么状态就是安全的。</p>
<h3 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h3><img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220913161821302.png" class="" title="image-20220913161821302">

<p>左面的5个矩阵为分别已分配的各个资源数，右边的资源显示了使个进程完成运行所需要的各种资源数。最右边的三个向量分别表示现共有资源E，已分配资源P，可用资源A。E表示6台磁带机，3台绘图仪，4台打印机，2台蓝光光驱。</p>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>通过前面的学习我们知道，死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。那么实际的系统又是如何避免死锁的呢? 如果能够保证四个条件中至少有一个不成立，那么死锁将不会产生(Havender,1968)。</p>
<p><strong>破坏互斥条件</strong></p>
<p><strong>破坏占有等待条件</strong></p>
<p><strong>破坏不可抢占条件</strong></p>
<p><strong>破坏环路等待条件</strong></p>
<h2 id="关于死锁的其他问题"><a href="#关于死锁的其他问题" class="headerlink" title="关于死锁的其他问题"></a>关于死锁的其他问题</h2><h1 id="Linux-的操作系统"><a href="#Linux-的操作系统" class="headerlink" title="Linux 的操作系统"></a>Linux 的操作系统</h1><h2 id="Linux的简介"><a href="#Linux的简介" class="headerlink" title="Linux的简介"></a>Linux的简介</h2><p>一个Linux系统可被看成一座金字塔，如图10-1所示。最底层的是硬件，包括CPU、内存、磁盘、显示器、键盘以及其他设备。运行在硬件之上的是操作系统。它的作用是控制硬件并且为其他程序提供系统调用接口。这些系统调用允许用户程序创立并管理进程、文件以及其他资源。</p>
<img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220919092942173.png" class="" title="image-20220919092942173">

<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>尽管Linux系统具有图形用户界面，然而大多数程序员和高级用户都更愿意使用一个命令行界面，称作shell。通常这些用户在图形用户界面中启动一个或更多的shell窗口，然后就在这些shell窗口中工作。shell命令行界面使用起来更快速，功能更强大，扩展性更好。接下来我们简要介绍一下bash shell（bash）。经常使用的还有很多其他的shell（ksh和csh等），但是bash是大多数Linux系统的默认shell。</p>
<p>当shell被启动时，它初始化自己，然后在屏幕上输出一个提示符（prompt），通常是一个百分号或者美元符号，并等待用户输入命令行。</p>
<p>等用户输入一个命令行后，shell提取其中的第一个字，这里的字指的是被空格或制表符分隔开的一连串字符。假定这个字是将要运行程序的程序名，搜索这个程序，如果找到了这个程序就运行它。然后，shell会将自己挂起直到该程序运行完毕，之后再尝试读入下一条命令。重要的是，shell也只是一个普通用户程序。它仅仅需要从键盘读取数据、向显示器输出数据和运行其他程序的能力。</p>
<p>关于shell的应用程序分类：<strong>文件和目录操作命令，通配符，编辑器，系统管理，过滤器，管道符，shell脚本。</strong></p>
<h2 id="linux内核结构"><a href="#linux内核结构" class="headerlink" title="linux内核结构"></a>linux内核结构</h2><img src="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220919094927824.png" class="" title="image-20220919094927824">
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h3><h4 id="回归方程"><a href="#回归方程" class="headerlink" title="回归方程"></a>回归方程</h4><p>假设场景是去银行贷款 银行看重两个参数：1.工资水平 2. 年龄大小 根据这两个因素决定—-&gt;贷款金额</p>
<img src="/2024/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20240406103644677.png" class="" title="image-20240406103644677">

<p>θ1 θ2 为权重参数</p>
<p>将方程转化为矩阵，新添加x0列 其中数据都为1 （目的：整合为矩阵 方便整合计算）</p>
<h4 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h4><img src="/2024/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20240406104432153.png" class="" title="image-20240406104432153">



]]></content>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2025/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-机器学习的概念"><a href="#1-机器学习的概念" class="headerlink" title="1.机器学习的概念"></a>1.机器学习的概念</h2><p>涉及概率论，统计学，逼近论，算法复杂度理论等多门学科。专门研究计算机怎么模拟或实现人类的学习行为，以获取新的知识或技能。</p>
<p>定位：人工智能的核心 主要使用归纳 综合</p>
<p>定义：探究和开发一系列的算法来如何使计算机不需要外部的指示，可以自己通过数据来学习，建模，并利用好建模和新的输入来进行预测的学科。</p>
<h2 id="1-深度学习的概念"><a href="#1-深度学习的概念" class="headerlink" title="1.深度学习的概念"></a>1.深度学习的概念</h2><p>deep Learning 是机器学习的一个分支 是一种以人工神经网络为架构 对数据进行特征学习的算法</p>
<p>机器学习 手动进行数据提取 </p>
<p>深度学习 帮助自动进行数据提取</p>
<h2 id="2-深度学习和机器学习的区别"><a href="#2-深度学习和机器学习的区别" class="headerlink" title="2. 深度学习和机器学习的区别"></a>2. 深度学习和机器学习的区别</h2><p>机器学习是需要人工选取数据进行下一轮的数据输入</p>
<p>深度学习采用智能方式自动提取数据进行特征值的选取，加强训练</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>留言页</title>
    <url>/2022/08/12/%E7%95%99%E8%A8%80%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="期待你留下你的足迹！"><a href="#期待你留下你的足迹！" class="headerlink" title="期待你留下你的足迹！"></a>期待你留下你的足迹！</h1>]]></content>
      <categories>
        <category>comments</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习入门</title>
    <url>/2025/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>算法举例</p>
<p>K近邻算法：</p>
<p><img src="https://picx.zhimg.com/70/v2-c3f1d2553e7467d7da5f9cd538d2b49a_1440w.image?source=172ae18b&biz_tag=Post" alt="一文搞懂k近邻（k-NN）算法（一）"></p>
<p>只讨论<strong>分类</strong>问题的k近邻法：</p>
<p>K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例<strong>最邻近</strong>的K个实例，<strong>这K个实例的多数属于某个类</strong>，就把该输入实例分类到这个类中。（<strong>根据身边的成分判断他本身未知的成分</strong>）</p>
<ul>
<li>如果K&#x3D;3，绿色圆点的最邻近的3个点是2个红色和1个蓝色，<strong>少数从属于多数，</strong>判定绿色的这个待分类点属于红色的一类。</li>
<li>如果K&#x3D;5，绿色圆点的最邻近的5个邻居是2个红色和3个蓝色，<strong>还是少数从属于多数，</strong>判定绿色的这个待分类点属于蓝色的一类。</li>
</ul>
<p><strong>k怎么确定的，k为多少效果最好呢？所谓的最近邻又是如何来判断给定呢？</strong></p>
<span id="more"></span>

<h2 id="k近邻算法中k的选取以及特征归一化的重要性"><a href="#k近邻算法中k的选取以及特征归一化的重要性" class="headerlink" title="k近邻算法中k的选取以及特征归一化的重要性"></a><strong>k近邻算法中k的选取以及特征归一化的重要性</strong></h2><ol>
<li><p>假设我们选取<strong>k&#x3D;1</strong>这个极端情况，怎么就使得模型变得复杂，又<strong>过拟合</strong>了呢？</p>
<p>过拟合就是在训练集上准确率非常高，而在测试集上准确率低。</p>
</li>
</ol>
<p><img src="https://pic4.zhimg.com/v2-6911dd1ce577c9fd6842cbd2ee68a309_1440w.png" alt="img"></p>
<p>如果k太小了，比如等于1，那么模型就太复杂了，<strong>我们很容易学习到噪声</strong></p>
<p>经过上例，我们可以得到k太小会导致<strong>过拟合</strong>，<strong>很容易将一些噪声（如上图离五边形很近的黑色圆点）学习到模型中，而忽略了数据真实的分布！</strong></p>
<ol start="2">
<li>如果我们选取<strong>较大的k值</strong>，就相当于用较大邻域中的训练数据进行预测，这时与<strong>输入实例较远</strong>的（不相似）训练实例也会对预测起作用，使预测发生错误，<strong>k值的增大意味着整体模型变得简单</strong>。</li>
</ol>
<p><img src="https://pic1.zhimg.com/v2-e79d46a56c426061a9494091f8fac068_1440w.png" alt="img"></p>
<p>如果<strong>k&#x3D;N（N为训练样本的个数）</strong>,那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型是不是非常简单，这相当于你压根就没有训练模型。这个图中，K&#x3D;N 则会将红色判断为黑色类别，明显错误。</p>
<ol start="3">
<li><p><strong>k值既不能过大，也不能过小</strong></p>
<p><img src="https://pic1.zhimg.com/v2-b7dc18ee84e5c099c21fbaa175a7b9c6_1440w.png" alt="img"></p>
</li>
</ol>
<p>能达到图中的效果是最好的</p>
<p><strong>选取k值很重要的关键是实验调参，类似于神经网络选取多少层这种，通过调整超参数来得到一个较好的结果</strong></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2022/07/11/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最懒的人就是整天忙得没时间学习、反思、成长的人。"><a href="#最懒的人就是整天忙得没时间学习、反思、成长的人。" class="headerlink" title="最懒的人就是整天忙得没时间学习、反思、成长的人。"></a><strong>最懒的人就是整天忙得没时间学习、反思、成长的人。</strong></h1><span id="more"></span>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><img src="/2022/07/11/%E7%AE%97%E6%B3%95/image-20230417125933502.png" class="" title="image-20230417125933502">

<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="所有位运算的基本规则"><a href="#所有位运算的基本规则" class="headerlink" title="所有位运算的基本规则"></a>所有位运算的基本规则</h2><p><strong>与&amp;：</strong>						<strong>或|:</strong></p>
<p>0&amp;0&#x3D;0;					0|0&#x3D;0；    </p>
<p>0&amp;1&#x3D;0;  				  0|1&#x3D;1；</p>
<p>1&amp;0&#x3D;0;  				  1|0&#x3D;1；</p>
<p>1&amp;1&#x3D;1;				    1|1&#x3D;1；</p>
<p><strong>异或：</strong>						<strong>同或：</strong>(同或运算 &#x3D; 异或运算  ^  1)用同或结果^1表示</p>
<p>0^0 &#x3D; 0，					0^0 &#x3D; 1，</p>
<p>1^0 &#x3D; 1，					1^0 &#x3D; 0，</p>
<p>0^1 &#x3D; 1，					0^1 &#x3D; 0，</p>
<p>1^1 &#x3D; 0						1^1 &#x3D; 1</p>
<p><strong>左移运算符（&lt;&lt;）</strong></p>
<p>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。相当于乘2。</p>
<p>例：a &#x3D; a&lt;&lt; 2将a的二进制位左移2位，右补0，（左移过程，高位舍弃，低位补 0）</p>
<p><strong>右移运算符（&gt;&gt;）</strong></p>
<p>将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>
<p>操作数每右移一位，相当于该数除以2。</p>
<p>例如：a &#x3D; a&gt;&gt; 2 将a的二进制位右移2位（右移过程，低位舍弃，高位：正数补 0，负数补符号位 1）</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>三个遍历</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>先根节点      再左子节点     最后右子节点</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>先左子节点    再根节点       最后右子节点</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先左子节点     再右子节点   最后根节点</p>
<p>前中后遍历的<strong>顺序都是针对于根节点</strong>来说的 前中后的顺序就是遍历的根节点的顺序 但无论是哪个遍历方式 左右子节点的顺序都是先左后右。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度 - 力扣（LeetCode）</a></p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>左子节点&lt;根节点&lt;右子节点</p>
<p>题目：</p>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2022/06/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>什么是线程池？</strong></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661">线程池_百度百科 (baidu.com)</a></p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在<a href="https://baike.baidu.com/item/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81/2886980">托管代码</a>中空闲（如正在等待某个事件）,则线程池将插入另一个<a href="https://baike.baidu.com/item/%E8%BE%85%E5%8A%A9%E7%BA%BF%E7%A8%8B/4746601">辅助线程</a>来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>说实话，百度的答案我没看懂。</p>
<span id="more"></span>

<h2 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h2><p>当我们线程创建过多时，容易引发内存溢出，因此我们就有必要使用线程池的技术了。</p>
<p><strong>创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？</strong></p>
<ol>
<li>核心参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数量大小 </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 线程池最大容纳线程数 </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, // 线程空闲后的存活时长 </span></span><br><span class="line"><span class="params">                          TimeUnit unit, //缓存异步任务的队列 //用来构造线程池里的worker线程 </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程池任务满载后采取的任务拒绝策略 </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>核心说明</li>
</ol>
<ol>
<li>当线程池中线程数量小于 corePoolSize 则创建线程，并处理请求。</li>
<li>当线程池中线程数量大于等于 corePoolSize 时，则把请求放入 workQueue 中,随着线程池 中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从 workQueue 中取 任务并处理。</li>
<li>当 workQueue 已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目 达到maximumPoolSize（最大线程数量设置值）。</li>
<li>如果线程池中线程数大于 maximumPoolSize 则使用 RejectedExecutionHandler 来进行任 务拒绝处理。</li>
</ol>
<ol start="3">
<li>线程池大小分配</li>
</ol>
<p>线程池究竟设置多大要看你的线程池执行的什么任务了，CPU密集型、IO密集型、混合型，任 务类型不同，设置的方式也不一样。 </p>
<p>任务一般分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线 程池。</p>
<p>3.1）CPU密集型 </p>
<p>尽量使用较小的线程池，一般Cpu核心数+1</p>
<p>3.2）IO密集型 </p>
<p>方法一：可以使用较大的线程池，一般CPU核心数 * 2 </p>
<p>方法二：（线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
<p>3.3）混合型 可以将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，按情况而定</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>因特网是一个世界范围的计算机网络，是一个互联了遍及全世界数十亿计算设备的网络。</p>
<p>我们通常理解为 计算机主机和端系统代指相同的东西。端系统通过通信链路和分组交换机连接到一起。通信链路通常由物理媒体构成。不同的链路能够以不同的速率传输数据，链路的传输速率为比特&#x2F;秒（bit&#x2F;s）度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，这样形成的信息在计算机网络中称为<strong>分组</strong>。</p>
<p>端系统通过因特网服务提供商（<strong>ISP</strong>）接入互联网。</p>
<span id="more"></span>

<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>端系统，分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP（传输控制协议）和IP（网际协议）是因特网中最为重要的两个协议。<strong>因特网的主要协议统称为TCP&#x2F;IP</strong>。</p>
<p>人类活动在计算机网络协议中的类比：</p>
<p>（我更喜欢这个例子）假如你正在大学课堂听课，任课老师正在孜(lao)孜(lao)不(dao)倦(dao) 地讲述计算机网络协议，而你却疑惑不解，这名教师停下问：“同学们有什么问题吗？”（教师发出了一个报文，该报文没有被所有没有睡觉的学生接收到。）你举起了手（向教师发出了一个隐含的报文）。这名教师面带微笑地示意你说：“请讲……”(教师发出的这个报文表示他看到你举手想要提出问题)。接着你就问了问题（向该教师传输了你的报文）。这就是一个连接建立的过程。</p>
<p><strong>协议</strong>定义了在两个或多个通信通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作。</p>
<p>主机&#x3D;端系统</p>
<p>主机又分为客户端和服务器。 </p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220830145042545.png" class="" title="image-20220830145042545">

<h2 id="网路核心："><a href="#网路核心：" class="headerlink" title="网路核心："></a>网路核心：</h2><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中，端系统彼此交换报文，报文能够包含协议设计者需要的任何东西。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为<strong>分组</strong>。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要分为两类：路由器和链路层交换机）<strong>分组以等于在该链路最大传输速率的速度传输通过通信链路。</strong></p>
<p><strong>存储转发传输</strong></p>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>机制。该机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p>路由器在转发前需要接受，存储和处理整个分组。</p>
<h3 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h3><p>每台分组交换机由多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（输出队列），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该分组必须在输出缓存中等待。因此 除了存储转发时延以外，分组还要承受输出缓存的排队时延。</p>
<p>因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在这种情况下，将出现分组丢失（丢包）到达的分组或已经排队的分组之一将被丢弃。</p>
<h3 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h3><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等物理介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p>
<p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong></p>
<p>在电路交换网络中，端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源，但是在分组交换网络中，这些资源是不预留的。</p>
<p>&#x2F;&#x2F;TODO 电路交换的具体实现</p>
<p>二者对比：</p>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="分组交换中的时延，丢包和吞吐量"><a href="#分组交换中的时延，丢包和吞吐量" class="headerlink" title="分组交换中的时延，丢包和吞吐量"></a>分组交换中的时延，丢包和吞吐量</h2><p>因为在理想状态下，我们可以随心所欲的在端到端进行数据的传输。可现实中，计算机网络必定要限制在端系统之间的吞吐量（每秒能够传输的数据量），在端系统之间引入时延的概念，并且实际上也会丢失分组。</p>
<h3 id="节点时延"><a href="#节点时延" class="headerlink" title="节点时延"></a>节点时延</h3><p>分组从一台主机出发，通过一系列路由器传输，在另一条主机中结束他的历程。</p>
<p>当分组从一个节点（主机或路由器）沿着这条路径到后继结点（主机或路由器），该分组在沿途的每个节点经受了几种不同类型的时延。这些时延最为重要的是节点处理时延（nodlal processing delay）、排队时延（queuing delay）、传输时延（transmission delay）和传播时延（propagation delay），这些时延总体累加起来是<strong>节点总时延</strong>（total nodal delay）。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831124803715.png" class="" title="image-20220831124803715">

<h4 id="1-处理时延"><a href="#1-处理时延" class="headerlink" title="1. 处理时延"></a>1. 处理时延</h4><p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。</p>
<p>处理时延也能够包括其他因素，如检查比特级别的差错所需要的时间，该差错出现在从上游节点向路由器 传输这些分组比特的过程中 高速路由器的处理时延通常是微秒或更低的数量在这种节点处理之后，路由器将该分组引向通往路由器 链路之前的队列。</p>
<h4 id="2-排队时延"><a href="#2-排队时延" class="headerlink" title="2. 排队时延"></a>2. 排队时延</h4><p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。实际的排队时延可以是毫秒到微秒量级。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831133536281.png" class="" title="image-20220831133536281">

<p> 节点时延的最为复杂和有趣的成分是排队时延。什么时候排队时延大，什么时候又不大呢?该问题的答案很大程度取决于流量到达该队列的速率、链路的传输速率和到达流量的性质，即流量是<ins>  周期性到达  还是  突发形式到达 </ins>。为了更深入地领会某些要点，令<strong>a</strong>表示分组到达队列的<strong>平均速率</strong>（a的单位是分组&#x2F;秒，即pkt&#x2F;s）。<strong>R</strong>是<strong>传输速率</strong>，即从队列中推出比特的速率（以bps即b&#x2F;s为单位）。为了简单起见，也假定所有分组都是由L比特组成的。则比特到达队列的<strong>平均速率是La bps</strong>。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。<strong>比率La&#x2F;R被称为流量强度</strong>（traffic intensity），它在估计排队时延的范围方面经常起着重要的作用。如果La&#x2F;R&gt;1，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大!因此,<strong>设计系统时流量强度不能大于1。</strong></p>
<p>现在考虑La&#x2F;R≤1时的情况。这时，到达流量的性质影响排队时延。例如，如果分组周期性到达，即每L&#x2F;R秒到达一个分组，则每个分组将到达一个空队列中，不会有排队时延。另一方面，如果分组以突发形式到达而不是周期性到达，则可能会有很大的平均排队时延。例如，假定每（L&#x2F;R）N秒同时到达N个分组。则传输的第一个分组没有排队时延；传输的第二个分组就有L&#x2F;R秒的排队时延；更为一般地，第n个传输的分组具有（n-1）L&#x2F;R秒的排队时延。</p>
<p>图1-18的一个重要方面是这样一个事实∶随着流量强度接近于1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加。</p>
<h5 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h5><p>在现实中,一条链路前的队列只有有限的容量,尽管排队容量极大地依赖于路由器设计和成本.因为该排队容量是有限的,随着流量强度接近1,排队时延并不真正趋向无穷大。相反，<ins>到达的分组将发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃(drop)该分组。</ins> 即该分组将<strong>会丢失</strong>(lost).当流量强度大于1时,队列中的这种溢出。</p>
<p>从端系统的角度看,上述丢包现象看起来是一个分组已经传输到网络核心,但它绝不会从网络发送到目的地.分组丢失的比例随着流量强度增加而增加。因此,<ins>一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量</ins>。丢失的分组可能基于端到端的原则重传,以确保所有的数据最终从源传送到了目的地。</p>
<h4 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3.传输时延"></a>3.传输时延</h4><p>假定分组以先到先服务方式传输————这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用<strong>L</strong>比特表示该分组的长度，用<strong>R</strong> bps （即b&#x2F;s）表示从路由器A到路由器B的链路传输速率。例如，对于一条10Mbps的以太网链路，速率R&#x3D;10Mbps；对于100Mbps的以太网链路，速率R&#x3D;100Mbps。<strong>传输时延是L&#x2F;R</strong>。这是将所有分组的比特推向链路（即传输，或者说发射）所需要的时间。实际的传输时延通常在毫秒到微秒量级。</p>
<h4 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4. 传播时延"></a>4. 传播时延</h4><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B 传播所需要的时间是传播时延。该比特以该链路的传播速率传播。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是d&#x2F;s，其中d是路由器A和路由器B之间的距离，s是该链路的传播速率。一旦该分组的最后一个比特传播到节点B，该比特及前面的所有比特被存储于路由器B。整个过程将随着路由器B 执行转发而持续下去。在广域网中，传播时延为毫秒量级。</p>
<h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><p>我们计算了一个点（路由器）的时延，接下来我们计算一下从源到目的地的总时延。<ins>假设该网络此时是无拥塞的（因此排队时延可以忽略不计）</ins>，在每台路由器和源主机上的处理时延是d（proc） 每台路由器和源主机的输出速率是 R bps，d（trans）&#x3D; L &#x2F; R ，L为分组长度，每条链路的传播时延是d（prop），累加起来即可得到端到端时延。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901090110660.png" class="" title="image-20220901090110660">

<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804142611346-16595943730113.png" class="" title="image-20220804142611346">



<p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。国际标准化组织 ISO 于1977年提 出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI&#x2F;RM，简称为OSI，但它既复杂又不实用</p>
<p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则， 比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<p>本文针对<strong>TCP&#x2F;IP</strong> <strong>四层</strong>体系结构进行解析：</p>
<h2 id="网络数据封装过程"><a href="#网络数据封装过程" class="headerlink" title="网络数据封装过程"></a>网络数据封装过程</h2><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70.png" class="" title="img">

<p>应用层产生的数据叫上层数据，往下走，在传输层加上TCP头部，打包后在网络层再加上IP头部，打包后在数据链路层再加上MAC头部，打包后在物理层封装成信号发出去。传输到了目标主机，目标主机通过网口接收到信号，再进行解封装，一步一步的去掉相应的头部，最后得到上层数据即有效的数据。</p>
<p>发送方完成封装过程，接收方完成解封装过程</p>
<h2 id="数据解封装过程："><a href="#数据解封装过程：" class="headerlink" title="数据解封装过程："></a>数据解封装过程：<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70-16612297906722.png" class="" title="img"></h2><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><a href="https://zhuanlan.zhihu.com/p/428372105">应用层协议详解 - 知乎 (zhihu.com)</a></p>
<p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应 用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和 交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域 名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等 等。</p>
<p>在 TCP&#x2F;IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了<strong>管理通信连接</strong>的会话层功能、<strong>数据格式转换</strong>的表示层功能，还包括<strong>主机间交互</strong>的应用层功能。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804152634329-16595979954344.png" class="" title="image-20220804152634329">



<p>TCP&#x2F;IP 模型中应用层位于传输层之上，<strong>传输层的端口号用于标识数据所对应的应用层协议</strong>。也就是说，有端口号的协议都是<strong>应用层协议</strong>。应用协议是终端设备之间的应用通信规则。应用之间交互的信息叫<strong>消息</strong>，应用协议定义这些消息的格式以及消息的控制或操作的规则。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3fff05a4c9cc787c8c0abaf2e7d20097_720w.jpg" alt="img"></p>
<h2 id="应用协议的通信方式"><a href="#应用协议的通信方式" class="headerlink" title="应用协议的通信方式"></a>应用协议的通信方式</h2><p>应用程序所使用的主流体系结构可分为两类：</p>
<ul>
<li><p>服务器和客户端模型</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620.png" class="" title="img">
</li>
<li><p>P2P 模型</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612303375515.png" class="" title="img"></li>
</ul>
<p>在<strong>服务器和客户端模型</strong>中，始终公开固定 IP 地址的主机为其它主机的应用程序提供服务，请求服务的主机之间不会互相通信。这些为其它主机提供服务的终端设备称为<strong>服务器</strong>，那些请求服务的主机则称为<strong>客户端</strong>。大多数应用层协议，都是这种模型。</p>
<p>在 <strong>P2P 模型</strong>中，没有特定的服务器或客户端，这些设备上安装的应用程序，可以在主机间建立对等连接，既可以提供服务，也可以接受服务。通常是大流量的应用程序采用 P2P 模型，比如：下载器等。</p>
<p>两种方式的对比：</p>
<h3 id="Client和Server模式"><a href="#Client和Server模式" class="headerlink" title="Client和Server模式"></a>Client和Server模式</h3><ol>
<li><p>服务器主机是总是打开的， 客户机主机则并不总是打开</p>
</li>
<li><p>服务器是处理所有逻辑的中心</p>
</li>
<li><p>基于2的原因，两个客户机一般是不能直接通信的， 要进行通信必须经过服务器</p>
</li>
<li><p>虽然客户机&#x2F;服务器体系结构的特征是“一对多”，但是服务器却并不总是一台，因为有的时候要处理海量的客户机的请求， 一台服务器很快就会不堪重负，所以这个时候常用服务器集群技术（server clustering）创建强大的虚拟服务器。所以这里“一对多”的一要理解为一组服务器组成的“一”个整体的意思。</p>
</li>
<li><p>由于4的原因，客户机&#x2F;服务器体系的应用服务通常是基础设施密集的（infrastructure intensive）,也就是说，提供该服务的互联网商家，例如搜索引擎（百度），网络商务（淘宝）通常要为服务器场的购买，安装和维护投入巨额的费用。</p>
</li>
</ol>
<h3 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612305786968.png" class="" title="img">

<ol>
<li><p>客户机间的直接通信使得P2P有了强大的自扩展性（self-calability），什么意思呢？ 假设上面这幅图是一个发送文件（上载&#x2F;下载）文件的过程，我们可以看到，从上至下，接收文件的主机的数量是指数递增的，系统的服务能力在逐渐增强，而且越来越强。</p>
</li>
<li><p>P2P体系结构对基础设施服务器有最小的依赖， 这是和基础设施密集的客户机&#x2F;服务器体系结构是截然相反的。</p>
</li>
</ol>
<h2 id="进程通信（套接字，端口号）"><a href="#进程通信（套接字，端口号）" class="headerlink" title="进程通信（套接字，端口号）"></a>进程通信（套接字，端口号）</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信的情况有一个基本了解。用操作系统的术语来说，进行通信的实际上是<strong>进程</strong>（process）而不是程序。当多个进程xxxxxxxxxxxxxxxxxxx运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831135244309.png" class="" title="image-20220831135244309">

<p>进程于计算机网络之间的接口：进程通过一个称为<strong>套接字</strong>（sock-et）的软件接口向网络发送报文和从网络接收报文。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（Application Programming Interface，<strong>API</strong>）。</p>
<p>除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字）。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地<strong>端口号</strong>（port number）用于这个目的。</p>
<h2 id="应用层和运输层的工作衔接"><a href="#应用层和运输层的工作衔接" class="headerlink" title="应用层和运输层的工作衔接"></a>应用层和运输层的工作衔接</h2><p>运输层提供了不止一种运输层协议。当开发一个应用时，应该选择一种合适的运输层协议，如果做出这种选择呢？我么应该研究这些可用的运输层协议所提供的服务。</p>
<ol>
<li>可靠数据传输</li>
</ol>
<p>这种服务确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。</p>
<ol start="2">
<li>吞吐量</li>
</ol>
<p>运输层协议能够以某种特定的速率提供确保的可用吞吐量。具有<strong>吞吐量要求的应用程序</strong>被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application）。许多当前的多媒体应用是带宽敏感的，尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求，而弹性应用（elastic application）能够根据当时可用的带宽或多或少地利用可供使用的吞吐量。电子邮件、文件传输以及Web传送都属于弹性应用。</p>
<ol start="3">
<li>定时</li>
</ol>
<p>运输层协议也能提供定时保证。定时保证能够以多种形式实现，一个保证的例子如∶发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。这种服务将对交互式实时应用程序有吸引力。</p>
<ol start="4">
<li>安全性</li>
</ol>
<p>最后，运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。 </p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p><strong>应用程序</strong>有很多，包括 Web 浏览器、电子邮件、远程登录、文件传输、网络管理等。这些应用程序都会使用应用协议进行通信，应用协议正是为了实现应用程序的功能而设计和创造的。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-bef9ba3e565d2e170260b75b2b94c161_r.jpg" class="" title="preview">

<h3 id="1-远程登陆"><a href="#1-远程登陆" class="headerlink" title="1. 远程登陆"></a>1. 远程登陆</h3><h3 id="8-Http协议"><a href="#8-Http协议" class="headerlink" title="8.Http协议"></a>8.Http协议</h3><p>应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP），HTTP使用TCP作为它的支撑运输协议。</p>
<p>当用户在浏览器的地址栏里输入 Web 页的 URL 后，HTTP 的处理就开始了。<strong>HTTP</strong> 默认使用 80 端口。它的工作机制，<em>首先是客户端向服务器的 80 端口建立一个 TCP 连接，然后在这个 TCP 连接上进行请求和应答以及数据报文的发送。</em></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509224724959.png" class="" title="img">

<p>HTTP 中常用的有两个版本，一个是 <strong>HTTP 1.0</strong> ，另一个是 <strong>HTTP 1.1</strong> 。在HTTP 1.0 中每一个命令和应答都会触发一次 TCP 连接的建立和断开，非持续连接有一些缺点。第一，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，第二，每一个对象经受两倍RTT（往返时间）的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。而从 HTTP 1.1 开始，允许在一个 TCP 连接上发送多个命令和应答，这种方式也叫<strong>持续连接</strong>（ keep-alive ）。可以大量减少 TCP 连接的建立和断开操作，提高传输效率。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-3c1a52d9036fd7bbb3e060125c6bf1a8_r.jpg" class="" title="preview">

<p>详解 Connection：</p>
<p>HTTP 是应用层协议，HTTP 用的是下层的 TCP协议，而 TCP 是保证可靠性的。<br>TCP 为了保证可靠性，所以 TCP 是面向连接的。<br>TCP 面向连接之前必须先建立连接——&gt; HTTP 向通信就要在底层先把连接建立好。然后，发送方根据已经建立好的连接向服务器发送一个请求。<br>发过去之后对方就可以根据这个完整地读出来，对方再分析这个报文，然后对这个报文做出响应，HTTP 请求结束，之后断开连接。<br>这种一来一回的形式成为短连接（一次请求一个）</p>
<h4 id="Http数据格式解析"><a href="#Http数据格式解析" class="headerlink" title="Http数据格式解析"></a>Http数据格式解析</h4><h5 id="HTTP请求报文格式"><a href="#HTTP请求报文格式" class="headerlink" title="HTTP请求报文格式"></a>HTTP请求报文格式</h5><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/webp.webp" class="" title="img">

<p><strong>请求方法：</strong></p>
<p><strong>【GET：获取资源】</strong><br>   GET方法用来请求已被URI识别的资源。指定的资源经服务器端解析后返回响应内容（也就是说，如果请求的资源是文本，那就保持原样返回；如果是CGI[通用网关接口]那样的程序，则返回经过执行后的输出结果）。</p>
<p><strong>【POST：传输实体文本】</strong><br>   POST方法用来传输实体的主体。<br>   虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法；虽然GET方法和POST方法很相似，但是POST的主要目的并不是获取响应的主体内容。</p>
<blockquote>
<p><strong>GET 方法和 POST 方法核心点：</strong></p>
<ol>
<li>传参的数据量不一样，一个通过 url，一个通过正文，所以 POST 能传更多的数据；</li>
<li>GET 方法和 POST 方法传参位置上，可靠性问题。</li>
</ol>
</blockquote>
<p><strong>【HEAD：获得报文首部】</strong><br>   HEAD方法和GET方法一样，只是不返回报文的主体部分，用于确认URI的有效性及资源更新的日期时间等。<br>   具体来说：1、判断类型； 2、查看响应中的状态码，看对象是否存在（响应：请求执行成功了，但无数据返回）； 3、测试资源是否被修改过<br>   HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。<br><strong>【PUT：传输文件】</strong></p>
<p><strong>【DELETE：删除文件】</strong></p>
<p><strong>【OPTIONS：询问支持的方法】</strong></p>
<p><strong>【TRACE：追踪路径】</strong></p>
<p><strong>【CONNECT：要求用隧道协议连接代理】</strong></p>
<p><strong>请求行：</strong></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509211948316.png" class="" title="在这里插入图片描述">

<p><strong>整体格式(请求格式：</strong></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220823132947904.png" class="" title="image-20220823132947904">

<p>(HTTP响应的格式与请求的格式十分类似,在响应中”唯一”真正的区别在于第一行中用状态行代替了请求行)</p>
<h5 id="HTTP响应报文格式"><a href="#HTTP响应报文格式" class="headerlink" title="HTTP响应报文格式"></a>HTTP响应报文格式</h5><p>HTTP响应也由3个部分构成，分别是：</p>
<ol>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ol>
<p>在接收和解释请求消息后，服务器会返回一个HTTP响应消息。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2f86d3626184a4fc8b8fed6008419055_720w.jpg" alt="img"></p>
<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>格式: <code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br>例如: <code>HTTP/1.1 200 OK \r\n</code></p>
<h3 id="HTTP-cookie"><a href="#HTTP-cookie" class="headerlink" title="HTTP cookie"></a>HTTP cookie</h3><p>假设 Susan在上网 ，她首次与Amazon.com联系，假定过去她已经访问过eBay站点。当请求报文到达该Amazon Web服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来Amazon Web服务器用一个包含 Set-cookie∶首部的<strong>HTTP响应报文</strong>对Susan的浏览器进行响应，其中Set-cookie∶首部含有该识别码。例如，该首部行可能是</p>
<p>Set-cookie: 1678</p>
<p>当 Susan 的浏览器收到了该HTTP响应报文时，它会看到该 Set-cookie∶首部。<strong>该浏览器在它管理的特定cookie文件中添加一行</strong>，该行包含服务器的主机名和在Set-cookie∶首部中的识别码。值得注意的是该cookie文件已经有了用于eBay的表项，因为Susan过去访问过该站点。当Susan继续浏览Amazon网站时，每请求一个Web页面，其浏览器就会<strong>查询该cookie 文件并抽取她对这个网站的识别码</strong>，<strong>并放到HTTP请求报文中包括识别码的cookie首部行中</strong>，特别是，发往该 Amazon 服务器的每个 HTTP 请求报文都包括以下首部行：</p>
<p>Cookie : 1678 </p>
<p>如果Susan再次访问Amazon站点，比如说一个星期后，她的浏览器会在其请求报文中继续放入首部行cookie∶1678。Amazon将根据Susan过去在Amazon访问的网页向她推荐产品。如果 Susan也在 Amazon 注册过，即提供了她的全名、电子邮件地址、邮政地址和信用卡账号，则 Amazon能在其数据库中包括这些信息，将 Susan 的名字与识别码相关联（以及她在过去访问过的本站点的所有页面）。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901100646399.png" class="" title="image-20220901100646399">

<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web 缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实</p>
<p>体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。如图2-11所示，可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该</p>
<p>Web缓存器。举例来说，假设浏览器正在请求对象 <a href="http://www.someschool.edu/campus.gif">http://www.someschool.edu/campus.gif</a> ，将会发生如下情况∶</p>
<p>1）浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</p>
<p>2）Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</p>
<p>3）如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器（即<a href="http://www.someschool.edu)的tcp连接.web缓存器则在这个缓存器到服务器的tcp连接上发送一个对该对象的http请求.在收到该请求后,初始服务器向该web缓存器发送具有该对象的http响应./">www.someschool.edu）的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</a></p>
<p>4）当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）。</p>
<p><strong>值得注意的是Web缓存器既是服务器又是客户。</strong></p>
<p>在因特网上部署Web缓存器有两个原因。首先，<strong>Web缓存器可以大大减少对客户请求的响应时间</strong>，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接（情况常常如此）。其次，如我们马上用例子说明的那样，<strong>Web缓存器能够大大减少一个机构的接入链路到因特网的通信量</strong>。通过减少通信量，该机构（如一家公司或者一所大学）就<ins>不必急于增加带宽</ins>，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的Web。</p>
<p><strong>条件GET方法：</strong></p>
<p>尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即<ins>保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了</ins>。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是<strong>条件GET</strong>（conditional GET）方法。如果∶①请求报文使用GET 方法并且②请求报文中包含一个”If-Modified-Since∶”首部行。那么，这个HTTP请求报文就是一个条件GET请求报文。</p>
<p>具体过程：</p>
<p>首先代理服务器访问服务器，服务器响应的报文存在Last-Modified: ，以用来表示缓存服务器最新的访问时间，当客户端请求的时候，缓存服务器访问服务器，并发送以下请求报文：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901105811202.png" class="" title="image-20220901105811202">

<p>If-modified-since即缓存服务器的资源 该条件 GET 报文告诉服务器，仅当自指定日期之后该对象被修改过，服务器才发送该对象。</p>
<p>接着服务器查看对应资源，如果If-modified-since后资源没有修改，则返回响应报文：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901110057993.png" class="" title="image-20220901110057993">

<p>这样做并没有在该响应报文中包含所请求的对象，包含该对象只会浪费带宽，并增加用户感受到的响应时间，特别是如果该对象很大的时候更是如此。</p>
<h3 id="HTTP的不同版本"><a href="#HTTP的不同版本" class="headerlink" title="HTTP的不同版本"></a>HTTP的不同版本</h3><p><a href="https://blog.csdn.net/yinlidong77/article/details/103908035">(48条消息) HTTP1.0和HTTP2.0的区别_丶懿的博客-CSDN博客_http1.0和http2.0的区别</a></p>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><a href="https://www.runoob.com/w3cnote/http-vs-https.html">HTTP 与 HTTPS 的区别 | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/428372105">应用层协议详解 - 知乎 (zhihu.com)</a></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS实际上也是应用层协议，因为是端到端之间的通信，并且由运输层来传送DNS的报文信息。</p>
<p>关于DNS的工作流程：[详见url的请求过程](# 2. 一个URL的执行过程)</p>
<p>&#x2F;&#x2F;TODO DNS的报文内容 P90</p>
<h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p>&#x2F;&#x2F;TODO 关于视频在网络的传输 P97</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220902103152331.png" class="" title="image-20220902103152331">



<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="关于运输层"><a href="#关于运输层" class="headerlink" title="关于运输层"></a>关于运输层</h2><p>运输层协议是在端系统中而不是在路由器中实现的。网络路由器仅作用于该数据包的网络层字段。</p>
<p>运输协议能够提供的服务常常受制于底层网络层协议的服务模型 如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证。</p>
<p>然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务，例如，即使底层网络协议是不可靠的，也就是说网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务。</p>
<p>在对 UDP TCP 进行简要介绍之前，简单介绍 下因特网的网络层，是有用的 因特网网络层协议有 个名字叫IP，即网际协议 ，IP为主机之间提供了逻辑通信 IP 的服务模型是<strong>尽力而为交付服务</strong> ，意味着 IP 尽它“最大的努力”在通信的主机之间交付报文段 ，但它并不做任何确保。<ins>特别是，它不确保报文段的交付，不保证报文段的按序交付， 不保证报文段中数据的完整性。</ins></p>
<p>运输层为它上面的应用层提供通信服务。<br>在OSI七层参考模型中，运输层是面向通信的最高层，也是用户功能的最底层。<br>传输层两大重要的功能：复用 和 分用。<br>1.复用：在发送端，多个应用进程公用一个传输层；<br>2.分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。<br>和网络层的区别：<br>1.网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。<br>2.网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</p>
<p>以下是两种主要协议：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>UDP</strong></th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>有连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用 流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对 一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8个字节</td>
<td>首部小：20字节， 大：60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用 （IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p><strong>UDP只在IP数据报服务的基础上增加了少量的功能：复用与分用、对整个报文的差错检测。</strong><br>1.UDP是无连接的<br>通信前不需要建立连接，通信结束也无需释放连接。<br>2.UDP是不可靠的<br>它是尽最大努力交付，不能确保每一个数据报都送达。<br>3.UDP是面向报文的<br>所谓 面向报文 就是指：UDP数据传输的单位是报文，且不会对数据作任何 拆分 和 拼接 操作。在发送端，应用程序给传输层的UDP什么样的数据，UDP不会对数据进行切分，只增加一个UDP头并交给网络层。在接收端，UDP收到网络层的数据报后，去除IP数据报头部后遍交给应用层，不会作任何拼接操作。<br>4.<strong>UDP没有拥塞控制</strong><br>UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。<br>弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。<br>优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<ul>
<li><strong>源端口</strong>：源端口号。在需要对方回信时选用。不需要时可用全0。</li>
<li><strong>目的端口</strong>：目的端口号。这在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>： UDP用户数据报的长度，其最小值是8（仅有首部）。</li>
<li><strong>校验和</strong>：检测UDP用户数据报在传输中是否有错。有错就丢弃。</li>
</ul>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612429750222.png" class="" title="img">

<p><strong>伪首部</strong><br>在 TCP 的分段或 UDP 的数据报格式中，在数据报首部前面增加源 IP 地址、目的 IP 地址、IP 分组的协议字段、TCP 或 UDP 数据报的总长度等共12字节，所构成的扩展首部结构。此伪首部是一个临时的结构，它既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-02.gif" class="" title="img">



<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>图3-8 图示说明了我们学习可靠数据传输的框架。为上层实体提供的服务抽象是∶数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是TCP向调用它的因特网应用所提供的服务模型。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220902103242185.png" class="" title="image-20220902103242185">

<p>图3-8b 图示说明了用于数据传输协议的接口。通过调用rdt_send（）函数，上层可以调用数据传输协议的发送方。它将要发送的数据交付给位于接收方的较高层。（这里rdt表示可靠数据传输协议， _send指示 rdt的发送端正在被调用。）在接收端，当分组从信道的接收端到达时，将调用rdt_rev（）。当rdt协议想要向较高层交付数据时，将通过调用deliver_data（）来完成。</p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p>我们现在一步步地研究 系列协议，它 一个 比一个更为复杂，最后得到 个完美可靠 的数据传输协议。</p>
<p><strong>1.经完全可靠信道的可 数据传输： rdt1 . 0</strong> </p>
<p><strong>2.经具有比特差错信道的可靠数据传输： rdt2. 0</strong> </p>
<p><strong>3.经具有 特差错的丢包信道的可靠数据传输： rdt3. 0</strong> </p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220907093316040.png" class="" title="image-20220907093316040">

<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220907093329034.png" class="" title="image-20220907093329034">

<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220907095553056.png" class="" title="image-20220907095553056">



<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220907095437167.png" class="" title="image-20220907095437167">

<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220907095517751.png" class="" title="image-20220907095517751">













<p><a href="https://blog.51cto.com/u_15295346/3022689">https://blog.51cto.com/u_15295346/3022689</a></p>
<p>&#x2F;&#x2F;TODO 反复回味 page 135</p>
<h2 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h2><p>TCP最主要的特点</p>
<ol>
<li><p><strong>TCP是面向连接的</strong></p>
<p>通信前需要建立连接，通信结束需要释放连接。每一条TCP连接只能有两个端点,TCP只能提供点到点的通信，而UDP可以任意方式的通信。</p>
</li>
<li><p><strong>TCP提供可靠交付的服务</strong></p>
<p>可靠指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。(对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号)</p>
</li>
<li><p><strong>TCP提供全双工通信</strong><br>全双工通信指的是：TCP的两端既可以作为发送端，也可以作为接收端。</p>
</li>
<li><p><strong>TCP是面向字节流的</strong><br>面向字节流指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报 ，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</p>
</li>
<li><p><strong>TCP的连接</strong><br>TCP连接就是由协议软件所提供的一种抽象。表示一条可通信的链路。每条TCP连接有且仅有两个端点，表示通信的双方。且双发在任意时刻都可以作为发送者和接收者。<br>TCP连接的端点叫做套接字或插口。<br>套接字 socket &#x3D;（IP地址:端口号）。<br>因此，TCP连接 ::&#x3D;（套接字1，套接字2）&#x3D;{(IP1:端口号1)，(IP2:端口号2)}</p>
</li>
</ol>
<h4 id="TCP报文段首部"><a href="#TCP报文段首部" class="headerlink" title="TCP报文段首部"></a>TCP报文段首部</h4><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-05-16613875284723.gif" class="" title="img">



<h3 id="TCP实现可靠传输原理"><a href="#TCP实现可靠传输原理" class="headerlink" title="TCP实现可靠传输原理"></a>TCP实现可靠传输原理</h3><p>TCP的可靠性表现在：它向应用层提供的数据是 无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一模一样的。TCP采用了流量控制、拥塞控制、连续ARQ等技术来保证它的可靠性。</p>
<p>当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来是不可靠的传输信道就能够实现可靠传输了。</p>
<h4 id="1-停止等待协议-ARQ协议"><a href="#1-停止等待协议-ARQ协议" class="headerlink" title="1.停止等待协议(ARQ协议)"></a>1.停止等待协议(ARQ协议)</h4><p>TCP保证其可靠性采用的是更为复杂的滑动窗口协议，但停止等待协议是它的简化版，为了方便理解，这里先介绍停止等待协议。<br>AQR协议</p>
<p>ARQ(Automatic Repeat reQuest)自动重传请求。<br>顾名思义，当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。停止等待协议是一种ARQ协议。</p>
<p><strong>停止等待协议的原理</strong></p>
<ol>
<li><p>无差错的情况<br>A向B每发送一个分组，都要停止发送，等待B的确认应答；A只有收到了B的确认应答后才能发送下一个分组。</p>
</li>
<li><p>分组丢失和出现差错的情况<br>发送者拥有超时计时器。每发送一个分组便会启动超时计时器，等待B的应答。若超时仍未收到应答，则A会重发刚才的分组。</p>
<p>分组出现差错：若B收到分组，但通过检查和字段发现分组在运输途中出现差错，它会直接丢弃该分组，并且不会有任何其他动作。A超时后便会重新发送该分组，直到B正确接收为止。</p>
<p>分组丢失：若分组在途中丢失，B并没有收到分组，因此也不会有任何响应。当A超时后也会重传分组，直到正确接收该分组的应答为止。<br>综上所述：当分组丢失 或 出现差错 的情况下，A都会超时重传分组。</p>
</li>
<li><p>应答丢失 和 确认迟到 的情况<br>TCP会给每个字节都打上序号，用于判断该分组是否已经接收。</p>
<p>应答丢失：若B正确收到分组，并已经返回应答，但应答在返回途中丢失了。此时A也收不到应答，从而超时重传。紧接着B又收到了该分组。接收者根据序号来判断当前收到的分组是否已经接收，若已接收则直接丢弃，并补上一个确认应答。</p>
<p>确认迟到：若由于网络拥塞，A迟迟收不到B发送的应答，因此会超时重传。B收到该分组后，发现已经接收，便丢弃该分组，并向A补上确认应答。A收到应答后便继续发送下一个分组。但经过了很长时间后，那个失效的应答最终抵达了A，此时A可根据序号判断该分组已经接收，此时只需简单丢弃即可。</p>
</li>
</ol>
<blockquote>
<p>停止等待协议的注意点</p>
<p>每发送完一个分组，该分组必须被保留，直到收到确认应答为止。<br>必须给每个分组进行编号。以便按序接收，并判断该分组是否已被接收。<br>必须设置超时计时器。每发送一个分组就要启动计时器，超时就要重发分组。<br>计时器的超时时间要大于应答的平均返回时间，否则会出现很多不必要的重传，降低传输效率。但超时时间也不能太长。</p>
</blockquote>
<h4 id="2-滑动窗口协议（连续ARQ协议）"><a href="#2-滑动窗口协议（连续ARQ协议）" class="headerlink" title="2. 滑动窗口协议（连续ARQ协议）"></a>2. 滑动窗口协议（连续ARQ协议）</h4><ol>
<li><p>连续ARQ协议<br>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。</p>
</li>
<li><p>累计确认<br>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。</p>
</li>
</ol>
<blockquote>
<p>TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。下面会介绍TCP头部报文段。</p>
</blockquote>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190531151613730.png" class="" title="在这里插入图片描述">

<p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。<br>发送窗口由三个指针构成：</p>
<p>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。<br>p2指向尚未发送的第一个字节。<br>p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。<br>p2-p3间的字节表示可以发送，但还没有发送的字节。<br>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。<br>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p>
<p><strong>连续ARQ的注意点：</strong></p>
<ol>
<li>同一时刻发送窗口的大小并不一定和接收窗口一样大。<br>虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。<br>此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</li>
<li>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。</li>
<li>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5s以内。<br>此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</li>
</ol>
<hr>
<h2 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h2><p>总结二者各自的特点：</p>
<ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220905103934241.png" class="" title="image-20220905103934241">

<p>(什么图都有)</p>
<h2 id="TCP三次握手和四次挥手过程"><a href="#TCP三次握手和四次挥手过程" class="headerlink" title="TCP三次握手和四次挥手过程"></a>TCP三次握手和四次挥手过程</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>要理解TCP三次握手和四次挥手的过程，首先需要了解TCP报文段的某些首部的含义：</p>
<ol>
<li>序号 seq：本报文段所发送的数据的第一个字节序号</li>
<li>确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号</li>
<li>确认位 ACK：仅当ACK&#x3D;1时确认号字段才有效</li>
<li>同步位 SYN：在连接建立时用来同步序号，SYN&#x3D;1表示这是一个连接请求或是连接接受请求。</li>
<li>终止位 FIN：用来释放一个连接。当FIN&#x3D;1时，表示此报文段的发送方数据已经发送完毕，并要求释放运输连接</li>
</ol>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612438854245.png" class="" title="在这里插入图片描述">

<p>（1）客户端A向服务端B发出连接请求，同步位SYN&#x3D;1，初始序号seq&#x3D;x，连接请求报文段不能携带数据，但是要消耗一个序号，这时客户端A进入SYN-SENT（同步已发送状态）。<br>（2）服务端B收到请求报文段之后，向A发送后确认。将同部位SYN和确认位都置为1，确认序号ack&#x3D;x+1，同时自己选择一个初始序号seq&#x3D;y。连接接收报文也不能携带数据，但是也要消耗一个序号，这时服务端进入SYN-RCVD(同步收到状态)。<br>（3）A收到B的确认时候要给B一个确认。确认报文段的确认位ACK&#x3D;1,确认号ack&#x3D;y+1,自己的序号seq&#x3D;x+1。这时,TCP连接已经建立，客户端进入ESTABLISHED（已建立连接状态）。B收到A发出的确认报文之后也进入已建立连接状态。</p>
<h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612439966847.png" class="" title="在这里插入图片描述">

<p>（1）客户端进程发出连接释放报文，并且停止发送数据。A将连接释放报文的终止位FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>（2）服务器收到连接释放报文后发出确认，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向的连接就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>（3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）<br>（4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认<br>（5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态<br>（6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。</p>
<h4 id="各个挥手和握手的传送异常的情况"><a href="#各个挥手和握手的传送异常的情况" class="headerlink" title="各个挥手和握手的传送异常的情况"></a>各个挥手和握手的传送异常的情况</h4><p><a href="https://zhuanlan.zhihu.com/p/398890723">TCP 才不傻：三次握手和四次挥手的异常处理 - 知乎 (zhihu.com)</a></p>
<h4 id="为什么是三次握手-而不是两次或者四次呢"><a href="#为什么是三次握手-而不是两次或者四次呢" class="headerlink" title="为什么是三次握手 而不是两次或者四次呢?"></a>为什么是三次握手 而不是两次或者四次呢?</h4><p>其实TCP连接需要的是，两方都知道自己是否有接受和发送数据的能力， 第一次A发送消息，A，B都不知道自己是否有接受和发送能力， B收到A的消息后，B知道了我有接受消息的能力，B发送给A，A现在知道了我能接受消息，而且发送的消息B能接受到，也说明A有发送消息的能力，最后一次A给B发送信息，B也知道了我有发送消息的能力，至此，AB都有发送和接受消息的能力，所以是三次，刚刚好。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是由于服务端的LISTEN状态下收到SYN报文的建立连接请求后。它能够把ACK和SYN（ACK起应答作用。而SYN起同步作用）放在一个报文里来发送给客户端。<br>但关闭连接的时候，当服务端收到客户端的FIN报文段的时候，表示客户端没有数据发送给服务端了，但是服务端可能还有数据要发送给客户端，这时TCP连接处于半连接状态。当服务端没有数据再发送给客户端的时候就会向客户端发送一个FIN报文表示服务端要关闭连接，ACK和FIN一般不会分开发送。这个过程也是由于TCP的通信方式是全双工的，发送和接收方都需要发送FIN和ACK。</p>
<h4 id="为什么三次挥手不能释放连接呢"><a href="#为什么三次挥手不能释放连接呢" class="headerlink" title="为什么三次挥手不能释放连接呢?"></a>为什么三次挥手不能释放连接呢?</h4><h4 id="最后为什么要进行2MSL-的等待"><a href="#最后为什么要进行2MSL-的等待" class="headerlink" title="最后为什么要进行2MSL 的等待"></a>最后为什么要进行2MSL 的等待</h4><p>网络是不可靠的，TCP是可靠协议，必须保证最后一次报文送达之后才能断开链接，否则会再次收到S端的FIN报文信息。<br>而等待2MSL时间就是为了保证最后最后一次报文丢失时还能重新发送。</p>
<p>2MSL是报文一个往返的最长时间，假设小于这个时间会发生，ACK丢了，但是还没接收到对方重传的FIN我方就重新发送了ACK。</p>
<hr>
<p>TIME_WAIT 状态也成为 2MSL 等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的 MSL 值，处理的原则是：当 TCP 执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的FIN）。</p>
<p>这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的 IP 地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h3 id="SYN-攻击是什么"><a href="#SYN-攻击是什么" class="headerlink" title="SYN 攻击是什么"></a><strong>SYN 攻击是什么</strong></h3><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。</p>
<p>SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ol>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ol>
<p><a href="https://baijiahao.baidu.com/s?id=1647168988779212556">TCP&#x2F;IP面试：为什么要四次挥手，三次不行吗 (baidu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/130475730">关于TCP三次握手和四次挥手问题，求你别再问了问了… - 知乎 (zhihu.com)</a></p>
<h2 id="TCP-x2F-UDP各自的缓冲区"><a href="#TCP-x2F-UDP各自的缓冲区" class="headerlink" title="TCP&#x2F;UDP各自的缓冲区"></a>TCP&#x2F;UDP各自的缓冲区</h2><p>TCP和UDP都拥有套接口接收缓冲区。</p>
<p><strong>TCP套接口接收缓冲区不可能溢出</strong>，因为TCP具有流量控制(窗口).然而对于TCP来说，当接收到的数据报装不进套接口接收缓冲区时，该数据报就丢弃。UDP是没有流量控制的：较快的发送端可以很容易淹没较慢的接收端，导致接收端的UDP丢弃数据报。</p>
<p><strong>UDP存在接收缓冲区，UDP没有发送缓冲区，</strong>在调用sendto时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作。为什么UDP不需要发送缓冲区？ 因为UDP不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而<strong>TCP不同，他必须具备发送缓冲区</strong>，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区。</p>
<p><a href="https://blog.csdn.net/hansionz/article/details/86435127">(51条消息) TCP和UDP详解(非常详细)_Hansionz的博客-CSDN博客_tcp udp</a></p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><a href="https://blog.csdn.net/weixin_39754631/article/details/90242887">(48条消息) TCP三次握手和四次挥手过程_wq0321的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/jinjiniao1/article/details/90698643">(48条消息) 运输层功能详解_lzcWHUT的博客-CSDN博客_运输层</a></p>
<p>待学习：<a href="https://blog.csdn.net/OYMNCHR/article/details/119118383">(48条消息) 计算机网络总结——运输层_OYMN的博客-CSDN博客</a></p>
<h1 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h1><p>网络层实际是怎样实现主机到主机的通信服务的。我们将看到与运输层和应用层不同的是，在网络中的每一台主机和路由器中都有一个网络层部分 正因如此，网络层协议是协议栈中最具挑战性（因而也是最有趣）的部分。网络层在协议栈中毋庸置疑是最复杂的层次，因此我们将在这里用大量篇幅来讨论，的确因为涉及的内容太多，我们要用两章的篇幅来讨论网络层 我们将看到网络层能够被分解为两个相互作用的部分，即<strong>数据平面</strong>和<strong>控制平面</strong>。在第4章，我们将首先学习网络层的数据平面功能，即<strong>网络层中每台路由器的功能，</strong>该数据平面功能决定到达路由器输入链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一。</p>
<h2 id="转发与路由选择：数据平面和控制平面"><a href="#转发与路由选择：数据平面和控制平面" class="headerlink" title="转发与路由选择：数据平面和控制平面"></a>转发与路由选择：数据平面和控制平面</h2><p>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机为此，需要使用两种重要的网络层功能：</p>
<p>•  <strong>转发</strong> 当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路，转发是在数据平面中实现的唯一功能（尽管是最为常见和重要的功能） 在最为常见的场合（我们将在 4.4 节中讨论），分组也可能被现有的路由器阻挡（例如，该分组来源个已知的恶意主机，或者该分组发向 个被禁止的目的主机），或者可能是冗余的并经过多条出链路发送。</p>
<p>•  <strong>路由选择</strong> 当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径 计算这些路径的算法被称为路由选择算法 。 </p>
<p>两者的对比：</p>
<p><strong>转发</strong> (forwanling) 是指将分组从一个输人链路接口转移到适当的输出链路接口的路由器本地动作 转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现。</p>
<p><strong>路由选择</strong> (routing) 是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程 路由选择发生的时间尺度长得多 （通常为几秒） ，因此通常用软件来实现。</p>
<p>每台网络路由器中有 个关键元素是它的<strong>转发表</strong> (fonvarding table) 路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口 例如在图 4-2 中，一个首部字段值为 0111 的分组到达路由器 该路由器在它的转发表中索引，并确定该分组的输出链路接口是接口 该路由器则在内部将该分组转发到接口2。	</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220911182646848.png" class="">



<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220912084641094.png" class="" title="image-20220912084641094">

<p>• <strong>输入端口</strong> 输入端口执行几项重要功能 它在路由器中执行终结入物理链路的物理层功能，这显示在图 4-4 中输入端口部分最左侧的方框与输出端口部分最右侧的方框中。它还要与位于入链路远端的数据链路层交互来执行数据链路层功能，这显示在输入与输出端口部分中间的方框中 也许更为重要的是，在输入端口还要执行查找功能，这显示在输入端口最右侧的方框中 正是在这里，通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构转发到输出端口。控制分组（如携带路由选择协议信息的分组）从输入端口转发到路由选择处理器。</p>
<p>• <strong>交换结构</strong> 交换结构将路由器的输入端口连接到它的输出端口 这种交换结构完全包含在路由器之中，即它是一个网络路由器中的网络！</p>
<p>• <strong>输出端口</strong> 输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组 当一条链路是双向的时 （即承载两个方向的流量），输出端口通常与该链路的输入端口成对出现在同一线路卡上。</p>
<p>• <strong>路由选择处理器</strong> 路由选择处理器执行控制平面功能 在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表 SDN 路由器中，路由选择处理器（在其他活动中）负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项 路由选择处理器还执行网络管理功能。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220912091915037.png" class="" title="image-20220912091915037">

<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换结构位于 台路由器的核心部位，因为正是通过这种交换结构，分组才能实际地从一个输入端口交换 即转发 个输出端口中 交换可以用许多方式完成。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220912090722369.png" class="" title="image-20220912090722369">



<h3 id="何处出现排队"><a href="#何处出现排队" class="headerlink" title="何处出现排队"></a>何处出现排队</h3><p>在输入端口和输出端口处都可以形成分组队列排队的位置和程度（或者在输入端口排队，或者在输出端口排 ）将取决于流量负载、交换结构的相对速率和线路速率 我们现在更为详细 点考虑这些队列因为随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包 (packet loss)。</p>
<ol>
<li><strong>输人排队</strong></li>
</ol>
<p>其中在输入队列前端的两个分组（带深色阴影）要发往同个右上角输出端口 假定该交换结构决定发送左上角队列前端的分组 在这种情况下，左下角队列中的深色阴 影分组必须等待 但不仅该分组要 等待，左下角队列中排在该分组后面的浅色阴 影分组也要等待，即使右中侧输出端口（浅色阴影分组的目的地）中无竞争 这种现象叫作输入排队交换机中的线路前部(Head-Of-the-Line, HOL) 阻塞，即在个输入队列中排队的分组必须等待通过交换结构发送（即使输出端口是空闲的），因为它被位于线路前部的另 个分组所阻塞。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220912094727037.png" class="" title="image-20220912094727037">

<ol start="2">
<li><strong>输出排队</strong></li>
</ol>
<p>排队的分组数量能够变得足够大，耗尽输出端口的可用内存 。当没有足够的内存来缓存一个入分组时，就必须做出决定：要么丢弃到达的分组（采种称为弃尾 (drop-taiJ) 的策略），要么删除 个或多个巳排队的分组为新来的分组腾出空间 在某些情况下 在缓存填满之前便丢弃 个分组 （或在其首部加上标记）的做是有利的，这可以向发送方提供 个拥塞信号 已经提出和分析了许多分组丢弃与标记策略 , 这些策略统称为主动队列管理 (Active Queue Management, AQM) 算法。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220912102118547.png" class="" title="image-20220912102118547">



<p>在某一时刻 , 每个入端输入端口都到达了一个分组 每个分组都是发往最上侧 的输出端口。假定线路速度相同，交换机以3倍于线路速度的速度运行， 一个时间单位（即接收或发送 个分组所需的时间）以后，所有三个初始分组都被传送到输出端口，并排 等待传 在下一个时间单位中，这三个分组中的一个将通过输出链路发送出去。在这个例子中，又有两个新分组已到达交换机的入端；这些分组之一要发往最上侧的输出端 这样的后果是，输出端口 的<strong>分组调度</strong> 在这些排队分组中选择一个分组来传输 。</p>
<h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><h2 id="网际协议：-1Pv4-、寻址、-1Pv6-及其他"><a href="#网际协议：-1Pv4-、寻址、-1Pv6-及其他" class="headerlink" title="网际协议： 1Pv4 、寻址、 1Pv6 及其他"></a>网际协议： 1Pv4 、寻址、 1Pv6 及其他</h2><h1 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h1><h1 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h1><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250209093722075.png" class="" title="image-20250209093722075">

<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250209094403255.png" class="" title="image-20250209094403255">

<h2 id="组帧："><a href="#组帧：" class="headerlink" title="组帧："></a>组帧：</h2><p>帧的传输需要考虑如何界定数据的大小确定帧的界限，还需要考虑如何让接收方识别帧。</p>
<img src="计算机网络/image-20250209105416852.png" alt="image-20250209105416852"  />

<h3 id="帧的组成方法"><a href="#帧的组成方法" class="headerlink" title="帧的组成方法"></a>帧的组成方法</h3><h4 id="1-字符计数法"><a href="#1-字符计数法" class="headerlink" title="1. 字符计数法"></a>1. 字符计数法</h4><p>在帧的前面添加一个定长的<strong>计数字段</strong>表示帧长。</p>
<img src="计算机网络/image-20250209105840158.png" alt="image-20250209105840158" style="zoom:33%;" />

<p>缺点：如果<strong>计数字段</strong>出现错误，则后续所有帧的界限都会错误。</p>
<h4 id="2-字节填充法"><a href="#2-字节填充法" class="headerlink" title="2. 字节填充法"></a>2. 字节填充法</h4><p>使用两个特殊的<strong>控制字符</strong>分别表示帧的开头和结束标志。</p>
<img src="计算机网络/image-20250209110845702.png" alt="image-20250209110845702" style="zoom:33%;" />

<p>问题：如果帧中出现同控制字符的信息？导致错误的帧界定。</p>
<p>解决：使用<strong>转义字符ESC</strong>，插入到数据中包含<strong>控制字符</strong>之前的位置，<strong>识别到转义字符esc，则删除，将后面识别为数据。</strong></p>
<img src="计算机网络/image-20250209110810022.png" alt="image-20250209110810022" style="zoom:33%;" />

<p>问题：如果数据中包含转义字符？导致会删除数据</p>
<p>解决：在转义字符ESC之前再插入一个转义字符，于是就可以将同转义字符的数据识别为真实数据。</p>
<h4 id="3-零比特传输法"><a href="#3-零比特传输法" class="headerlink" title="3.零比特传输法"></a>3.零比特传输法</h4><p>使用<strong>特殊比特串</strong>表示帧的开始和结束：都是01111110 （0+6个1+0）</p>
<p>在帧发送组装的过程中，处理数据中的<strong>可能出现的特殊比特串</strong>，</p>
<p>处理方法：</p>
<ol>
<li>发送方每当遇见连续的5个1，就在后面插入一个0</li>
<li>接收方每当遇见连续的5个1，就在后面删除一个0</li>
</ol>
<img src="计算机网络/image-20250209112348755.png" alt="image-20250209112348755" style="zoom:50%;" />

<p>数据链路层的HDLC，PPP这两个协议使用的都是这个传输方法。</p>
<h1 id="物理层：通信原理"><a href="#物理层：通信原理" class="headerlink" title="物理层：通信原理"></a>物理层：通信原理</h1><h4 id="通信原理中一些基本概念："><a href="#通信原理中一些基本概念：" class="headerlink" title="通信原理中一些基本概念："></a>通信原理中一些基本概念：</h4><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205145706765.png" class="" title="image-20250205145706765">

<p><strong>码元</strong>：每个信号就是一个码元，既在一个周期内，可能出现几种信号就对应几种码元。</p>
<p>用数字信号设计4进制码元：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205150859460.png" class="" title="image-20250205150859460">

<p>如果一个码元（一个信号）可能有4种状态，那么可以称为4进制码元（一个码元携带2bit的数据 —00 01 10 11）</p>
<p>类似的，如果一个码元（即一个信号）可能有8种状态，那么就称之为8进制码元（一个码元携带3bit数据）。 </p>
<p>一个码元能够携带多少比特数据？</p>
<p>如果一个周期内有K种可能的信号</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205201452266.png" class="" title="image-20250205201452266">

<p>例如：一个周期内有8种可能的信号，则有8个码元，其中1码元&#x3D;3bit</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205201905923.png" class="" title="image-20250205201905923">

<p>信号传输的速率：</p>
<p>两个计量单位：1.<strong>波特率</strong>（码元&#x2F;秒）2.<strong>比特率</strong>（比特&#x2F;秒）</p>
<p>带宽</p>
<h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>前提条件：在一个理想的<strong>没有噪声</strong>的，带宽有限的信道。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205202538485.png" class="" title="image-20250205202538485">

<h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>前提条件：有噪音的情况下</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205203216591.png" class="" title="image-20250205203216591">



<p>信噪比S&#x2F;N的两种表示方法：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205203657532.png" class="" title="image-20250205203657532">

<p>根据两个定理的总结和公式的说明 得出的结论：信道中是有限的码元，能够携带的比特的数量是也有限的。</p>
<h3 id="信号在物理层上传输的方式："><a href="#信号在物理层上传输的方式：" class="headerlink" title="信号在物理层上传输的方式："></a>信号在物理层上传输的方式：</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250205205118274.png" class="" title="image-20250205205118274">

<p>信源A通过将二进制数据转化为数字信号或者模拟信号到信道上，信号到信宿B后通过反变换器，将数字信号和模拟信号转化为二进制数据。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="1-HTTP和HTTPS的区别："><a href="#1-HTTP和HTTPS的区别：" class="headerlink" title="1. HTTP和HTTPS的区别："></a>1. HTTP和HTTPS的区别：</h2><p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:&#x2F;&#x2F; 打头的都是标准 HTTP 服务。</p>
<p><strong>HTTP 协议以明文方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。既使用<strong>SSL&#x2F;TLS+HTTP</strong>。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9556fa61ac7262a18bc639db29362669_720w.jpg" class="" title="img">

<p>SSL（Secure Socket Layer，安全套接字层）TLS（Transport Layer Security，传输层安全）</p>
<p>HTTPS使用了非对称加密</p>
<h3 id="对称加密和非对称加密："><a href="#对称加密和非对称加密：" class="headerlink" title="对称加密和非对称加密："></a>对称加密和非对称加密：</h3><p><strong>对称加密：</strong>加密和解密的秘钥使用的是同一个.</p>
<p> <a href="https://so.csdn.net/so/search?q=%E5%AF%86%E9%92%A5&spm=1001.2101.3001.7020">密钥</a>较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，且对计算机性能要求也没有那么高.</p>
<p>缺点：  算法公开、计算量小、加密速度快、加密效率高</p>
<p>常见的对称加密算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES </p>
<p>在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<p><strong>非对称加密算法:</strong> 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<p>https使用的是非对称加密</p>
<p><img src="https://pic4.zhimg.com/80/v2-1ea0209a526f3527a713736fe7609fcf_720w.jpg" alt="img"></p>
<p>[你知道，HTTPS用的是对称加密还是非对称加密？ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/96494976#:~:text=%E5%A4%A7%E5%AE%B6%E5%8F%AF%E8%83%BD%E9%83%BD%E5%90%AC%E8%AF%B4%E8%BF%87">https://zhuanlan.zhihu.com/p/96494976#:~:text=大家可能都听说过</a> HTTPS,协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。)</p>
<p><a href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227873816610">非对称加密算法 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h2 id="2-一个URL的执行过程"><a href="#2-一个URL的执行过程" class="headerlink" title="2. 一个URL的执行过程"></a>2. 一个URL的执行过程</h2><p>总体来说分为以下六个步骤：</p>
<p><strong>1、DNS解析</strong></p>
<p>DNS是将便于记忆的<strong>域名转化为IP地址</strong>。（DNS分为俩个，一个是DNS服务器，另一个是DNS协议，存在于UDP之上，使用53端口）。</p>
<p>三个层级的DNS服务器：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202849848.png" class="" title="image-20220825202849848">

<p>具体的执行步骤（不经过DNS缓存）：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202950751.png" class="" title="image-20220825202950751">

<p>当一个客户端主机(cse.nyu.edu)想要知道主机gaia.cs.umass.edu的IP地址。同时假设纽约大学的cse.nyu.edu主机的本地DNS服务器为dns.nyu.edu，并且gaia.cs.umass.edu的权威DNS服务器为dns.nyu.edu，主机cse.nyu.edu首先向它的本地DNS服务器dns.nyu.edu发送一个DNS查询报文。该查询报文含有被转化的主机名gaia.cs.umass.edu。本地DNS服务器将该报文转发到根DNS服务器。该根DNS服务器注意到其edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表。该本地DNS服务器则再次向这些TLD服务器之一发送查询报文。该TLD服务器注意到umass.edu的前缀，并用权威DNS服务器的IP地址进行响应，该权威DNS服务器是负责马萨诸塞大学的dns.umass.edu。最后，本地DNS服务器直接向dns.umass.edu重发查询报文，dns.umass.edu用gaia.cs.umass.edu的IP地址进行响应。注意到在本例中，为了获得一台主机名的映射，共发送了8份DNS报文：4份查询报文和4份回答报文。</p>
<p>DNS缓存</p>
<p>在一个请求链中，当某个DNS服务器接受一个DNS回答时，它能够将映射，缓存在本地存储器中。事实上，因为缓存，除了少数DNS查询以外，根服务器都被绕过了。（因为主机名和IP地址之间的映射并不是永久的，DNS服务器在一段时间后（通常为两天）将会丢弃缓存的信息）。</p>
<p>在这一步 我们通过DNS将一个url的域名转化为一个真实的IP地址。</p>
<p><strong>2、TCP连接</strong></p>
<p>我们知道IP地址之后，就可以与这个IP地址开始尝试建立连接，在运输层我们选用的是TCP协议。</p>
<p><strong>3、发送HTTP请求</strong></p>
<p>在运输层我们建立好连接以后，应用层的使用者们就会开始进行应用信息的传输，</p>
<p><strong>4、服务器处理请求并返回HTTP报文</strong></p>
<p>这些就是后端工程师眼中的HTTP，后端从固定的端口接收到TCP报文开始，这一部分对应编程语言中的socket。它对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用，这一部分工作一般是由WEB服务器去进行，我们使用过的Web服务器有Tomcat等。</p>
<p>http响应报文也是由三部分组成的状态码、响应报头、响应报文</p>
<p><strong>5、负载均衡</strong></p>
<p>什么是负载均衡？当一台服务器无法支持大量的用户访问时，将用户分摊到两个或多个服务器上的方法叫负载均衡。什么是Nginx？Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。</p>
<p>关于Nginx的负载均衡：</p>
<ol>
<li><p>一般，如果我们的平台配备了负载均衡的话，前一步DNS解析获得的IP地址应该是我们Nginx负载均衡服务器的IP地址。所以，我们的浏览器将我们的网页请求发送到了Nginx负载均衡服务器上。</p>
</li>
<li><p>Nginx根据我们设定的分配算法和规则，选择一台后端的真实Web服务器，与之建立TCP连接、并转发我们浏览器发出去的网页请求。</p>
</li>
</ol>
<p>Nginx默认支持 RR轮转法 和 ip_hash法 这2种分配算法。</p>
<p>前者会从头到尾一个个轮询所有Web服务器，而后者则对源IP使用hash函数确定应该转发到哪个Web服务器上，也能保证同一个IP的请求能发送到同一个Web服务器上实现会话粘连。</p>
<p>也有其他扩展分配算法，如：</p>
<p>fair：这种算法会选择相应时间最短的Web服务器</p>
<p>url_hash：这种算法会使得相同的url发送到同一个Web服务器</p>
<ol start="3">
<li><p>Web服务器收到请求，产生响应，并将网页发送给Nginx负载均衡服务器。</p>
</li>
<li><p>Nginx负载均衡服务器将网页传递给filters链处理，之后发回给我们的浏览器。</p>
</li>
</ol>
<p><strong>6、浏览器解析渲染页面</strong></p>
<p>浏览器是一个边解析边渲染的过程。</p>
<ol>
<li><p>浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码。</p>
</li>
<li><p>根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)</p>
</li>
<li><p>根据Render Tree渲染网页</p>
</li>
</ol>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190402234453381.png" class="" title="在这里插入图片描述">



<p><a href="https://blog.csdn.net/g291976422/article/details/88984859">(51条消息) 访问一个URL经历了哪些过程_昵給硪鐙誒的博客-CSDN博客_url过程</a></p>
<h2 id="3-常见的HTTP状态码"><a href="#3-常见的HTTP状态码" class="headerlink" title="3. 常见的HTTP状态码"></a>3. 常见的HTTP状态码</h2><p>状态码作为HTTP响应报文中状态行的其中最重要的标识,每个状态码都代表不同的含义</p>
<p> <strong>HTTP Status Code</strong>。</p>
<ul>
<li><p>200 - 请求成功</p>
</li>
<li><p>206 - 部分内容。服务器成功处理了部分GET请求</p>
</li>
<li><p>301 - 资源（网页等）被永久转移到其它URL</p>
</li>
<li><p>304 - 实际服务器响应web缓存服务器的报文状态标识 ， 表示web服务器的资源是否需要更新。</p>
</li>
<li><p>305 - 使用代理,所请求的资源必须通过代理访问</p>
</li>
<li><p>403 - 服务器理解请求客户端的请求，但是拒绝执行此请求</p>
</li>
<li><p>404 - 请求的资源（网页等）不存在</p>
</li>
<li><p>413 - 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。</p>
</li>
<li><p>500 - 内部服务器错误</p>
<p><a href="https://zhuanlan.zhihu.com/p/76679642">413错误码——http请求实体太大 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h2 id="4-Cookie和Session的区别"><a href="#4-Cookie和Session的区别" class="headerlink" title="4. Cookie和Session的区别"></a>4. Cookie和Session的区别</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ul>
<li><strong>作用范围</strong>不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式</strong>的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期</strong>不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>安全性</strong>不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些</li>
</ul>
<h3 id="二者关联方式"><a href="#二者关联方式" class="headerlink" title="二者关联方式"></a>二者关联方式</h3><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2022/05/16/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>一些回答不好的面试题。</p>
<span id="more"></span>

<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><p>一些面经：</p>
<p><a href="https://leetcode.cn/circle/discuss/TbNRZ7/">【面经】字节北京抖音直播后端面经-已OC - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/wOfw8h/">美团｜java后台开发｜秋招Java开发面经｜2020｜ - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/KjcPyp/">百度java实习面经 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/bAdvQT/">贝壳找房｜后端开发实习生｜一面 &amp; 二面 &amp; 三面 面经｜2021｜ - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/mPok0z/">快手丨Java丨面经丨2021丨 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/WxXglM/">【面经】快手｜Java｜一面、二面、三面（已offer）｜2021｜ - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/sPg4eX/">字节｜后端实习｜技术三面面经｜2021.1.24｜ - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/HHZBlM/">阿里巴巴｜Java工程师｜面经汇总｜2020 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/jGm0Eu/">字节面经｜字节java后端一面，面经 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/KiatYq/">面试｜京东 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/v6M7KP/">8.6蔚来面经 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/circle/discuss/MDq50z/">字节跳动｜后端｜提前批｜一面+二面+三面+HR 面 - 力扣（LeetCode）</a></p>
<p><a href="https://mp.weixin.qq.com/s/pHEZydpS67yH821GagWe9g">热乎的美团一面，1小时40分钟，问的很全面！ (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247529365&idx=2&sn=cede039a89fa340584f7226b709e86ad&chksm=cea13c5ef9d6b5482c9e372a11d4aae512ecd106ed53b977ac27d13b723bc543a8a9ed5d10ca&scene=132#wechat_redirect">美团二面：什么是 CDN ？CDN 工作原理是什么？ (qq.com)</a></p>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><p>Innodb存储引擎的实现原理 索引的原理：</p>
<p>内存泄露怎么解决：</p>
<p>线程的生命周期：</p>
<img src="/2022/05/16/%E9%9D%A2%E8%AF%95/image-20220517082401082.png" class="" title="image-20220517082401082">

<p>缓存穿透、缓存击穿、缓存雪崩：</p>
<p>hashmap的实现原理</p>
<p>redis的数据类型：String（字符串） Hash（哈希 k-v） Set（集合） Zset（有序集合） List（列表）</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>回文子串：</p>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="抢红包方案："><a href="#抢红包方案：" class="headerlink" title="抢红包方案："></a>抢红包方案：</h2><p>应对高并发<br>    前面说过抢红包类似于秒杀场景，需要一定的性能保证，并且同时得保证红包不会抢出问题，比如10个红包，因为并发没处理好造成抢出了20个红包，那就血亏了。基于这两个原因，传统的基于数据库对红包进行扣减，会造成较大的压力。并且如果我们基于数据库的悲观锁来实现时，有可能造成堵塞，而基于乐观锁实现，又容易造成大量的失败请求，影响用户体验。所以最终决定基于redis来进行实现，redis的lua脚本本身具备原子性，同一时间不会处理多笔抢红包事件，同时redis本身的高性能（秒级10w）的操作量也能很好的承接住这种秒杀场景。<br>    基本的算法和设计方案敲定，再来推敲细节，redis的高性能得益于小操作，也就是你不能把一个很耗时的操作放到redis里（比如一个大循环），那可能会造成极为严重的影响，甚至堵塞住你的所有和redis相关的业务。所以我们这里仅仅将红包的扣减操作放到redis当中，设计如下：</p>
<p>用户发放红包时，会将红包的剩余个数和剩余金额（即总个数和总金额）写入redis中，并将本次发放红包的所有详情记录记录到数据库中，数据库操作在前，redis操作在后，对整个写数据的方法增加事务，保证数据的写一致性。<br>用户抢红包时，在服务端生成[0,1]的浮点随机数，然后带入redis的lua脚本，在脚本中实现对前面的抢红包算法，根据当前剩余红包个数和剩余金额，计算出当前用户的红包区间，再将红包区间和我们带入的[0,1]的浮点随机数相乘并向下取整得到当前用户抢到的金额数，再对redis里的剩余个数和剩余金额进行修改。<br>从lua脚本执行结果中获取到剩余数量，剩余金额，本次抢到的金额，然后发布mq，将本次抢红包的日志记录和金额修改的操作放到异步去进行，如果mq发送失败，需要手动回滚调redis，将剩余数量自增1，将本次抢到金额也要加回剩余金额。</p>
<p><a href="https://blog.csdn.net/qq_30095631/article/details/116485748">(51条消息) 抢红包设计方案_泰勒今天不想展开的博客-CSDN博客_抢红包设计</a></p>
<p><a href="https://blog.csdn.net/weixin_43591980/article/details/112548164">(51条消息) Lua脚本基础入门及其案例_兴趣使然的草帽路飞的博客-CSDN博客_lua脚本入门</a></p>
<h2 id="商城系统难点"><a href="#商城系统难点" class="headerlink" title="商城系统难点"></a>商城系统难点</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/05/11/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<img src="/2022/05/11/%E9%9B%86%E5%90%88/1166662.jpg" class="" width="1166662">

<h2 id="Collection："><a href="#Collection：" class="headerlink" title="Collection："></a>Collection：</h2><img src="/2022/05/11/%E9%9B%86%E5%90%88/20180803184706534.png" class="" width="20180803184706534">

<span id="more"></span>

<p>1.List:  元素可重复 可以多个元素为null </p>
<p>2.Set:  添加的元素不可重复</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="1-ArrayList："><a href="#1-ArrayList：" class="headerlink" title="1.ArrayList："></a>1.ArrayList：</h3><p>​	底层使用数组实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//首先了解一下几个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		ArrayList的空参构造器 构建一个空间大小为10的空链表</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		ArrayList的指定列表大小的构造方法</span></span><br><span class="line"><span class="comment">		当传入的参数为0的时候 会自动使用ArrayList的static数组EMPTY_ELEMENTDATA  这是一个空的对象数组</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		转化集合为ArrayList的构造方法 首先将集合使用Collection的toArray()方法 转化为数组</span></span><br><span class="line"><span class="comment">		然后进行判断 如果该集合的内容大小为0 则直接等效于上一个构造方法的指定长度为0的情况</span></span><br><span class="line"><span class="comment">					否则 则需要判断内容是否为Object类型</span></span><br><span class="line"><span class="comment">							如果为Object类型的 则直接将其赋值给ArrayList的Object[]数组</span></span><br><span class="line"><span class="comment">							否则 将其内容转化为Obejct类型</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​			</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加方法 首先ensureCapacityInternal确定大小</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 如果数组elementData的长度小于最小需要的容量（minCapacity）就需要扩容数组</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*如果 当前数组和默认的初始数组相同 那么就选择10和size+1的更大值 为10</span></span><br><span class="line"><span class="comment">	*也验证了 ArrayList使用无参构造函数的时候第一次添加元素时 数组初始化为10</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//扩容机制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	*最大容量 2^18-8</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *	新数组的大小=（原数组大小&gt;&gt;1）+原数组大小 相当于1.5倍</span></span><br><span class="line"><span class="comment">     * 如果太小 则使用原数组大小 如果太大 则使用最大数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	1）扩容：1.空间扩容：先把原来数组内的元素复制到另一个空间大小更大的数组中：</p>
<p>​				2.添加元素：把新元素添加到扩容后的数组中</p>
<p>​	2）安全：ArrayList是非线程安全的</p>
<p>​	3）效率：因为底层根据数组实现 所以对集合内元素的移动操作相对于链表是效率较慢的 适合快速随机存取</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>初始值大小：10</p>
<p>添加元素add方法：首先确定数组大小 使用无参构造函数 第一次添加元素 数组初始化为10</p>
<p>扩容： 新数组的大小&#x3D;（原数组大小&gt;&gt;1）+原数组大小    相当于1.5倍</p>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList:"></a>2.LinkedList:</h3><p>​	底层使用双向链表实现 继承于AbstractSequentialList</p>
<p>​	1）扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加元素的方法 直接将元素添加到最后一个位置</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  2）效率：LinkedList是根据双向链表实现 在增删元素的效率 相对ArrayList略高 但是在存储空间方面 因为要存储指向上一个和下一个元素位置的索引 所以元素的存储空间相对ArrayList较大</p>
<p> 3）安全：和ArrayList一样 LinkedList也是非线程安全的</p>
<h3 id="3-Vertor"><a href="#3-Vertor" class="headerlink" title="3.Vertor"></a>3.Vertor</h3><p>vertor内部实现是类似于ArrayList</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>数据以键值对的形式进行存储</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/%E5%9B%BE%E7%89%871.png" class="" title="图片1">

<h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li><p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标。</p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value 放入链表中</p>
</li>
<li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png" class="" title="img">

<h4 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Table数组的初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//Table数组的最大长度： 1&lt;&lt;302^30=1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//负载因子：默认值为0.75。 当元素的总个数 &gt; 当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>



<h4 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span></span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;　　　　　　</span><br><span class="line">        inflateTable(threshold);<span class="comment">//如果为空，则初始化</span></span><br><span class="line">    &#125;<span class="comment">//判断key是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)<span class="keyword">return</span> putForNullKey(value);<span class="comment">//hashmap允许key为空</span></span><br><span class="line">    <span class="comment">//计算当前key的哈希值　　　</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;　　　　　　</span><br><span class="line">        Object k;<span class="comment">//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);　　　　　　　</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;　　　</span><br><span class="line">    <span class="comment">//存放值的具体方法</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">　　　　<span class="comment">//1、判断当前个数是否大于等于阈值</span></span><br><span class="line">　　　　<span class="comment">//2、当前存放是否发生哈希碰撞</span></span><br><span class="line">　　　　<span class="comment">//如果上面两个条件否发生，如果发生，那么就扩容</span></span><br><span class="line">　　　　<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　<span class="comment">//扩容，并且把原来数组中的元素重新放到新数组中</span></span><br><span class="line">　　　　　　resize(<span class="number">2</span> * table.length);</span><br><span class="line">　　　　　　hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">　　　　Entry[] oldTable = table;</span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">　　　　<span class="comment">//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作</span></span><br><span class="line">　　　　<span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">　　　　　　threshold = Integer.MAX_VALUE;</span><br><span class="line">　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">　　　　<span class="comment">// transfer()方法把原数组中的值放到新数组中</span></span><br><span class="line">　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容后为新的数组引用</span></span><br><span class="line">　　　　table = newTable;</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容新的阈值</span></span><br><span class="line">　　　　threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h4><p>在JDK7中，当new Hashmap()的时候会对对象进行初始化，而<strong>JDK8中new Hashmap()并没有对对象进行初始化</strong>，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。 </p>
<p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行</p>
<p>扩容:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="触发扩容的条件"><a href="#触发扩容的条件" class="headerlink" title="触发扩容的条件"></a>触发扩容的条件</h4><p>​       （1）Java 8 在新增数据存入成功后进行扩容</p>
<p>　　（2）扩容会发生在两种情况下（满足任意一种条件即发生扩容）：</p>
<p>　　　　　　a 当前存入数据大于阈值即发生扩容</p>
<p>　　　　　　b 存入数据到某一条链表时，此时该链表数据个数大于8，且数组长度小于64即发生扩容</p>
<p>　　（3）此外需要注意一点java7是在存入数据前进行判断是否扩容，而java8是在存入数据后再进行扩容的判断。</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2gxNDU4MjgwNzk5,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h4 id="关于树化和扩容"><a href="#关于树化和扩容" class="headerlink" title="关于树化和扩容"></a>关于树化和扩容</h4><p>第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;&#x3D;7,从0开始，及第8个开始<strong>判断是否</strong>转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Hash 这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出</p>
<p>所以 <strong>当散列值（Hash值）相同的时候 不可以判断为 两个输入就相同</strong></p>
<p>哈希碰撞：两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。</p>
<p>将拥有相同哈希值的对象组织成一个链表放在hash值所对应的 bucket下，但相比于hashCode返回的int类型，我们<strong>HashMap初始的容量</strong>大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即2的四次方16）<strong>要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率</strong>，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，即为<strong>扰动函数</strong>，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123; </span><br><span class="line">     <span class="type">int</span> h; </span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将生成的hashcode值的高16位于低16位进行异或运算，这样得到的值再进行相与，一得到最散列的下标值。</span></span><br></pre></td></tr></table></figure>

<p>1.8新增红黑树</p>
<p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)。</p>
<p><strong>HashMap是如何解决哈希冲突的：</strong></p>
<ol>
<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>
<li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li>
<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。（是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)）。</li>
</ol>
<p><strong>HashMap如何有效减少碰撞</strong></p>
<ol>
<li><p>扰动函数算法，促使元素为自豪分布均匀，减少碰撞频率</p>
</li>
<li><p>使用final函数，并采用合适的equals()方法和hashCode方法</p>
</li>
</ol>
<p><strong>HashMap</strong> <strong>的长度为什么是2的幂次方</strong>!</p>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p>那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组</p>
<p>存储下标位置的随机性&amp;均匀性， 终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p>
<p><strong>HashMap的添加元素的过程：</strong></p>
<p><strong>( 1.)第一种就是数组下标下内容为空：</strong><br>这种情况没什么好说的，为空据直接占有这个slot槽位就好了，然后把当前.put方法传进来的key和value包装成一个node对象,放到这个slot中就好了。</p>
<p><strong>( 2.)第二种情况就是数组下标下内容不为空，但它引用的node还没有链化：</strong><br>这种情况下先要对比一下这个node对象的key与当前put对象的key是否完全.相等，如果完全相等的情况下，就行进行replace操作，把之前的槽位中node.下的value替换成新的value就可以了，否则的话这个put操作就是一个正儿.八经的hash冲突,这种情况在slot槽位后面追加一个node就可以了,用尾插法 ( 前面讲过，jdk7是把新增元素添加到头部节点，而jdk8则添加到尾部节点)。</p>
<p><strong>( 3.)第三种就是该数组下标下内容已经被链化了：</strong><br>这种情况和第二种情况处理很相似，首先也是迭代查找node，看看链表上中元素的key，与当前传过来的key是否完全一致，如果完全一致的话还是repleace操作，用put过来的新value替换掉之前node中的value，否则的话就是一致迭代到链表尾节点也没有匹配到完全一致的node，就和之前的一样，把put进来数据包装成node追加到链表的尾部，再检查一下当前链表的长度，有没有达到树化阈值，如果达到了阈值就调用一个树化方法，树化操作都是在这个方法里完成的。</p>
<p><strong>( 4.)第四种情况就是冲突很严重的情况下，这个链表已经转化成红黑树了：</strong><br>红黑树就比较复杂 要将清楚这个红黑树还得从TreeNode说起 TreeNode继承了Node结构，在Node基础上加了几个字段，分别是指向父节点parent字段，指向左子节点left字段，指向右子节点right字段，还有一个表示颜色的red字段，这就是TreeNode的基本结构，然后红黑树的插入操作，首先找到一个合适的插入点，就是找到插入节点的父节点，然后红黑树它又满足二叉树的所有特性，所以找这个父节点的操作和二叉树排序是完全一致的，然后说一下这个二叉树排序，其实就是二分查找算法映射出来的结构，就是一个倒立的二叉树，然后每个节点都可以有自己的子节点，本且左节点小于但前节点，右节点大于当前节点，然后每次向下查找一层就能那个排除掉一半的数据，查找效率非常的高效，当查找的过程中也是分情况的</p>
<p><strong>HashMap的负载因子为什么是0.75？</strong></p>
<ol>
<li>阈值(threshold) &#x3D; 负载因子(loadFactor) x 容量(capacity) 根据HashMap的扩容机制，他会保证容量(capacity)的值永远都是2的幂 为了保证负载因子x容量的结果是一个整数，这个值是0.75(4&#x2F;3)比较合理，因为这个数和任何2的次幂乘积结果都是整数。</li>
<li>理论上来讲，负载因子越大，导致哈希冲突的概率也就越大，负载因子越小，费的空间也就越大,这是一个无法避免的利弊关系，所以通过一个简单的数学推理，可以测算出这个数值在0.75左右是比较合理的</li>
</ol>
<p><strong>HashMap使用String作为key  有什么好处</strong></p>
<p>String作为hashMap的key HashMap是使用hashCode值作为参数 存放key的位置 而String对象是不可变的 在创建的时候 就已经缓存Hash Code值 所以存储对象更快</p>
<p><strong>HashMap 链表转化为红黑树，以及红黑树转化为链表的条件</strong></p>
<p>链表转化为红黑树：hashMap并不是在链表元素个数大于8就一定会转换为红黑树，而是先考虑扩容，扩容达到默认限制后才转换。</p>
<p>红黑树转化为链表：hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。</p>
<h3 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2.ConcurrentHashMap"></a><strong>2.ConcurrentHashMap</strong></h3><p>ConcurrentHashMap的内部实现对整个桶分组进行了分段分割Segment 每一把锁值锁住一部分数据 不会出现资源的恶行竞争 提高效率</p>
<p>（默认分配16个Segment，从效率上来讲 比HashMap高16倍）。</p>
<p>**ConcurrentHashMap 和HashMap的不同 **</p>
<p>ConcurrentHashMap是实现线程安全的ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁行保护，相对于HashTable的synchronized 锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启了一种全新的方式实现,利用CAS算法。） </p>
<p>所以ConcurrentHashMap也分为1.7和1.8两个jdk版本的不同</p>
<p>1.7</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry数组里的元素，当对HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/webp.webp" class="" title="img">

<p>1.8</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用<strong>Node + CAS + Synchronized</strong>来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N 倍。</p>
<p>每一个结点为node  而红黑树的结点为TreeNode</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/image-20220516110334299.png" class="" title="image-20220516110334299">

<p>使用CAS的部分 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    tab = initTable();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;TODO 在具体一点这个1.8的</p>
<p>ConcurrentHashMap的CAS的具体实现：</p>
<ol>
<li>根据键值取出 ConcurrentHashMap 中的节点 <code>Node</code>。</li>
<li>根据更新前的节点计算出一个用于 <code>CAS</code> 操作的锁，锁是旧节点 <code>Node</code> 的 <code>hashcode</code> 左移 16 位的值。</li>
<li>利用 <code>unsafe</code> 的 CAS 操作进行替换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(<span class="type">int</span> i, Node expect, Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该方法中，i 代表了节点的数组下标，expect 代表旧节点，update 代表新节点。</span></span><br></pre></td></tr></table></figure>





<h3 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3.TreeMap"></a>3.TreeMap</h3><p>根据保存的key进行排序（默认排序，可自己定义），默认是按照升序排序的 ，并且不允许key的值为null <strong>非线程同步</strong></p>
<p>排序是SortedMap定义的方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回元素比较器。如果是自然顺序，则返回null；</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回从fromKey到toKey的集合：含头不含尾</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从头到toKey的集合：不包含toKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从fromKey到结尾的集合：包含fromKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer,Integer&gt; map= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * int compare(Object o1, Object o2) 返回一个基本类型的整型，</span></span><br><span class="line"><span class="comment">     * 返回负数表示：o1 小于o2，</span></span><br><span class="line"><span class="comment">     * 返回0 表示：o1和o2相等，</span></span><br><span class="line"><span class="comment">     * 返回正数表示：o1大于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b-a;<span class="comment">//倒序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong>TreeMap <strong>？</strong></p>
<p>对于在Map中插入、删除和查询元素这类操作，HashMap是 好的选择。</p>
<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，</p>
<p>也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h3 id="4-HashTable"><a href="#4-HashTable" class="headerlink" title="4.HashTable"></a>4.HashTable</h3><p>和hashmap类似 但不允许key或value为null 支持线程同步 只允许一条线程同时操作HashTable <strong>线程同步</strong></p>
<p>HashTable基本被淘汰</p>
<p><strong>与HashMap的区别</strong></p>
<p>1.线程安全; HashMap是非线程安全的 HashTable是线程安全的 HashTable的内部方法基本都经过synchronized修饰</p>
<p>（但是如果想要保证线程安全的话 请使用ConcurrentHashMap吧）</p>
<p>2.效率： 众所周知 鱼和熊掌不可兼得 保证了安全性 那一定会牺牲效率 </p>
<p>3.对null的支持： HashMap中 null可以作为键 但是只能有一个 对应的value可以多个为null </p>
<p>​								HashTable中 null如果添加 不论是key or value 则直接抛空指针异常NullPointerException。</p>
<p>4.初始容量大小的不同：</p>
<p>①如果不指定容量 HashTable的大小是11  每次扩容为2n+1</p>
<p>​	而hashMap的默认初始化大小是16	扩容为两倍（左移一位）</p>
<p>②HashTable如果指定了大小 则会初始化为指定大小 而HashMap则会在指定大小的基础上 扩充为2的幂次方</p>
<p>5.使用场景 ：HashTable如果是单线程使用 则推荐使用HashMap 如果是多线程使用 则推荐ConcurrentHashMap</p>
<p>​						因为HashTable是将整个表都锁 减少了并发的效率</p>
<h3 id="5-LinkedListMap"><a href="#5-LinkedListMap" class="headerlink" title="5.LinkedListMap"></a>5.LinkedListMap</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>不允许重复的元素存在 </p>
<p>只允许一个元素为null </p>
<p> 非线程安全</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>元素是无序的</p>
<p>首先是构造方法 直接创建了一个HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>说明 Set是用Map的key存储内容 而map的value 是在set中创建的Object类对象PRESENT</p>
<p>PRESENT为了使用HashMap而创建的一个Object对象，用来占掉value的位置，无其他意义 。</p>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>因为结构就是根据Hashmap生成 添加元素的方法也是根据Hashmap的put方法，结构同上。</p>
<p>hashset为什么要重写hashcode和equals方法？<br>在Hashset种 为了保证元素的不重复性 首先计算添加元素的hash值 计算hash值后 在map的区域算法计算去应该添加的桶位置<br>如果该位置有没有元素 则直接 添加<br>如果该位置铀元素 则进行equals（）判断 如果这两个内容相同 则替换原来的元素<br>                    如果不同 则添加到该位置元素的后面 以链表的形式存储 之后就和Hashmap相同</p>
<p>但是如果不重写HashCode  那么对于一些引用类型的对象 即使两者的内容和属性完全相同 两者的Hashcode也不会相同 那么就会出现Set种存在两个相同应用类型的对象<br>所以 当重写HashCode 那么对于两个内容完全相同的元素 也会计算出相同的HashCode值 完全符合Set 元素不重复的特点<br>equals()比较的是 当出现Hash冲突的时候 判断两个元素是否是完全相同的元素 如果不是才会添加<br>使用hashcode进行判断 也大大的减少了equals()的比较次数 增加了效率。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>元素是有序的</p>
<p>元素是使用它们的自然顺序来排序的，或者通过在设置的创建时提供的比较器来排序的，这取决于使用的是哪个构造函数</p>
<p>构造方法：同样是借助Map 但是TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层结构：二叉树排序。 </p>
<h5 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h5><p>Comparable与Comparator实际上是TreeSet集合的两种实现方式，用来实现对象的排序。</p>
<ol>
<li>Comparable称为元素的自然顺序，或者叫做默认顺序。</li>
<li>Comparator称为元素定制排序。</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>此过程主要由LinkedHashSet.class中重写超类的两个addEntry和createEntry 实现双向链表的结构。保证数据已我们录入的顺序遍历输出</p>
<h1 id="巨人的肩膀："><a href="#巨人的肩膀：" class="headerlink" title="巨人的肩膀："></a>巨人的肩膀：</h1><p><a href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>​	<a href="https://www.cnblogs.com/yanzige/p/8392142.html">深入理解HashMap的扩容机制 - 颜子歌 - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
