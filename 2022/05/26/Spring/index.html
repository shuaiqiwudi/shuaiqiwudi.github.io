<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-nextwechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[Spring官网]Spring | Home   什么是Spring?Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="http://example.com/2022/05/26/Spring/index.html">
<meta property="og:site_name" content="shuaiqiwudi blog">
<meta property="og:description" content="[Spring官网]Spring | Home   什么是Spring?Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175028291-16536637559683.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220731112029587.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175017424-16536637765225-16536638098216.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526174932412-16536638610858.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175457607-16536638760849.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175600355-165366388819310.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175612242-165366391229911.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220526175650919-165366393348713.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220528103213112.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220528111158974.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/70.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/image-20220528111124796.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220805154104.jpg">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI0NjUxOA==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/bean%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16537349916045.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/webp.webp">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/format,png-16599262367702.png">
<meta property="og:image" content="http://example.com/spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6X3NtYWxscmVk,size_16,color_FFFFFF,t_70#pic_center.jpeg">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/format,png-16594342853715.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/format,png-16594339917133.png">
<meta property="og:image" content="http://example.com/2022/05/26/Spring/format,png-16594344712637.png">
<meta property="article:published_time" content="2022-05-26T01:26:34.000Z">
<meta property="article:modified_time" content="2022-08-22T05:32:34.675Z">
<meta property="article:author" content="zh-CN">
<meta property="article:tag" content="zsr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg">

<link rel="canonical" href="http://example.com/2022/05/26/Spring/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spring | shuaiqiwudi blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shuaiqiwudi blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/26/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zh-CN">
      <meta itemprop="description" content="The Blog Which Owned Shuaiqiwudi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuaiqiwudi blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-26 09:26:34" itemprop="dateCreated datePublished" datetime="2022-05-26T09:26:34+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 13:32:34" itemprop="dateModified" datetime="2022-08-22T13:32:34+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/05/26/Spring/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/26/Spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>42k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>38 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[Spring官网]<a target="_blank" rel="noopener" href="https://spring.io/">Spring | Home</a></p>
<img src="/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg" class="" title="v2-f35943a6d87c5f9f10f45eee4941deb3_720w">

<h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h1><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的大小。	然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>​	<strong>简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。</strong></p>
<span id="more"></span>

<h1 id="Spring的核心组件"><a href="#Spring的核心组件" class="headerlink" title="Spring的核心组件"></a>Spring的核心组件</h1><img src="/2022/05/26/Spring/image-20220526175028291-16536637559683.png" class="" title="image-20220526175028291">

<h1 id="Spring大致加载流程"><a href="#Spring大致加载流程" class="headerlink" title="Spring大致加载流程"></a>Spring大致加载流程</h1><img src="/2022/05/26/Spring/image-20220731112029587.png" class="" title="image-20220731112029587">

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Spring是一个生态圈，需要的是新的拓展功能不停的进行完善，所以我们可以通过BeanFactoryPostProcesser和BeanPostProcesser进行Spring功能的拓展。所以 Spring最核心的一个思想就是<strong>拓展</strong>。</p>
<h2 id="BeanFactoryPostProcesser："><a href="#BeanFactoryPostProcesser：" class="headerlink" title="BeanFactoryPostProcesser："></a>BeanFactoryPostProcesser：</h2><p><strong>功能：允许自定义对ApplicationContext的 bean definitions 进行修饰，扩展功能。</strong> </p>
<p>BeanFactoryPostProcessor是<strong>实现spring容器功能扩展的重要接口</strong>，例如修改bean属性值，实现bean动态代理等。很多框架都是通过此接口实现对spring容器的扩展，例如mybatis与spring集成时，只定义了mapper接口，无实现类，但spring却可以完成自动注入。</p>
<p>BeanFactoryPostProcessor的主体是BeanFactory，并且该接口中只定义了一个方法，其将会在ApplicationContext内部的BeanFactory加载完bean的定义后，但是在对应的bean实例化之前进行回调。所以通常我们可以通过实现该接口来对实例化之前的bean定义进行修改。</p>
<p>BeanFactoryPostProcessor可以对bean的定义（<strong>配置元数据</strong>）进行处理。也就是说，<strong>Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其它的bean之前读取配置元数据，并有可能修改它</strong>。如果你愿意，你可以配置多个BeanFactoryPostProcessor。你还能通过设置’order’属性来控制BeanFactoryPostProcessor的<strong>执行次序</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是BeanFactoryPostProcessor接口的定义，其中只定义了一个方法。接下来我们来定义一个自己的BeanFactoryPostProcessor，用以输出当前bean容器中bean定义的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">			ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">//获取所有的beanName</span></span><br><span class="line">		String beanNames[] = beanFactory.getBeanDefinitionNames();</span><br><span class="line">		<span class="keyword">if</span> (beanNames != <span class="literal">null</span> &amp;&amp; beanNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">				<span class="comment">//获取对应的bean定义</span></span><br><span class="line">				beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">				<span class="built_in">this</span>.printBeanDef(beanName, beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印bean定义的基本信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDef</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printBeanDef</span><span class="params">(String beanName, BeanDefinition beanDef)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">defStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;beanName: &quot;</span>).append(beanName);</span><br><span class="line">		defStr.append(<span class="string">&quot;, className: &quot;</span>).append(beanDef.getBeanClassName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, scope: &quot;</span>).append(beanDef.getScope());</span><br><span class="line">		defStr.append(<span class="string">&quot;, parent: &quot;</span>).append(beanDef.getParentName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryBean: &quot;</span>).append(beanDef.getFactoryBeanName());</span><br><span class="line">		defStr.append(<span class="string">&quot;, factoryMethod: &quot;</span>).append(beanDef.getFactoryMethodName());</span><br><span class="line">		System.out.println(defStr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<strong>BeanFactoryPostProcessor是针对于bean容器的</strong>，在调用它时，BeanFactory只加载了bean的定义，<strong>还没有对它们进行实例化</strong>，所以我们可以通过对BeanFactory的处理来达到影响之后实例化bean的效果。跟BeanPostProcessor一样，ApplicationContext也能自动检测和调用容器中的BeanFactoryPostProcessor。 </p>
<h2 id="BeanPostProcesser："><a href="#BeanPostProcesser：" class="headerlink" title="BeanPostProcesser："></a>BeanPostProcesser：</h2><p>BeanPostProcessor 可以在 spring 容器实例化 bean 之后，在执行 bean 的初始化方法前后，添加一些自己的处理逻辑。 这里说的初始化方法，指的是以下两种：</p>
<ol>
<li>bean 实现 了 InitializingBean 接口，对应的方法为 afterPropertiesSet 。</li>
<li>在 XML 文件中定义 bean 的时候，<bean>标签有个属性叫做 init-method，来指定初始化方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125; </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.    </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务  </span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean </span><br><span class="line">     * initialization callbacks (like InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125;   </span><br><span class="line">     * or a custom init-method). The bean will already be populated with property values.       </span><br><span class="line">     */  </span><br><span class="line">　　//实例化、依赖注入、初始化完毕时执行  </span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个接口的某个实现类被注册到某个容器，<strong>那么该容器的每个受管Bean在调用初始化方法的前后，都会获得该接口实现类的一个回调</strong>。容器调用接口定义的方法时会将该受管Bean的实例和名字通过参数传入方法，经过处理后通过方法的返回值返回给容器。</p>
<p>要使用BeanPostProcessor回调，就必须先在容器中注册实现该接口的类，那么如何注册呢？BeanFactory和ApplicationContext容器的注册方式不大一样：</p>
<ul>
<li>若使用BeanFactory，则必须要显示的调用其addBeanPostProcessor()方法进行注册，参数为BeanPostProcessor实现类的实例；</li>
<li>如果是使用ApplicationContext，那么容器会在配置文件在中自动寻找实现了BeanPostProcessor接口的Bean，然后自动注册，我们要做的只是配置一个BeanPostProcessor实现类的Bean就可以了。</li>
</ul>
<p>假如我们使用了多个的BeanPostProcessor的实现类，那么如何确定处理顺序呢？其实只要实现Ordered接口，设置order属性就可以很轻松的确定不同实现类的处理顺序了。</p>
<h2 id="BeanFactoryPostProcessor和BeanPostProcessor"><a href="#BeanFactoryPostProcessor和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcessor和BeanPostProcessor"></a>BeanFactoryPostProcessor和BeanPostProcessor</h2><p>相同点：</p>
<p>1.BeanFactoryPostProcessor和BeanPostProcessor都是<strong>spring初始化bean的扩展点</strong>。两个接口非常相似。</p>
<p>2.二者都可以被ApplicationContext自动检测到。</p>
<p>不同点：</p>
<p><strong>BeanFactoryPostProcessor 作用于 bean 实例化之前，读取配置元数据，并且可以修改；而 BeanPostProcessor 作用于 bean 的实例化过程中，然后可以改变 bean 实例（例如从配置元数据创建的对象）。</strong></p>
<h2 id="执行的过程如下"><a href="#执行的过程如下" class="headerlink" title="执行的过程如下:"></a><strong>执行的过程如下:</strong></h2><p>1.ResouceLoader加载配置信息<br>2.解析配置信息，生成一个一个的BeanDefintion<br>3.BeanDefintion由BeanDefintionRegistry管理起来<br>4.BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)<br>5.实例化Bean<br>6.如果该Bean配置&#x2F;实现了InstantiationAwareBean，则调用对应的方法<br>7.使用BeanWarpper来完成对象之间的属性配置(依赖)<br>8.如果该Bean配置&#x2F;实现了Aware接口，则调用对应的方法<br>9.如果该Bean配置了BeanPostProcessor的before方法，则调用<br>10.如果该Bean配置了init-method或者实现InstantiationBean，则调用对应的方法<br>11.如果该Bean配置了BeanPostProcessor的after方法，则调用<br>12.将对象放入到HashMap中<br>13.最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</p>
<h1 id="Spring浅看"><a href="#Spring浅看" class="headerlink" title="Spring浅看"></a>Spring浅看</h1><img src="/2022/05/26/Spring/image-20220526175017424-16536637765225-16536638098216.png" class="" title="image-20220526175017424-16536637765225">

<img src="/2022/05/26/Spring/image-20220526174932412-16536638610858.png" class="" title="image-20220526174932412">

<img src="/2022/05/26/Spring/image-20220526175457607-16536638760849.png" class="" title="image-20220526175457607">

<p>bean注入与装配的的方式有很多种，可以通过xml，get, set方式，构造函数或者注解等。简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式，让项目阅读和开发起来更加方便。</p>
<img src="/2022/05/26/Spring/image-20220526175600355-165366388819310.png" class="" title="image-20220526175600355">

<img src="/2022/05/26/Spring/image-20220526175612242-165366391229911.png" class="" title="image-20220526175612242">

<p>它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。Spring框架的开发不是为了替代现有的优秀第三方框架，而是通过集成的方式把它们都连接起来。下面总结了一些常集成的优秀框架。</p>
<img src="/2022/05/26/Spring/image-20220526175650919-165366393348713.png" class="" title="image-20220526175650919">

<h1 id="SpringIOC-和-Spring-AOP"><a href="#SpringIOC-和-Spring-AOP" class="headerlink" title="SpringIOC 和 Spring AOP"></a>SpringIOC 和 Spring AOP</h1><p>作为Spring框架最核心的两个“功能” ，需要完全理解IOC和AOP，才能真正灵活正确的使用Spring框架 ，而Spring框架作为Spring全家桶系列的最基础的使用框架，它的最核心功能就是—拓展， 让这个框架的功能越来越丰富，在基石上创建最实用的功能。</p>
<p>spring的IoC容器是spring的核心，spring AOP是spring框架的重要组成部分。</p>
<h2 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h2><p>在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此被称作控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），<strong>依赖注入和控制反转是同一个概念。</strong></p>
<p>IOC:控制反转也叫依赖注入。利用了<strong>工厂模式</strong></p>
<p>将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p>
<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p>面向切面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使IoC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。</p>
<p>AOP:面向切面编程。（Aspect-Oriented Programming）<br><strong>AOP可以说是对OOP的补充和完善:</strong></p>
<p>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义<strong>从上到下</strong>的关系，但并不适合定义<strong>从左到右</strong>的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br><strong>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面</strong>，然后注入到目标对象（具体业务逻辑）中去。</p>
<p>&#x2F;&#x2F;TODO AOP的具体实现步骤 （ 帮助理解） </p>
<h2 id="Spring中beanFactory和ApplicationContext的联系和区别"><a href="#Spring中beanFactory和ApplicationContext的联系和区别" class="headerlink" title="Spring中beanFactory和ApplicationContext的联系和区别"></a><strong>Spring中beanFactory和ApplicationContext的联系和区别</strong></h2><p>声明二者之间的关系：</p>
<p>早期的电脑性能低，内存小，所以spring容器的容量不足，不能讲所以的对象全部创建好放入容器，所以使用的是BeanFactory，需要某个对象时，再进行创建，随着电脑硬件的发展，内存越来越大，所以spring框架引入了ApplicationContext，将所有的对象都创建好，放入容器，使用哪个对象，从容器中取得即可。</p>
<p><strong>一、 BeanFactory</strong></p>
<p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。也是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>
<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。</p>
<p>BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。来看一下BeanFactory的基本类体系结构（接口为主）：</p>
<img src="/2022/05/26/Spring/image-20220528103213112.png" class="" title="image-20220528103213112">

<p>1、BeanFactory作为一个主接口不继承任何接口，暂且称为<strong>一级接口</strong>。<br>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为<strong>二级接口</strong>。<br>3、ConfigurableBeanFactory可以被称为<strong>三级接口</strong>，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为<strong>四级接口</strong>。（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。</p>
<p>BeanFactory接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111158974.png" class="" title="image-20220528111158974">

<details> 
    <summary><font color=blue>点击查看BeanFactory接口源码</font></summary> 
    <pre><code>   
/**
 *The root interface for accessing a Spring bean container.
 * This is the basic client view of a bean container;
 * further interfaces such as &#123;@link ListableBeanFactory&#125; and
 * &#123;@link org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;
 * are available for specific purposes.
 *
 * This interface is implemented by objects that hold a number of bean definitions,
 * each uniquely identified by a String name. Depending on the bean definition,
 * the factory will return either an independent instance of a contained object
 * (the Prototype design pattern), or a single shared instance (a superior
 * alternative to the Singleton design pattern, in which the instance is a
 * singleton in the scope of the factory). Which type of instance will be returned
 * depends on the bean factory configuration: the API is the same. Since Spring
 * 2.0, further scopes are available depending on the concrete application
 * context (e.g. "request" and "session" scopes in a web environment).
 *
 * Bean factory implementations should support the standard bean lifecycle interfaces
 * as far as possible. The full set of initialization methods and their standard order is:
 * <ol>
 * <li>BeanNameAware's &#123;@code setBeanName&#125;
 * <li>BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;
 * <li>BeanFactoryAware's &#123;@code setBeanFactory&#125;
 * <li>EnvironmentAware's &#123;@code setEnvironment&#125;
 * <li>EmbeddedValueResolverAware's &#123;@code setEmbeddedValueResolver&#125;
 * <li>ResourceLoaderAware's &#123;@code setResourceLoader&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125;
 * (only applicable when running in an application context)
 * <li>MessageSourceAware's &#123;@code setMessageSource&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationContextAware's &#123;@code setApplicationContext&#125;
 * (only applicable when running in an application context)
 * <li>ServletContextAware's &#123;@code setServletContext&#125;
 * (only applicable when running in a web application context)
 * <li>&#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors
 * <li>InitializingBean's &#123;@code afterPropertiesSet&#125;
 * <li>a custom init-method definition
 * <li>&#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors
 * </ol>
 *
 * On shutdown of a bean factory, the following lifecycle methods apply:
 * <ol>
 * <li>&#123;@code postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors
 * <li>DisposableBean's &#123;@code destroy&#125;
 * <li>a custom destroy-method definition
 * </ol>
 */
public interface BeanFactory &#123;
   /**
    * Used to dereference a &#123;@link FactoryBean&#125; instance and distinguish it from
        * beans <i>created</i> by the FactoryBean. For example, if the bean named
        * &#123;@code myJndiObject&#125; is a FactoryBean, getting &#123;@code &myJndiObject&#125;
        * will return the factory, not the instance returned by the factory.
        */
      String FACTORY_BEAN_PREFIX = "&";
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
        * This method allows a Spring BeanFactory to be used as a replacement for the
        * Singleton or Prototype design pattern. Callers may retain references to
        * returned objects in the case of Singleton beans.
        * Translates aliases back to the corresponding canonical bean name.
        * Will ask the parent factory if the bean cannot be found in this factory instance.
        * @param name the name of the bean to retrieve
        * @return an instance of the bean
        * @throws NoSuchBeanDefinitionException if there is no bean definition
        * with the specified name
        * @throws BeansException if the bean could not be obtained
        */
      Object getBean(String name) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Behaves the same as &#123;@link #getBean(String)&#125;, but provides a measure of type
    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the
    * required type. This means that ClassCastException can't be thrown on casting
    * the result correctly, as can happen with &#123;@link #getBean(String)&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to retrieve
    * @param requiredType type the bean must match. Can be an interface or superclass
    * of the actual class, or &#123;@code null&#125; for any match. For example, if the value
    * is &#123;@code Object.class&#125;, this method will succeed whatever the class of the
    * returned instance.
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanNotOfRequiredTypeException if the bean is not of the required type
    * @throws BeansException if the bean could not be created
    */
   <T> T getBean(String name, Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * @param name the name of the bean to retrieve
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 2.5
    */
   Object getBean(String name, Object... args) throws BeansException;
   /**
    * Return the bean instance that uniquely matches the given object type, if any.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @return an instance of the single bean matching the required type
    * @throws NoSuchBeanDefinitionException if no bean of the given type was found
    * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
    * @throws BeansException if the bean could not be created
    * @since 3.0
    * @see ListableBeanFactory
    */
   <T> T getBean(Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 4.1
    */
   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
   /**
    * Does this bean factory contain a bean definition or externally registered singleton
    * instance with the given name?
    * If the given name is an alias, it will be translated back to the corresponding
    * canonical bean name.
    * If this factory is hierarchical, will ask any parent factory if the bean cannot
    * be found in this factory instance.
    * If a bean definition or singleton instance matching the given name is found,
    * this method will return &#123;@code true&#125; whether the named bean definition is concrete
    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;@code true&#125;
    * return value from this method does not necessarily indicate that &#123;@link #getBean&#125;
    * will be able to obtain an instance for the same name.
    * @param name the name of the bean to query
    * @return whether a bean with the given name is present
    */
   boolean containsBean(String name);
   /**
    * Is this bean a shared singleton? That is, will &#123;@link #getBean&#125; always
    * return the same instance?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * independent instances. It indicates non-singleton instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isPrototype&#125; operation to explicitly
    * check for independent instances.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean corresponds to a singleton instance
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @see #getBean
    * @see #isPrototype
    */
   boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
   /**
    * Is this bean a prototype? That is, will &#123;@link #getBean&#125; always return
    * independent instances?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * a singleton object. It indicates non-independent instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isSingleton&#125; operation to explicitly
    * check for a shared singleton instance.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean will always deliver independent instances
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.3
    * @see #getBean
    * @see #isSingleton
    */
   boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code ResolvableType&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 4.2
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code Class&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.1
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Determine the type of the bean with the given name. More specifically,
    * determine the type of object that &#123;@link #getBean&#125; would return for the given name.
    * For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates,
    * as exposed by &#123;@link FactoryBean#getObjectType()&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return the type of the bean, or &#123;@code null&#125; if not determinable
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 1.1.2
    * @see #getBean
    * @see #isTypeMatch
    */
   Class<?> getType(String name) throws NoSuchBeanDefinitionException;
   /**
    * Return the aliases for the given bean name, if any.
    * All of those aliases point to the same bean when used in a &#123;@link #getBean&#125; call.
    * If the given name is an alias, the corresponding original bean name
    * and other aliases (if any) will be returned, with the original bean name
    * being the first element in the array.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the bean name to check for aliases
    * @return the aliases, or an empty array if none
    * @see #getBean
    */
   String[] getAliases(String name);
&#125;
    </code></pre> 
</details>

<p>总结：</p>
<p>1、4个获取实例的方法。getBean的重载方法。<br>2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<p>BeanFactory最常见的实现类为XmlBeanFactory，可以从classpath或文件系统等获取资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;classpath.xml&quot;</span>); </span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>



<p><strong>二、 ApplicationContext</strong></p>
<p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</p>
<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>
<p>（1）MessageSource, 提供国际化的消息访问<br>（2）资源访问，如URL和文件<br>（3）事件传播特性，即支持aop特性<br>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </p>
<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。</p>
<p><strong>ApplicationContext的继承关系图:</strong></p>
<img src="/2022/05/26/Spring/70.png" class="" title="img">

<p>ApplicationContext接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111124796.png" class="" title="image-20220528111124796">

<details> 
    <summary>
        <font color=blue>点击查看ApplicationContext源码</font>
    </summary> 
    <pre><code>  
 /**
 * Central interface to provide configuration for an application.
 * This is read-only while the application is running, but may be
 * reloaded if the implementation supports this.
 *
 *  An ApplicationContext provides:
 * <ul>
 * <li>Bean factory methods for accessing application components.
 * Inherited from &#123;@link org.springframework.beans.factory.ListableBeanFactory&#125;.
 * <li>The ability to load file resources in a generic fashion.
 * Inherited from the &#123;@link org.springframework.core.io.ResourceLoader&#125; interface.
 * <li>The ability to publish events to registered listeners.
 * Inherited from the &#123;@link ApplicationEventPublisher&#125; interface.
 * <li>The ability to resolve messages, supporting internationalization.
 * Inherited from the &#123;@link MessageSource&#125; interface.
 * <li>Inheritance from a parent context. Definitions in a descendant context
 * will always take priority. This means, for example, that a single parent
 * context can be used by an entire web application, while each servlet has
 * its own child context that is independent of that of any other servlet.
 * </ul>
 *
 *  In addition to standard &#123;@link org.springframework.beans.factory.BeanFactory&#125;
 * lifecycle capabilities, ApplicationContext implementations detect and invoke
 * &#123;@link ApplicationContextAware&#125; beans as well as &#123;@link ResourceLoaderAware&#125;,
 * &#123;@link ApplicationEventPublisherAware&#125; and &#123;@link MessageSourceAware&#125; beans.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see ConfigurableApplicationContext
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.core.io.ResourceLoader
 */
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;
/**
     * Return the unique id of this application context.
     * @return the unique id of the context, or &#123;@code null&#125; if none
     */
    String getId();
    /**
     * Return a name for the deployed application that this context belongs to.
     * @return a name for the deployed application, or the empty String by default
     */
    String getApplicationName();
    /**
     * Return a friendly name for this context.
     * @return a display name for this context (never &#123;@code null&#125;)
     */
    String getDisplayName();
    /**
     * Return the timestamp when this context was first loaded.
     * @return the timestamp (ms) when this context was first loaded
     */
    long getStartupDate();
    /**
     * Return the parent context, or &#123;@code null&#125; if there is no parent
     * and this is the root of the context hierarchy.
     * @return the parent context, or &#123;@code null&#125; if there is no parent
     */
    ApplicationContext getParent();
    /**
     * Expose AutowireCapableBeanFactory functionality for this context.
     *  This is not typically used by application code, except for the purpose of
     * initializing bean instances that live outside of the application context,
     * applying the Spring bean lifecycle (fully or partly) to them.
     *  Alternatively, the internal BeanFactory exposed by the
     * &#123;@link ConfigurableApplicationContext&#125; interface offers access to the
     * &#123;@link AutowireCapableBeanFactory&#125; interface too. The present method mainly
     * serves as a convenient, specific facility on the ApplicationContext interface.
     *  <b>NOTE: As of 4.2, this method will consistently throw IllegalStateException
     * after the application context has been closed.</b> In current Spring Framework
     * versions, only refreshable application contexts behave that way; as of 4.2,
     * all application context implementations will be required to comply.
     * @return the AutowireCapableBeanFactory for this context
     * @throws IllegalStateException if the context does not support the
     * &#123;@link AutowireCapableBeanFactory&#125; interface, or does not hold an
     * autowire-capable bean factory yet (e.g. if &#123;@code refresh()&#125; has
     * never been called), or if the context has been closed already
     * @see ConfigurableApplicationContext#refresh()
     * @see ConfigurableApplicationContext#getBeanFactory()
     */
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
&#125;
    </code></pre> 
</details>

<p><strong>三、二者区别</strong></p>
<p>不同点：Bean的加载时机</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身时检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。<br>应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相同点：</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）</p>
<h2 id="Spring用到的设计模式"><a href="#Spring用到的设计模式" class="headerlink" title="Spring用到的设计模式"></a>Spring用到的设计模式</h2><p>Spring作为一款及其优秀的框架，其代码的编写非常优秀，里面采用了大量的设计模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 这两个接口 来创建 bean 对象。<br>两者对比：</p>
<ul>
<li><p>BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li><p>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 由 BeanFactory 派生而来 ，提供了更多面向实际应用的功能 ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</p>
</li>
</ul>
<h5 id="设置延迟加载的方式："><a href="#设置延迟加载的方式：" class="headerlink" title="设置延迟加载的方式："></a>设置延迟加载的方式：</h5><p>方式1：对单个Bean对象进行延迟加载</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例如连接池的延时加载设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  通过数据库连接池给我们提供的init方法和 close方法进行设置 指定初始化（类似构造器）到销毁的具体方法。</span><br></pre></td></tr></table></figure>
<p>方式2：对Bean标签集中的所有bean对象都进行延迟加载设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;com.beans.ConnectionPool&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h5 id="Bean对象的作用域"><a href="#Bean对象的作用域" class="headerlink" title="Bean对象的作用域"></a>Bean对象的作用域</h5><p>Spring中bean对象的默认作用域就是singleton ，创建以后一直存在，除了singleton的作用域，还有其他的作用域。</p>
<ul>
<li>singleton：对于延迟加载，只有在第一次获取bean的时候才会加载这个bean对象，否则直接生成，但都是IOC容器的唯一对象</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>globalSession 用于分布式web开发中，创建的实例绑定全局session对象</li>
</ul>
<p>对于<strong>prototype作用域的bean对象</strong>：</p>
<p>作用域为 prototype 的 bean ，其destroy方法并没有被调用。如果 bean 的 scope 设为prototype时，<strong>当容器关闭时，destroy 方法不会被调用</strong>。对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring不能对一个 prototype bean 的整个生命周期负责：<strong>容器在初&#x2F;始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。</strong> 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。<strong>清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责</strong>（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。<br>谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由<strong>客户端</strong>来处理。<br>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，<strong>Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<p>​											<strong>（Spring容器对prototype作用域的bean对象 ——只管生，不管养）</strong></p>
<p>Spring通过<strong>ConcurrentHashMap</strong>实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;  </span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例    </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。  </span></span><br><span class="line">                addSingleton(beanName, singletonObject);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将对象添加到单例注册表  </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Spring的注册表</p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Spring中策略模式的应用</p>
<p>当bean需要访问资源配置文件时，Spring有两种方式</p>
<p>1.代码中获取Rescource实例<br>2.依赖注入<br>第一种方式需要获取rescource资源的位置，代码中耦合性太高，而今我们一直使用注解，依赖注入的方式去获取。这样的话就无需修改程序，只改配置文件即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Test&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- 注入资源 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tmp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:book.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>在依赖注入的过程中，<strong>Spring会调用ApplicationContext 来获取Resource的实例</strong>。然而，Resource 接口封装了各种可能的资源类型，包括了：UrlResource，ClassPathResource，FileSystemResource等，Spring需要针对不同的资源采取不同的访问策略。在这里，Spring让ApplicationContext成为了资源访问策略的“决策者”。<strong>在资源访问策略的选择上，Spring采用了策略模式。</strong>当 Spring 应用需要进行资源访问时，它并不需要直接使用 Resource 实现类，而是<strong>调用 ApplicationContext 实例的 getResource() 方法来获得资源。ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略</strong>，从而将应用程序和具体的资源访问策略分离开来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> PathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;book.xml&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>上面的代码中，Spring 将采用和 ApplicationContext 相同的策略来访问资源。即： ApplicationContext 是ClassPathXmlApplicationContext，则res 就是 ClassPathResource 实例。若将代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>通过使用修饰模式，可以在运行时扩充一个类的功能。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//根据指定的bean使用对应的侧脸创建新的实例，如工厂方法，构造函数自动注入，简单初始化</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。如下图所示：</p>
<img src="/2022/05/26/Spring/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220805154104.jpg" class="" title="微信图片_20220805154104">

<p>当然你也可以使用AspectJ，Spring AOP已经继承了AspectJ,AspectJ应该算的上是java生态系统中最完整的AOP框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。<br>动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。</p>
<p><strong>jdk动态代理，必须有接口，目标类必须实现jdk动态代理的接口， 没有接口时，需要使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=cglib&spm=1001.2101.3001.7020">cglib</a>动态代理。</strong></p>
<p><strong>动态代理能做什么？</strong></p>
<p>可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。</p>
<p>举例：</p>
<p>在开发中也会有这样的情况， 你有a类， 本来是调用c类的方法， 完成某个功能。 但是c不让a调用。</p>
<p>a —–不能调用 c的方法。<br>在a 和 c 直接 创建一个 b 代理， c让b访问。<br>a –访问b—访问c</p>
<p>实际的例子： 登录，注册有验证码， 验证码是手机短信。<br>中国移动， 联通能发短信。<br>中国移动， 联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能<br>张三项目发送短信—-子公司，或者关联公司—–中国移动， 联通</p>
<p><strong>使用代理模式的作用</strong></p>
<ol>
<li>功能增强： 在你原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强。</li>
<li>控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。</li>
</ol>
<p><strong>实现代理的方式：</strong></p>
<ol>
<li><p>静态代理</p>
<p>代理类是自己手工实现的，自己创建一个java类，表示代理类。<br>同时你所要代理的目标类是确定的。</p>
<p>特点：</p>
<p>1）实现简单 2）容易理解。<br>缺点：当你的项目中，目标类和代理类很多时候，有以下的缺点<br>1）当目标类增加了， 代理类可能也需要成倍的增加。 代理类数量过多。<br>2）当你的接口中功能增加了， 或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。jdk动态代理实现</p>
</li>
<li><p>动态代理</p>
<p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。<br>1）代理类数量可以很少，<br>2）当你修改了接口中的方法时，不会影响代理类。</p>
<p>动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理类对象， 并动态的指定要代理目标类。换句话说， 动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。</p>
<hr>
<p>在java中，要想创建对象：</p>
<p>创建类文件， java文件编译为class<br>使用构造方法，创建类的对象。</p>
<hr>
<p>而<strong>动态代理的实现</strong>：<br>反射包 java.lang.reflect , 包含 一个接口 ： InvocationHandler </p>
<p>​													 两个类	： Method, Proxy</p>
<p>(1)InvocationHandler 接口（调用处理器）：</p>
<p>只有一个方法invoke（）：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>(2) Method类：表示方法的， 确切的说就是目标类中的方法。</p>
<p>作用：通过Method可以执行某个目标类的方法，Method.invoke();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(目标对象，方法的参数)</span><br><span class="line"><span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(service2, “李四”);</span><br><span class="line"><span class="comment">// method.invoke（）就是用来执行目标方法的，等同于静态代理中的</span></span><br><span class="line"><span class="comment">//向厂家发送订单，告诉厂家，我买了u盘，厂家发货</span></span><br><span class="line"><span class="comment">//float price = factory.sell(amount); //厂家的价格。</span></span><br></pre></td></tr></table></figure>

<p>(3) Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法(),现在我们是使用Proxy类的方法，代替new的使用。</p>
<p>方法： 静态方法 newProxyInstance()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                         Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                         InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>作用： 创建代理对象， 等同于静态代理中的TaoBao taoBao &#x3D; new TaoBao();<br>参数：<br>ClassLoader loader 类加载器，负责向内存中加载对象的。 使用反射获取对象的ClassLoader类a , a.getCalss().getClassLoader(), 目标对象的类加载器<br>Class&lt;?&gt;[] interfaces： 接口， 目标对象实现的接口，也是反射获取的。<br>InvocationHandler h : 我们自己写的，代理类执行invoke()方法，实现要完成的功能。</p>
<p>这样我们就完成了JDK的动态代理流程。</p>
</li>
</ol>
<h4 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h4><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p>
<p>cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。</p>
<p>CGLIB的核心类：<br>    net.sf.cglib.proxy.Enhancer – 主要的增强类<br>    net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>    net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>    Object o &#x3D; methodProxy.invokeSuper(proxy, args);&#x2F;&#x2F;虽然第一个参数是被代理对象，也不会出现死循环的问题。</p>
<p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, java.lang.reflect.Method method,Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++before &quot;</span> + methodProxy.getSuperName() + <span class="string">&quot;++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.hyt.test3.cglib;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.meituan.hyt.test3.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(cglibProxy);</span><br><span class="line"> </span><br><span class="line">        <span class="type">UserService</span> <span class="variable">o</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">        o.getName(<span class="number">1</span>);</span><br><span class="line">        o.getAge(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>++++++before CGLIB$getName$0++++++<br>getName<br>——getName——<br>++++++before CGLIB$getName$0++++++<br>++++++before CGLIB$getAge$1++++++<br>getAge<br>——getAge——</p>
<p>++++++before CGLIB$getAge$1++++++</p>
<h4 id="Spring-AOP和AspectJ-AOP有什么区别？"><a href="#Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别？"></a>Spring AOP和AspectJ AOP有什么区别？</h4><p>Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作。</p>
<p>Spring AOP已经集成了AspectJ，AsectJ应该算的上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单，如果我们的切面比较少，那么两者的性能差异不大。但是当切面太多的话，最好选择AspectJ，它比Spring AOP快很多。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012285269/article/details/122022182?spm=1001.2101.3001.6650.16&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&utm_relevant_index=18">(20条消息) 关于Jdk的Proxy与CGLib的理解_臧馆长的博客-CSDN博客_jdk proxy 和cglib</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/resentment/p/5742661.html">CGLib与JDKProxy的区别 - resentment - 博客园 (cnblogs.com)</a></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变一个算法的结构即可重定义该算法的默写特定步骤的实现方式。</p>
<p>还有很多设计模式 就不详细写了 下面解析源码的时候将设计模式和spring的加载流程串联到一起。</p>
<h1 id="Bean对象的生命周期"><a href="#Bean对象的生命周期" class="headerlink" title="Bean对象的生命周期"></a>Bean对象的生命周期</h1><p>上面我们已经提到过Bean对象的作用域了，现在我们谈一谈Bean对象从被创建到消亡的过程。（就像一个人的一生一样，更应该着重看人的一生的意义，而不是出生和死亡。）</p>
<p>该位置也是从进入容器开始实例化 到bean对象被销毁的对应位置：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI0NjUxOA==,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p>再通过调用的方法名来进行区域的划分：</p>
<img src="/2022/05/26/Spring/bean%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16537349916045.png" class="" title="bean对象生命周期">

<p>主要分为四大阶段：</p>
<ul>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ul>
<p><strong>生命周期执行的过程如下:</strong></p>
<ol>
<li>spring对bean进行实例化,默认bean是单例<strong>singleton</strong>作用域</li>
<li>spring对bean进行依赖注入</li>
<li>如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来</li>
<li>如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入</li>
<li>如果bean实现了<strong>BeanPostProcessor</strong>接口,spring将调用它们的<strong>postProcessBeforeInitialization</strong>接口方法</li>
<li>如果bean实现了<strong>InitializingBean</strong>接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了<strong>init-method属性声明了初始化方法</strong>,该方法也会被调用</li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法</li>
<li>此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁</li>
<li>若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用</li>
</ol>
<p><strong>关于initializingbean</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6964604073223913509">Spring InitializingBean 接口都不知道，源码你还是缓缓吧… - 掘金 (juejin.cn)</a></p>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>  该接口作用是<strong>在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑</strong>。注意是Bean实例化完毕后及依赖注入完成后触发的。接口的源码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="title class_">Object</span> <span class="title function_">postProcessBeforeInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">postProcessBeforeInitialization</td>
<td align="left">实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务</td>
</tr>
<tr>
<td align="left">postProcessAfterInitialization</td>
<td align="left">实例化、依赖注入、初始化完毕时执行</td>
</tr>
</tbody></table>
<p>既分为前置处理和后置处理的方法。</p>
<h3 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h3><p>spring依赖注入有三种方式</p>
<ol>
<li>set注入</li>
<li>构造器注入</li>
<li>注解@Autoware @Resource</li>
</ol>
<h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><h2 id="Spring事务分类"><a href="#Spring事务分类" class="headerlink" title="Spring事务分类"></a>Spring事务分类</h2><p><strong>编程式事务</strong>:允许用户在实现代码中使用显式的方式调用beginTransaction()开启事务、commit()提交事务、rollback()回滚事务，从而可以达到精确定义事务的边界。</p>
<p><strong>声明式事务管理</strong>:底层是建立在Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。声明式事务的最大优点就是不需要编程，将事务管理从复杂业务逻辑中抽离，只需要在配置文件中配置并在目标方法上添加 <strong>@Transactional</strong> 注解即可实现。</p>
<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是<strong>DataSource</strong>、<strong>TransactionManager</strong>和<strong>代理机制</strong>这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager,关系图如下</p>
<img src="/2022/05/26/Spring/webp.webp" class="" title="img">

<h2 id="Spring事务的传播属性"><a href="#Spring事务的传播属性" class="headerlink" title="Spring事务的传播属性"></a>Spring事务的传播属性</h2><ol>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRED)</strong></p>
<p>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)</strong></p>
<p>容器不为这个方法开启事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)</strong></p>
<p>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行旧的事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.MANDATORY)</strong></p>
<p>必须在一个已有的事务中执行,否则抛出异常</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NEVER)</strong></p>
<p>必须在一个没有的事务执行,否则抛出异常(与Propagation.MANDATORY相反)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.SUPPORTS)</strong></p>
<p>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他  bean没有声明事务,那就不用事务.</p>
</li>
</ol>
<h2 id="Spring事务注意事项"><a href="#Spring事务注意事项" class="headerlink" title="Spring事务注意事项"></a>Spring事务注意事项</h2><ol>
<li>在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。</li>
<li>@Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</li>
<li>注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。</li>
<li>通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。</li>
<li>Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</li>
<li>@Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</li>
</ol>
<h2 id="Spring事务超时时间"><a href="#Spring事务超时时间" class="headerlink" title="Spring事务超时时间"></a>Spring事务超时时间</h2><ol>
<li>TransactionDefinition 接口中定义了1个表示超时时间的常量**TIMEOUT_DEFAULT **，使用getTimeout()方法可以获取到超时时间，单位是秒。Spring事务超时时间，是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在Spring程序中超时时间设置的注解方式是设置timeout的值表示这个事务，true只读取数据但不更新数据，false表示可正常读写数据</li>
<li><strong>@Transactional(timeout&#x3D;30)</strong> 默认是-1，不超时</li>
</ol>
<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h2 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h2><img src="/2022/05/26/Spring/format,png-16599262367702.png" class="" title="format,png">

<p>循环依赖其实就是多个类（或一个类）互相拥有彼此的属性，bean加载的时候不能怎么解决如何加载他们。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A中注入了B</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// B中也注入了A</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-什么情况下循环依赖可以被处理？"><a href="#2-什么情况下循环依赖可以被处理？" class="headerlink" title="2. 什么情况下循环依赖可以被处理？"></a>2. 什么情况下循环依赖可以被处理？</h2><p>Spring解决循环依赖是有前置条件的</p>
<ol>
<li>出现循环依赖的Bean必须要是单例</li>
<li>依赖注入的方式不能全是构造器注入的方式</li>
</ol>
<p><strong>因为加入singletonFactories三级缓存的前提是执行了构造器来创建半成品的对象，所以构造器的循环依赖没法解决</strong></p>
<h2 id="3-Spring是如何解决的循环依赖？"><a href="#3-Spring是如何解决的循环依赖？" class="headerlink" title="3. Spring是如何解决的循环依赖？"></a>3. Spring是如何解决的循环依赖？</h2><p>关于循环依赖的解决方式应该要分两种情况来讨论</p>
<ol>
<li>简单的循环依赖（没有AOP）</li>
<li>结合了AOP的循环依赖</li>
</ol>
<h3 id="使用Spring的缓存"><a href="#使用Spring的缓存" class="headerlink" title="使用Spring的缓存"></a>使用Spring的缓存</h3><p>首先我们要先了解一下spring 的缓存都是什么。</p>
<p>一级缓存为单例池（<code>singletonObjects</code>）,一级缓存中存储的是已经完全创建好了的单例Bean。</p>
<p>二级缓存为早期曝光对象<code>earlySingletonObjects</code>，</p>
<p>三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）</p>
<p><img src="/spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6X3NtYWxscmVk,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6X3NtYWxscmVk,size_16,color_FFFFFF,t_70"></p>
<h3 id="Spring解决循环依赖的大致流程："><a href="#Spring解决循环依赖的大致流程：" class="headerlink" title="Spring解决循环依赖的大致流程："></a>Spring解决循环依赖的大致流程：</h3><p>这里我们假设一个场景进行讲解：ServiceA、ServiceB相互依赖。</p>
<p>Spring容器依次创建两个bean时，发现在缓存中没有ServiceA，因此将新创建好的未注入属性的ServiceA放到三级缓存中去。<br>然后ServiceA进行属性注入时，发现依赖ServiceB，转而去实例化B。<br>同样创建对象ServiceB，注入属性时发现依赖ServiceA，依次从一级到三级缓存查询ServiceA，从三级缓存通过对象工厂拿到ServiceA，把ServiceA放入二级缓存，同时删除三级缓存中的ServiceA，此时，ServiceB已经实例化并且初始化完成，把ServiceB放入一级缓存。<br>接着继续创建ServiceA，顺利从一级缓存拿到实例化且初始化完成的ServiceB对象，ServiceA对象创建也完成，删除二级缓存中的ServiceA，同时把ServiceA放入一级缓存<br>最后，一级缓存中保存着实例化、初始化都完成的ServiceA、ServiceB对象</p>
<h3 id="不结合AOP的Bean加载流程："><a href="#不结合AOP的Bean加载流程：" class="headerlink" title="不结合AOP的Bean加载流程："></a>不结合AOP的Bean加载流程：</h3><p>我们应该知道，Spring在创建Bean的过程中分为三步：</p>
<ol>
<li>实例化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>中的<code>createBeanInstance</code>方法</li>
<li>属性注入，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法</li>
<li>初始化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code></li>
</ol>
<p>我们对于getSingleton(beanName,true)的boolean变量设置为false，这样bean就不会添加到三级缓存中了。</p>
<img src="/2022/05/26/Spring/format,png-16594342853715.png" class="" title="image-20200706092738559">

<p>实际上我们要将这个bean的单例对象 放入到单例池中（singletonFactory）。<strong>也就是说如果在不考虑<code>AOP</code>的情况下，上面的代码等价于：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也就是说这个工厂啥都没干，直接将实例化阶段创建的对象返回了！所以说在不考虑<code>AOP</code>的情况下三级缓存有用嘛？讲道理，真的没什么用</strong>，我直接将这个对象放到二级缓存中不是一点问题都没有吗？</p>
<p>所以不使用AOP的时候，也不会存在三级缓存。</p>
<img src="/2022/05/26/Spring/format,png-16594339917133.png" class="" title="image-20200706133018669">

<h3 id="使用AOP的Bean加载流程："><a href="#使用AOP的Bean加载流程：" class="headerlink" title="使用AOP的Bean加载流程："></a>使用AOP的Bean加载流程：</h3><img src="/2022/05/26/Spring/format,png-16594344712637.png" class="" title="image-20200706161709829">

<ol>
<li>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</li>
</ol>
<p>答：不会，这是因为不管是<code>cglib</code>代理还是<code>jdk</code>动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p>
<ol start="2">
<li>在给B注入的时候为什么要注入一个代理对象？</li>
</ol>
<p>答：当我们对A进行了<code>AOP</code>代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p>
<ol start="3">
<li>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</li>
</ol>
<p>答：<strong>这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</strong></p>
<h2 id="为什么要使用三级缓存？二级缓存不可以吗？"><a href="#为什么要使用三级缓存？二级缓存不可以吗？" class="headerlink" title="为什么要使用三级缓存？二级缓存不可以吗？"></a>为什么要使用三级缓存？二级缓存不可以吗？</h2><p>不可以，主要是为了生成代理对象。如果使用二级缓存，<strong>会导致被暴露出去的和最终的bean不是同一个bean。</strong></p>
<p><strong>三级缓存可以验证早期暴露的bean被其他bean使用过，并且用来判断被使用的和最终暴露的不一致的问题，二级缓存做不到。二级缓存无法判断早期bean是否被使用过，早期bean若没被使用过就无需判断早期暴露的bean和最终bean是否一致的问题。</strong></p>
<h2 id="循环依赖无法解决的情况"><a href="#循环依赖无法解决的情况" class="headerlink" title="循环依赖无法解决的情况"></a>循环依赖无法解决的情况</h2><p>只有<strong>单例的bean</strong>会通过三级缓存提前暴露来解决循环依赖的问题，而<strong>非单例的bean</strong>，每次从容器中获取都是一个新的对象，都会重新创建，所以<strong>非单例的bean是没有缓存的</strong>，不会将其放到三级缓存中。</p>
<h1 id="Spring中反射的应用"><a href="#Spring中反射的应用" class="headerlink" title="Spring中反射的应用"></a>Spring中反射的应用</h1><h1 id="Spring-连环问："><a href="#Spring-连环问：" class="headerlink" title="Spring 连环问："></a>Spring 连环问：</h1><h2 id="Autoware和-Resource的区别"><a href="#Autoware和-Resource的区别" class="headerlink" title="@Autoware和@Resource的区别"></a>@Autoware和@Resource的区别</h2><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p>
<ol>
<li><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为**<code>byType</code><strong>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</strong>当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了**，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 **<code>byName</code>**（根据名称进行匹配），这个名称通常就是类名（首字母小写）。（先用类型进行匹配bytype，然后根据名字匹配byname)</p>
</li>
<li><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的实现类的话，注入方式会变为<code>byType</code>。</p>
</li>
</ol>
<p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p>
<p>巨人的肩膀：</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/5846416.html">Spring系列之beanFactory与ApplicationContext - 平凡希 - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a5acbf54b91">Spring-事务机制 - 简书 (jianshu.com)</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38246518/article/details/106131083">https://blog.csdn.net/weixin_38246518/article/details/106131083</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chao821/article/details/92400186">https://blog.csdn.net/chao821/article/details/92400186</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/139f813fca80">Spring源码(七)-IOC中的那些设计模式 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/3750725.html">spring扩展点之一：BeanFactoryPostProcessor和BeanPostProcessor - duanxz - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43973404/article/details/113094312">https://blog.csdn.net/weixin_43973404/article/details/113094312</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/heyutao007/article/details/49738887">(36条消息) Java动态代理的两种实现方法_和大黄的博客-CSDN博客_java动态代理的两种方式</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1409315#:~:text=BeanPost,ean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E5%90%8E">Spring之BeanPostProcessor(后置处理器)介绍 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>循环依赖和三级缓存：</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zz_smallred/article/details/119698804">https://blog.csdn.net/zz_smallred/article/details/119698804</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daimzh/p/13256413.html">面试必杀技，讲一讲Spring中的循环依赖 - 程序员DMZ - 博客园 (cnblogs.com)</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="多线程">
      <i class="fa fa-chevron-left"></i> 多线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/28/SpringMVC/" rel="next" title="SpringMVC">
      SpringMVC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring"><span class="nav-number">1.</span> <span class="nav-text">什么是Spring?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">Spring的核心组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%A4%A7%E8%87%B4%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">Spring大致加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">3.1.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactoryPostProcesser%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">BeanFactoryPostProcesser：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanPostProcesser%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">BeanPostProcesser：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactoryPostProcessor%E5%92%8CBeanPostProcessor"><span class="nav-number">3.4.</span> <span class="nav-text">BeanFactoryPostProcessor和BeanPostProcessor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">执行的过程如下:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%B5%85%E7%9C%8B"><span class="nav-number">4.</span> <span class="nav-text">Spring浅看</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringIOC-%E5%92%8C-Spring-AOP"><span class="nav-number">5.</span> <span class="nav-text">SpringIOC 和 Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringIOC"><span class="nav-number">5.1.</span> <span class="nav-text">SpringIOC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringAOP"><span class="nav-number">5.2.</span> <span class="nav-text">SpringAOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%B8%ADbeanFactory%E5%92%8CApplicationContext%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">Spring中beanFactory和ApplicationContext的联系和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">Spring用到的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.1.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.4.1.0.1.</span> <span class="nav-text">设置延迟加载的方式：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.2.</span> <span class="nav-text">单例设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.4.2.0.1.</span> <span class="nav-text">Bean对象的作用域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.3.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.4.</span> <span class="nav-text">装饰器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.5.</span> <span class="nav-text">代理设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.4.5.1.</span> <span class="nav-text">Spring AOP 和 AspectJ AOP 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">5.4.5.2.</span> <span class="nav-text">JDK动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGlib"><span class="nav-number">5.4.5.3.</span> <span class="nav-text">CGlib</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-AOP%E5%92%8CAspectJ-AOP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.4.5.4.</span> <span class="nav-text">Spring AOP和AspectJ AOP有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.6.</span> <span class="nav-text">模板方法设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.</span> <span class="nav-text">Bean对象的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanPostProcessor"><span class="nav-number">6.1.</span> <span class="nav-text">BeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">6.1.1.</span> <span class="nav-text">Spring依赖注入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">Spring事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%88%86%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">Spring事务分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7"><span class="nav-number">7.2.</span> <span class="nav-text">Spring事务的传播属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.3.</span> <span class="nav-text">Spring事务注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-number">7.4.</span> <span class="nav-text">Spring事务超时时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">8.</span> <span class="nav-text">Spring循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">1. 什么是循环依赖？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">2. 什么情况下循环依赖可以被处理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">3. Spring是如何解决的循环依赖？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">8.3.1.</span> <span class="nav-text">使用Spring的缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">8.3.2.</span> <span class="nav-text">Spring解决循环依赖的大致流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%BB%93%E5%90%88AOP%E7%9A%84Bean%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">8.3.3.</span> <span class="nav-text">不结合AOP的Bean加载流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AOP%E7%9A%84Bean%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">8.3.4.</span> <span class="nav-text">使用AOP的Bean加载流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-number">8.4.</span> <span class="nav-text">为什么要使用三级缓存？二级缓存不可以吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">8.5.</span> <span class="nav-text">循环依赖无法解决的情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">Spring中反射的应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E8%BF%9E%E7%8E%AF%E9%97%AE%EF%BC%9A"><span class="nav-number">10.</span> <span class="nav-text">Spring 连环问：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Autoware%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.1.</span> <span class="nav-text">@Autoware和@Resource的区别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zh-CN</p>
  <div class="site-description" itemprop="description">The Blog Which Owned Shuaiqiwudi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zh-CN</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">207k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">3:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'hV6HQva8xks9UIucjaqQJ5uK-gzGzoHsz',
      appKey     : 'cDwVC10P19xDSP3q0QVRoFif',
      placeholder: "期待您的精彩评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
