<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-nextwechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络因特网是一个世界范围的计算机网络，是一个互联了遍及全世界数十亿计算设备的网络。 我们通常理解为 计算机主机和端系统代指相同的东西。端系统通过通信链路和分组交换机连接到一起。通信链路通常由物理媒体构成。不同的链路能够以不同的速率传输数据，链路的传输速率为比特&#x2F;秒（bit&#x2F;s）度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，这样形">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="shuaiqiwudi blog">
<meta property="og:description" content="计算机网络因特网是一个世界范围的计算机网络，是一个互联了遍及全世界数十亿计算设备的网络。 我们通常理解为 计算机主机和端系统代指相同的东西。端系统通过通信链路和分组交换机连接到一起。通信链路通常由物理媒体构成。不同的链路能够以不同的速率传输数据，链路的传输速率为比特&#x2F;秒（bit&#x2F;s）度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，这样形">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220830145042545.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831124803715.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831133536281.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901090110660.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804142611346-16595943730113.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70-16612297906722.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804152634329-16595979954344.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-3fff05a4c9cc787c8c0abaf2e7d20097_720w.jpg">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612303375515.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612305786968.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831135244309.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-bef9ba3e565d2e170260b75b2b94c161_r.jpg">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509224724959.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-3c1a52d9036fd7bbb3e060125c6bf1a8_r.jpg">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/webp.webp">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509211948316.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220823132947904.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-2f86d3626184a4fc8b8fed6008419055_720w.jpg">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901100646399.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901105811202.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901110057993.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612429750222.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-02.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190531105135488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-05-16613875284723.gif">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190531151613730.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612438854245.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612439966847.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9556fa61ac7262a18bc639db29362669_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-1ea0209a526f3527a713736fe7609fcf_720w.jpg">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202849848.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202950751.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190402234727661.png">
<meta property="og:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190402234453381.png">
<meta property="article:published_time" content="2022-08-04T06:02:31.000Z">
<meta property="article:modified_time" content="2022-09-01T03:22:07.675Z">
<meta property="article:author" content="zh-CN">
<meta property="article:tag" content="zsr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220830145042545.png">

<link rel="canonical" href="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机网络 | shuaiqiwudi blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shuaiqiwudi blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zh-CN">
      <meta itemprop="description" content="The Blog Which Owned Shuaiqiwudi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuaiqiwudi blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-04 14:02:31" itemprop="dateCreated datePublished" datetime="2022-08-04T14:02:31+08:00">2022-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-01 11:22:07" itemprop="dateModified" datetime="2022-09-01T11:22:07+08:00">2022-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>因特网是一个世界范围的计算机网络，是一个互联了遍及全世界数十亿计算设备的网络。</p>
<p>我们通常理解为 计算机主机和端系统代指相同的东西。端系统通过通信链路和分组交换机连接到一起。通信链路通常由物理媒体构成。不同的链路能够以不同的速率传输数据，链路的传输速率为比特&#x2F;秒（bit&#x2F;s）度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，这样形成的信息在计算机网络中称为<strong>分组</strong>。</p>
<p>端系统通过因特网服务提供商（<strong>ISP</strong>）接入互联网。</p>
<span id="more"></span>

<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>端系统，分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP（传输控制协议）和IP（网际协议）是因特网中最为重要的两个协议。<strong>因特网的主要协议统称为TCP&#x2F;IP</strong>。</p>
<p>人类活动在计算机网络协议中的类比：</p>
<p>（我更喜欢这个例子）假如你正在大学课堂听课，任课老师正在孜(lao)孜(lao)不(dao)倦(dao) 地讲述计算机网络协议，而你却疑惑不解，这名教师停下问：“同学们有什么问题吗？”（教师发出了一个报文，该报文没有被所有没有睡觉的学生接收到。）你举起了手（向教师发出了一个隐含的报文）。这名教师面带微笑地示意你说：“请讲……”(教师发出的这个报文表示他看到你举手想要提出问题)。接着你就问了问题（向该教师传输了你的报文）。这就是一个连接建立的过程。</p>
<p><strong>协议</strong>定义了在两个或多个通信通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作。</p>
<p>主机&#x3D;端系统</p>
<p>主机又分为客户端和服务器。 </p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220830145042545.png" class="" title="image-20220830145042545">

<h2 id="网路核心："><a href="#网路核心：" class="headerlink" title="网路核心："></a>网路核心：</h2><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中，端系统彼此交换报文，报文能够包含协议设计者需要的任何东西。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为<strong>分组</strong>。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要分为两类：路由器和链路层交换机）<strong>分组以等于在该链路最大传输速率的速度传输通过通信链路。</strong></p>
<p><strong>存储转发传输</strong></p>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>机制。该机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p>路由器在转发前需要接受，存储和处理整个分组。</p>
<h3 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h3><p>每台分组交换机由多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（输出队列），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该分组必须在输出缓存中等待。因此 除了存储转发时延以外，分组还要承受输出缓存的排队时延。</p>
<p>因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在这种情况下，将出现分组丢失（丢包）到达的分组或已经排队的分组之一将被丢弃。</p>
<h3 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h3><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等物理介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p>
<p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong></p>
<p>在电路交换网络中，端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源，但是在分组交换网络中，这些资源是不预留的。</p>
<p>&#x2F;&#x2F;TODO 电路交换的具体实现</p>
<p>二者对比：</p>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="分组交换中的时延，丢包和吞吐量"><a href="#分组交换中的时延，丢包和吞吐量" class="headerlink" title="分组交换中的时延，丢包和吞吐量"></a>分组交换中的时延，丢包和吞吐量</h2><p>因为在理想状态下，我们可以随心所欲的在端到端进行数据的传输。可现实中，计算机网络必定要限制在端系统之间的吞吐量（每秒能够传输的数据量），在端系统之间引入时延的概念，并且实际上也会丢失分组。</p>
<h3 id="节点时延"><a href="#节点时延" class="headerlink" title="节点时延"></a>节点时延</h3><p>分组从一台主机出发，通过一系列路由器传输，在另一条主机中结束他的历程。当分组从一个节点（主机或路由器）沿着这条路径到后继结点（主机或路由器），该分组在沿途的每个节点经受了几种不同类型的时延。这些时延最为重要的是节点处理时延（nodlal processing delay）、排队时延（queuing delay）、传输时延（transmission delay）和传播时延（propagation delay），这些时延总体累加起来是<strong>节点总时延</strong>（total nodal delay）。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831124803715.png" class="" title="image-20220831124803715">

<h4 id="1-处理时延"><a href="#1-处理时延" class="headerlink" title="1. 处理时延"></a>1. 处理时延</h4><p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。</p>
<p>处理时延也能够包括其他因素，如检查比特级别的差错所需要的时间，该差错出现在从上游节点向路由器 传输这些分组比特的过程中 高速路由器的处理时延通常是微秒或更低的数量在这种节点处理之后，路由器将该分组引向通往路由器 链路之前的队列。</p>
<h4 id="2-排队时延"><a href="#2-排队时延" class="headerlink" title="2. 排队时延"></a>2. 排队时延</h4><p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。实际的排队时延可以是毫秒到微秒量级。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831133536281.png" class="" title="image-20220831133536281">

<p> 节点时延的最为复杂和有趣的成分是排队时延。什么时候排队时延大，什么时候又不大呢?该问题的答案很大程度取决于流量到达该队列的速率、链路的传输速率和到达流量的性质，即流量是<ins>  周期性到达  还是  突发形式到达 </ins>。为了更深入地领会某些要点，令<strong>a</strong>表示分组到达队列的<strong>平均速率</strong>（a的单位是分组&#x2F;秒，即pkt&#x2F;s）。<strong>R</strong>是<strong>传输速率</strong>，即从队列中推出比特的速率（以bps即b&#x2F;s为单位）。为了简单起见，也假定所有分组都是由L比特组成的。则比特到达队列的<strong>平均速率是La bps</strong>。最后，假定该队列非常大，因此它基本能容纳无限数量的比特。<strong>比率La&#x2F;R被称为流量强度</strong>（traffic intensity），它在估计排队时延的范围方面经常起着重要的作用。如果La&#x2F;R&gt;1，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大!因此,<strong>设计系统时流量强度不能大于1。</strong></p>
<p>现在考虑La&#x2F;R≤1时的情况。这时，到达流量的性质影响排队时延。例如，如果分组周期性到达，即每L&#x2F;R秒到达一个分组，则每个分组将到达一个空队列中，不会有排队时延。另一方面，如果分组以突发形式到达而不是周期性到达，则可能会有很大的平均排队时延。例如，假定每（L&#x2F;R）N秒同时到达N个分组。则传输的第一个分组没有排队时延；传输的第二个分组就有L&#x2F;R秒的排队时延；更为一般地，第n个传输的分组具有（n-1）L&#x2F;R秒的排队时延。</p>
<p>图1-18的一个重要方面是这样一个事实∶随着流量强度接近于1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加。</p>
<h5 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h5><p>在现实中,一条链路前的队列只有有限的容量,尽管排队容量极大地依赖于路由器设计和成本.因为该排队容量是有限的,随着流量强度接近1,排队时延并不真正趋向无穷大。相反，<ins>到达的分组将发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃(drop)该分组。</ins> 即该分组将<strong>会丢失</strong>(lost).当流量强度大于1时,队列中的这种溢出。</p>
<p>从端系统的角度看,上述丢包现象看起来是一个分组已经传输到网络核心,但它绝不会从网络发送到目的地.分组丢失的比例随着流量强度增加而增加。因此,<ins>一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量</ins>。丢失的分组可能基于端到端的原则重传,以确保所有的数据最终从源传送到了目的地。</p>
<h4 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3.传输时延"></a>3.传输时延</h4><p>假定分组以先到先服务方式传输————这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用<strong>L</strong>比特表示该分组的长度，用<strong>R</strong> bps （即b&#x2F;s）表示从路由器A到路由器B的链路传输速率。例如，对于一条10Mbps的以太网链路，速率R&#x3D;10Mbps；对于100Mbps的以太网链路，速率R&#x3D;100Mbps。<strong>传输时延是L&#x2F;R</strong>。这是将所有分组的比特推向链路（即传输，或者说发射）所需要的时间。实际的传输时延通常在毫秒到微秒量级。</p>
<h4 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4. 传播时延"></a>4. 传播时延</h4><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B 传播所需要的时间是传播时延。该比特以该链路的传播速率传播。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是d&#x2F;s，其中d是路由器A和路由器B之间的距离，s是该链路的传播速率。一旦该分组的最后一个比特传播到节点B，该比特及前面的所有比特被存储于路由器B。整个过程将随着路由器B 执行转发而持续下去。在广域网中，传播时延为毫秒量级。</p>
<h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><p>我们计算了一个点（路由器）的时延，接下来我们计算一下从源到目的地的总时延。<ins>假设该网络此时是无拥塞的（因此排队时延可以忽略不计）</ins>，在每台路由器和源主机上的处理时延是d（proc） 每台路由器和源主机的输出速率是 R bps，d（trans）&#x3D; L &#x2F; R ，L为分组长度，每条链路的传播时延是d（prop），累加起来即可得到端到端时延。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901090110660.png" class="" title="image-20220901090110660">

<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804142611346-16595943730113.png" class="" title="image-20220804142611346">



<p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。国际标准化组织 ISO 于1977年提 出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI&#x2F;RM，简称为OSI，但它既复杂又不实用</p>
<p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则， 比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<p>本文针对<strong>TCP&#x2F;IP</strong> <strong>四层</strong>体系结构进行解析：</p>
<h2 id="网络数据封装过程"><a href="#网络数据封装过程" class="headerlink" title="网络数据封装过程"></a>网络数据封装过程</h2><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70.png" class="" title="img">

<p>应用层产生的数据叫上层数据，往下走，在传输层加上TCP头部，打包后在网络层再加上IP头部，打包后在数据链路层再加上MAC头部，打包后在物理层封装成信号发出去。传输到了目标主机，目标主机通过网口接收到信号，再进行解封装，一步一步的去掉相应的头部，最后得到上层数据即有效的数据。</p>
<p>发送方完成封装过程，接收方完成解封装过程</p>
<h2 id="数据解封装过程："><a href="#数据解封装过程：" class="headerlink" title="数据解封装过程："></a>数据解封装过程：<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTM1NDg3,size_16,color_FFFFFF,t_70-16612297906722.png" class="" title="img"></h2><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428372105">应用层协议详解 - 知乎 (zhihu.com)</a></p>
<p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应 用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和 交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域 名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等 等。</p>
<p>在 TCP&#x2F;IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了<strong>管理通信连接</strong>的会话层功能、<strong>数据格式转换</strong>的表示层功能，还包括<strong>主机间交互</strong>的应用层功能。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220804152634329-16595979954344.png" class="" title="image-20220804152634329">



<p>TCP&#x2F;IP 模型中应用层位于传输层之上，<strong>传输层的端口号用于标识数据所对应的应用层协议</strong>。也就是说，有端口号的协议都是<strong>应用层协议</strong>。应用协议是终端设备之间的应用通信规则。应用之间交互的信息叫<strong>消息</strong>，应用协议定义这些消息的格式以及消息的控制或操作的规则。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3fff05a4c9cc787c8c0abaf2e7d20097_720w.jpg" alt="img"></p>
<h2 id="应用协议的通信方式"><a href="#应用协议的通信方式" class="headerlink" title="应用协议的通信方式"></a>应用协议的通信方式</h2><p>应用程序所使用的主流体系结构可分为两类：</p>
<ul>
<li><p>服务器和客户端模型</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620.png" class="" title="img">
</li>
<li><p>P2P 模型</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612303375515.png" class="" title="img"></li>
</ul>
<p>在<strong>服务器和客户端模型</strong>中，始终公开固定 IP 地址的主机为其它主机的应用程序提供服务，请求服务的主机之间不会互相通信。这些为其它主机提供服务的终端设备称为<strong>服务器</strong>，那些请求服务的主机则称为<strong>客户端</strong>。大多数应用层协议，都是这种模型。</p>
<p>在 <strong>P2P 模型</strong>中，没有特定的服务器或客户端，这些设备上安装的应用程序，可以在主机间建立对等连接，既可以提供服务，也可以接受服务。通常是大流量的应用程序采用 P2P 模型，比如：下载器等。</p>
<p>两种方式的对比：</p>
<h3 id="Client和Server模式"><a href="#Client和Server模式" class="headerlink" title="Client和Server模式"></a>Client和Server模式</h3><ol>
<li><p>服务器主机是总是打开的， 客户机主机则并不总是打开</p>
</li>
<li><p>服务器是处理所有逻辑的中心</p>
</li>
<li><p>基于2的原因，两个客户机一般是不能直接通信的， 要进行通信必须经过服务器</p>
</li>
<li><p>虽然客户机&#x2F;服务器体系结构的特征是“一对多”，但是服务器却并不总是一台，因为有的时候要处理海量的客户机的请求， 一台服务器很快就会不堪重负，所以这个时候常用服务器集群技术（server clustering）创建强大的虚拟服务器。所以这里“一对多”的一要理解为一组服务器组成的“一”个整体的意思。</p>
</li>
<li><p>由于4的原因，客户机&#x2F;服务器体系的应用服务通常是基础设施密集的（infrastructure intensive）,也就是说，提供该服务的互联网商家，例如搜索引擎（百度），网络商务（淘宝）通常要为服务器场的购买，安装和维护投入巨额的费用。</p>
</li>
</ol>
<h3 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1620-16612305786968.png" class="" title="img">

<ol>
<li><p>客户机间的直接通信使得P2P有了强大的自扩展性（self-calability），什么意思呢？ 假设上面这幅图是一个发送文件（上载&#x2F;下载）文件的过程，我们可以看到，从上至下，接收文件的主机的数量是指数递增的，系统的服务能力在逐渐增强，而且越来越强。</p>
</li>
<li><p>P2P体系结构对基础设施服务器有最小的依赖， 这是和基础设施密集的客户机&#x2F;服务器体系结构是截然相反的。</p>
</li>
</ol>
<h2 id="进程通信（套接字，端口号）"><a href="#进程通信（套接字，端口号）" class="headerlink" title="进程通信（套接字，端口号）"></a>进程通信（套接字，端口号）</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信的情况有一个基本了解。用操作系统的术语来说，进行通信的实际上是<strong>进程</strong>（process）而不是程序。当多个进程xxxxxxxxxxxxxxxxxxx运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220831135244309.png" class="" title="image-20220831135244309">

<p>进程于计算机网络之间的接口：进程通过一个称为<strong>套接字</strong>（sock-et）的软件接口向网络发送报文和从网络接收报文。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（Application Programming Interface，<strong>API</strong>）。</p>
<p>除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字）。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地<strong>端口号</strong>（port number）用于这个目的。</p>
<h2 id="应用层和运输层的工作衔接"><a href="#应用层和运输层的工作衔接" class="headerlink" title="应用层和运输层的工作衔接"></a>应用层和运输层的工作衔接</h2><p>运输层提供了不止一种运输层协议。当开发一个应用时，应该选择一种合适的运输层协议，如果做出这种选择呢？我么应该研究这些可用的运输层协议所提供的服务。</p>
<ol>
<li>可靠数据传输</li>
</ol>
<p>这种服务确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。</p>
<ol start="2">
<li>吞吐量</li>
</ol>
<p>运输层协议能够以某种特定的速率提供确保的可用吞吐量。具有<strong>吞吐量要求的应用程序</strong>被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application）。许多当前的多媒体应用是带宽敏感的，尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求，而弹性应用（elastic application）能够根据当时可用的带宽或多或少地利用可供使用的吞吐量。电子邮件、文件传输以及Web传送都属于弹性应用。</p>
<ol start="3">
<li>定时</li>
</ol>
<p>运输层协议也能提供定时保证。定时保证能够以多种形式实现，一个保证的例子如∶发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。这种服务将对交互式实时应用程序有吸引力。</p>
<ol start="4">
<li>安全性</li>
</ol>
<p>最后，运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。 </p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p><strong>应用程序</strong>有很多，包括 Web 浏览器、电子邮件、远程登录、文件传输、网络管理等。这些应用程序都会使用应用协议进行通信，应用协议正是为了实现应用程序的功能而设计和创造的。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-bef9ba3e565d2e170260b75b2b94c161_r.jpg" class="" title="preview">

<h3 id="1-远程登陆"><a href="#1-远程登陆" class="headerlink" title="1. 远程登陆"></a>1. 远程登陆</h3><h3 id="8-Http协议"><a href="#8-Http协议" class="headerlink" title="8.Http协议"></a>8.Http协议</h3><p>应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP），HTTP使用TCP作为它的支撑运输协议。</p>
<p>当用户在浏览器的地址栏里输入 Web 页的 URL 后，HTTP 的处理就开始了。<strong>HTTP</strong> 默认使用 80 端口。它的工作机制，<em>首先是客户端向服务器的 80 端口建立一个 TCP 连接，然后在这个 TCP 连接上进行请求和应答以及数据报文的发送。</em></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509224724959.png" class="" title="img">

<p>HTTP 中常用的有两个版本，一个是 <strong>HTTP 1.0</strong> ，另一个是 <strong>HTTP 1.1</strong> 。在HTTP 1.0 中每一个命令和应答都会触发一次 TCP 连接的建立和断开，非持续连接有一些缺点。第一，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，第二，，每一个对象经受两倍RTT（往返时间）的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。而从 HTTP 1.1 开始，允许在一个 TCP 连接上发送多个命令和应答，这种方式也叫<strong>持续连接</strong>（ keep-alive ）。可以大量减少 TCP 连接的建立和断开操作，提高传输效率。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-3c1a52d9036fd7bbb3e060125c6bf1a8_r.jpg" class="" title="preview">

<p>详解 Connection：</p>
<p>HTTP 是应用层协议，HTTP 用的是下层的 TCP协议，而 TCP 是保证可靠性的。<br>TCP 为了保证可靠性，所以 TCP 是面向连接的。<br>TCP 面向连接之前必须先建立连接——&gt; HTTP 向通信就要在底层先把连接建立好。然后，发送方根据已经建立好的连接向服务器发送一个请求。<br>发过去之后对方就可以根据这个完整地读出来，对方再分析这个报文，然后对这个报文做出响应，HTTP 请求结束，之后断开连接。<br>这种一来一回的形式成为短连接（一次请求一个）</p>
<h4 id="Http数据格式解析"><a href="#Http数据格式解析" class="headerlink" title="Http数据格式解析"></a>Http数据格式解析</h4><h5 id="HTTP请求报文格式"><a href="#HTTP请求报文格式" class="headerlink" title="HTTP请求报文格式"></a>HTTP请求报文格式</h5><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/webp.webp" class="" title="img">

<p><strong>请求方法：</strong></p>
<p><strong>【GET：获取资源】</strong><br>   GET方法用来请求已被URI识别的资源。指定的资源经服务器端解析后返回响应内容（也就是说，如果请求的资源是文本，那就保持原样返回；如果是CGI[通用网关接口]那样的程序，则返回经过执行后的输出结果）。</p>
<p><strong>【POST：传输实体文本】</strong><br>   POST方法用来传输实体的主体。<br>   虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法；虽然GET方法和POST方法很相似，但是POST的主要目的并不是获取响应的主体内容。</p>
<blockquote>
<p><strong>GET 方法和 POST 方法核心点：</strong></p>
<ol>
<li>传参的数据量不一样，一个通过 url，一个通过正文，所以 POST 能传更多的数据；</li>
<li>GET 方法和 POST 方法传参位置上，可靠性问题。</li>
</ol>
</blockquote>
<p><strong>【HEAD：获得报文首部】</strong><br>   HEAD方法和GET方法一样，只是不返回报文的主体部分，用于确认URI的有效性及资源更新的日期时间等。<br>   具体来说：1、判断类型； 2、查看响应中的状态码，看对象是否存在（响应：请求执行成功了，但无数据返回）； 3、测试资源是否被修改过<br>   HEAD方法和GET方法的区别： GET方法有实体，HEAD方法无实体。<br><strong>【PUT：传输文件】</strong></p>
<p><strong>【DELETE：删除文件】</strong></p>
<p><strong>【OPTIONS：询问支持的方法】</strong></p>
<p><strong>【TRACE：追踪路径】</strong></p>
<p><strong>【CONNECT：要求用隧道协议连接代理】</strong></p>
<p><strong>请求行：</strong></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190509211948316.png" class="" title="在这里插入图片描述">

<p><strong>整体格式(请求格式：</strong></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220823132947904.png" class="" title="image-20220823132947904">

<p>(HTTP响应的格式与请求的格式十分类似,在响应中”唯一”真正的区别在于第一行中用状态行代替了请求行)</p>
<h5 id="HTTP响应报文格式"><a href="#HTTP响应报文格式" class="headerlink" title="HTTP响应报文格式"></a>HTTP响应报文格式</h5><p>HTTP响应也由3个部分构成，分别是：</p>
<ol>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ol>
<p>在接收和解释请求消息后，服务器会返回一个HTTP响应消息。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2f86d3626184a4fc8b8fed6008419055_720w.jpg" alt="img"></p>
<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>格式: <code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br>例如: <code>HTTP/1.1 200 OK \r\n</code></p>
<h3 id="HTTP-cookie"><a href="#HTTP-cookie" class="headerlink" title="HTTP cookie"></a>HTTP cookie</h3><p>假设 Susan在上网 ，她首次与Amazon.com联系，假定过去她已经访问过eBay站点。当请求报文到达该Amazon Web服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来Amazon Web服务器用一个包含 Set-cookie∶首部的<strong>HTTP响应报文</strong>对Susan的浏览器进行响应，其中Set-cookie∶首部含有该识别码。例如，该首部行可能是</p>
<p>Set-cookie: 1678</p>
<p>当 Susan 的浏览器收到了该HTTP响应报文时，它会看到该 Set-cookie∶首部。<strong>该浏览器在它管理的特定cookie文件中添加一行</strong>，该行包含服务器的主机名和在Set-cookie∶首部中的识别码。值得注意的是该cookie文件已经有了用于eBay的表项，因为Susan过去访问过该站点。当Susan继续浏览Amazon网站时，每请求一个Web页面，其浏览器就会<strong>查询该cookie 文件并抽取她对这个网站的识别码</strong>，<strong>并放到HTTP请求报文中包括识别码的cookie首部行中</strong>，特别是，发往该 Amazon 服务器的每个 HTTP 请求报文都包括以下首部行：</p>
<p>Cookie : 1678 </p>
<p>如果Susan再次访问Amazon站点，比如说一个星期后，她的浏览器会在其请求报文中继续放入首部行cookie∶1678。Amazon将根据Susan过去在Amazon访问的网页向她推荐产品。如果 Susan也在 Amazon 注册过，即提供了她的全名、电子邮件地址、邮政地址和信用卡账号，则 Amazon能在其数据库中包括这些信息，将 Susan 的名字与识别码相关联（以及她在过去访问过的本站点的所有页面）。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901100646399.png" class="" title="image-20220901100646399">

<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web 缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实</p>
<p>体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。如图2-11所示，可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该</p>
<p>Web缓存器。举例来说，假设浏览器正在请求对象 <a target="_blank" rel="noopener" href="http://www.someschool.edu/campus.gif">http://www.someschool.edu/campus.gif</a> ，将会发生如下情况∶</p>
<p>1）浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</p>
<p>2）Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</p>
<p>3）如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器（即<a target="_blank" rel="noopener" href="http://www.someschool.edu)的tcp连接.web缓存器则在这个缓存器到服务器的tcp连接上发送一个对该对象的http请求.在收到该请求后,初始服务器向该web缓存器发送具有该对象的http响应./">www.someschool.edu）的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</a></p>
<p>4）当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）。</p>
<p><strong>值得注意的是Web缓存器既是服务器又是客户。</strong></p>
<p>在因特网上部署Web缓存器有两个原因。首先，<strong>Web缓存器可以大大减少对客户请求的响应时间</strong>，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接（情况常常如此）。其次，如我们马上用例子说明的那样，<strong>Web缓存器能够大大减少一个机构的接入链路到因特网的通信量</strong>。通过减少通信量，该机构（如一家公司或者一所大学）就<ins>不必急于增加带宽</ins>，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的Web。</p>
<p><strong>条件GET方法：</strong></p>
<p>尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即<ins>保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了</ins>。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是<strong>条件GET</strong>（conditional GET）方法。如果∶①请求报文使用GET 方法并且②请求报文中包含一个”If-Modified-Since∶”首部行。那么，这个HTTP请求报文就是一个条件GET请求报文。</p>
<p>具体过程：</p>
<p>首先代理服务器访问服务器，服务器响应的报文存在Last-Modified: ，以用来表示缓存服务器最新的访问时间，当客户端请求的时候，缓存服务器访问服务器，并发送以下请求报文：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901105811202.png" class="" title="image-20220901105811202">

<p>If-modified-since即缓存服务器的资源 该条件 GET 报文告诉服务器，仅当自指定日期之后该对象被修改过，服务器才发送该对象。</p>
<p>接着服务器查看对应资源，如果If-modified-since后资源没有修改，则返回响应报文：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220901110057993.png" class="" title="image-20220901110057993">

<p>这样做并没有在该响应报文中包含所请求的对象，包含该对象只会浪费带宽，并增加用户感受到的响应时间，特别是如果该对象很大的时候更是如此。</p>
<h3 id="HTTP的不同版本"><a href="#HTTP的不同版本" class="headerlink" title="HTTP的不同版本"></a>HTTP的不同版本</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinlidong77/article/details/103908035">(48条消息) HTTP1.0和HTTP2.0的区别_丶懿的博客-CSDN博客_http1.0和http2.0的区别</a></p>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html">HTTP 与 HTTPS 的区别 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428372105">应用层协议详解 - 知乎 (zhihu.com)</a></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS实际上也是应用层协议，因为是端到端之间的通信，并且由运输层来传送DNS的报文信息。</p>
<p>关于DNS的工作流程：[详见url的请求过程](# 2. 一个URL的执行过程)</p>
<p>&#x2F;&#x2F;TODO DNS的报文内容 P90</p>
<h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p>&#x2F;&#x2F;TODO 关于视频在网络的传输 P97</p>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>运输层为它上面的应用层提供通信服务。<br>在OSI七层参考模型中，运输层是面向通信的最高层，也是用户功能的最底层。<br>传输层两大重要的功能：复用 和 分用。<br>1.复用：在发送端，多个应用进程公用一个传输层；<br>2.分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。<br>和网络层的区别：<br>1.网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。<br>2.网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>UDP</strong></th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>有连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用 流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对 一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8个字节</td>
<td>首部小：20字节， 大：60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用 （IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>UDP只在IP数据报服务的基础上增加了少量的功能：复用与分用、对整个报文的差错检测。<br>1.UDP是无连接的<br>通信前不需要建立连接，通信结束也无需释放连接。<br>2.UDP是不可靠的<br>它是尽最大努力交付，不能确保每一个数据报都送达。<br>3.UDP是面向报文的<br>所谓 面向报文 就是指：UDP数据传输的单位是报文，且不会对数据作任何 拆分 和 拼接 操作。在发送端，应用程序给传输层的UDP什么样的数据，UDP不会对数据进行切分，只增加一个UDP头并交给网络层。在接收端，UDP收到网络层的数据报后，去除IP数据报头部后遍交给应用层，不会作任何拼接操作。<br>4.<strong>UDP没有拥塞控制</strong><br>UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。<br>弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。<br>优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<ul>
<li><strong>源端口</strong>：源端口号。在需要对方回信时选用。不需要时可用全0。</li>
<li><strong>目的端口</strong>：目的端口号。这在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>： UDP用户数据报的长度，其最小值是8（仅有首部）。</li>
<li><strong>校验和</strong>：检测UDP用户数据报在传输中是否有错。有错就丢弃。</li>
</ul>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612429750222.png" class="" title="img">

<p><strong>伪首部</strong><br>在 TCP 的分段或 UDP 的数据报格式中，在数据报首部前面增加源 IP 地址、目的 IP 地址、IP 分组的协议字段、TCP 或 UDP 数据报的总长度等共12字节，所构成的扩展首部结构。此伪首部是一个临时的结构，它既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-02.gif" class="" title="img">



<h2 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h2><p>TCP最主要的特点</p>
<ol>
<li><p><strong>TCP是面向连接的</strong></p>
<p>通信前需要建立连接，通信结束需要释放连接。每一条TCP连接只能有两个端点,TCP只能提供点到点的通信，而UDP可以任意方式的通信。</p>
</li>
<li><p><strong>TCP提供可靠交付的服务</strong></p>
<p>可靠指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。(对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号)</p>
</li>
<li><p><strong>TCP提供全双工通信</strong><br>全双工通信指的是：TCP的两端既可以作为发送端，也可以作为接收端。</p>
</li>
<li><p><strong>TCP是面向字节流的</strong><br>面向字节流指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报 ，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</p>
</li>
<li><p><strong>TCP的连接</strong><br>TCP连接就是由协议软件所提供的一种抽象。表示一条可通信的链路。每条TCP连接有且仅有两个端点，表示通信的双方。且双发在任意时刻都可以作为发送者和接收者。<br>TCP连接的端点叫做套接字或插口。<br>套接字 socket &#x3D;（IP地址:端口号）。<br>因此，TCP连接 ::&#x3D;（套接字1，套接字2）&#x3D;{(IP1:端口号1)，(IP2:端口号2)}</p>
</li>
</ol>
<h4 id="TCP报文段首部"><a href="#TCP报文段首部" class="headerlink" title="TCP报文段首部"></a>TCP报文段首部</h4><p><img src="https://img-blog.csdnimg.cn/20190531105135488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2019-03-21-05-16613875284723.gif" class="" title="img">

<h4 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h4><p>TCP的可靠性表现在：它向应用层提供的数据是 无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一模一样的。</p>
<p>TCP采用了流量控制、拥塞控制、连续ARQ等技术来保证它的可靠性。</p>
<p>当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来是不可靠的传输信道就能够实现可靠传输了。</p>
<h4 id="1-停止等待协议-ARQ协议"><a href="#1-停止等待协议-ARQ协议" class="headerlink" title="1.停止等待协议(ARQ协议)"></a>1.停止等待协议(ARQ协议)</h4><p>TCP保证其可靠性采用的是更为复杂的滑动窗口协议，但停止等待协议是它的简化版，为了方便理解，这里先介绍停止等待协议。<br>AQR协议</p>
<p>ARQ(Automatic Repeat reQuest)自动重传请求。<br>顾名思义，当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。停止等待协议是一种ARQ协议。</p>
<p><strong>停止等待协议的原理</strong></p>
<ol>
<li><p>无差错的情况<br>A向B每发送一个分组，都要停止发送，等待B的确认应答；A只有收到了B的确认应答后才能发送下一个分组。</p>
</li>
<li><p>分组丢失和出现差错的情况<br>发送者拥有超时计时器。每发送一个分组便会启动超时计时器，等待B的应答。若超时仍未收到应答，则A会重发刚才的分组。</p>
<p>分组出现差错：若B收到分组，但通过检查和字段发现分组在运输途中出现差错，它会直接丢弃该分组，并且不会有任何其他动作。A超时后便会重新发送该分组，直到B正确接收为止。</p>
<p>分组丢失：若分组在途中丢失，B并没有收到分组，因此也不会有任何响应。当A超时后也会重传分组，直到正确接收该分组的应答为止。<br>综上所述：当分组丢失 或 出现差错 的情况下，A都会超时重传分组。</p>
</li>
<li><p>应答丢失 和 确认迟到 的情况<br>TCP会给每个字节都打上序号，用于判断该分组是否已经接收。</p>
<p>应答丢失：若B正确收到分组，并已经返回应答，但应答在返回途中丢失了。此时A也收不到应答，从而超时重传。紧接着B又收到了该分组。接收者根据序号来判断当前收到的分组是否已经接收，若已接收则直接丢弃，并补上一个确认应答。</p>
<p>确认迟到：若由于网络拥塞，A迟迟收不到B发送的应答，因此会超时重传。B收到该分组后，发现已经接收，便丢弃该分组，并向A补上确认应答。A收到应答后便继续发送下一个分组。但经过了很长时间后，那个失效的应答最终抵达了A，此时A可根据序号判断该分组已经接收，此时只需简单丢弃即可。</p>
</li>
</ol>
<blockquote>
<p>停止等待协议的注意点</p>
<p>每发送完一个分组，该分组必须被保留，直到收到确认应答为止。<br>必须给每个分组进行编号。以便按序接收，并判断该分组是否已被接收。<br>必须设置超时计时器。每发送一个分组就要启动计时器，超时就要重发分组。<br>计时器的超时时间要大于应答的平均返回时间，否则会出现很多不必要的重传，降低传输效率。但超时时间也不能太长。</p>
</blockquote>
<h4 id="2-滑动窗口协议（连续ARQ协议）"><a href="#2-滑动窗口协议（连续ARQ协议）" class="headerlink" title="2. 滑动窗口协议（连续ARQ协议）"></a>2. 滑动窗口协议（连续ARQ协议）</h4><ol>
<li><p>连续ARQ协议<br>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。</p>
</li>
<li><p>累计确认<br>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。</p>
</li>
</ol>
<blockquote>
<p>TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。下面会介绍TCP头部报文段。</p>
</blockquote>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190531151613730.png" class="" title="在这里插入图片描述">

<p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。<br>发送窗口由三个指针构成：</p>
<p>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。<br>p2指向尚未发送的第一个字节。<br>p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。<br>p2-p3间的字节表示可以发送，但还没有发送的字节。<br>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。<br>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p>
<p><strong>连续ARQ的注意点：</strong></p>
<ol>
<li>同一时刻发送窗口的大小并不一定和接收窗口一样大。<br>虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。<br>此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</li>
<li>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。</li>
<li>sTCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。<br>此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</li>
</ol>
<hr>
<h2 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h2><p>总结二者各自的特点：</p>
<ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<h2 id="TCP三次握手和四次挥手过程"><a href="#TCP三次握手和四次挥手过程" class="headerlink" title="TCP三次握手和四次挥手过程"></a>TCP三次握手和四次挥手过程</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>要理解TCP三次握手和四次挥手的过程，首先需要了解TCP报文段的某些首部的含义：</p>
<ol>
<li>序号 seq：本报文段所发送的数据的第一个字节序号</li>
<li>确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号</li>
<li>确认位 ACK：仅当ACK&#x3D;1时确认号字段才有效</li>
<li>同步位 SYN：在连接建立时用来同步序号，SYN&#x3D;1表示这是一个连接请求或是连接接受请求。</li>
<li>终止位 FIN：用来释放一个连接。当FIN&#x3D;1时，表示此报文段的发送方数据已经发送完毕，并要求释放运输连接</li>
</ol>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612438854245.png" class="" title="在这里插入图片描述">

<p>（1）客户端A向服务端B发出连接请求，同步位SYN&#x3D;1，初始序号seq&#x3D;x，连接请求报文段不能携带数据，但是要消耗一个序号，这时客户端A进入SYN-SENT（同步已发送状态）。<br>（2）服务端B收到请求报文段之后，向A发送后确认。将同部位SYN和确认位都置为1，确认序号ack&#x3D;x+1，同时自己选择一个初始序号seq&#x3D;y。连接接收报文也不能携带数据，但是也要消耗一个序号，这时服务端进入SYN-RCVD(同步收到状态)。<br>（3）A收到B的确认时候要给B一个确认。确认报文段的确认位ACK&#x3D;1,确认号ack&#x3D;y+1,自己的序号seq&#x3D;x+1。这时,TCP连接已经建立，客户端进入ESTABLISHED（已建立连接状态）。B收到A发出的确认报文之后也进入已建立连接状态。</p>
<h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70-16612439966847.png" class="" title="在这里插入图片描述">

<p>（1）客户端进程发出连接释放报文，并且停止发送数据。A将连接释放报文的终止位FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>（2）服务器收到连接释放报文后发出确认，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向的连接就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>（3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）<br>（4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认<br>（5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，客户端才进入CLOSED状态<br>（6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。</p>
<h4 id="为什么是三次握手-而不是两次或者四次呢"><a href="#为什么是三次握手-而不是两次或者四次呢" class="headerlink" title="为什么是三次握手 而不是两次或者四次呢?"></a>为什么是三次握手 而不是两次或者四次呢?</h4><p>其实TCP连接需要的是，两方都知道自己是否有接受和发送数据的能力， 第一次A发送消息，A，B都不知道自己是否有接受和发送能力， B收到A的消息后，B知道了我有接受消息的能力，B发送给A，A现在知道了我能接受消息，而且发送的消息B能接受到，也说明A有发送消息的能力，最后一次A给B发送信息，B也知道了我有发送消息的能力，至此，AB都有发送和接受消息的能力，所以是三次，刚刚好。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是由于服务端的LISTEN状态下收到SYN报文的建立连接请求后。它能够把ACK和SYN（ACK起应答作用。而SYN起同步作用）放在一个报文里来发送给客户端。<br>但关闭连接的时候，当服务端收到客户端的FIN报文段的时候，表示客户端没有数据发送给服务端了，但是服务端可能还有数据要发送给客户端，这时TCP连接处于半连接状态。当服务端没有数据再发送给客户端的时候就会向客户端发送一个FIN报文表示服务端要关闭连接，ACK和FIN一般不会分开发送。这个过程也是由于TCP的通信方式是全双工的，发送和接收方都需要发送FIN和ACK。</p>
<h4 id="为什么三次挥手不能释放连接呢"><a href="#为什么三次挥手不能释放连接呢" class="headerlink" title="为什么三次挥手不能释放连接呢?"></a>为什么三次挥手不能释放连接呢?</h4><h4 id="最后为什么要进行2MSL-的等待"><a href="#最后为什么要进行2MSL-的等待" class="headerlink" title="最后为什么要进行2MSL 的等待"></a>最后为什么要进行2MSL 的等待</h4><p>网络是不可靠的，TCP是可靠协议，必须保证最后一次报文送达之后才能断开链接，否则会再次收到S端的FIN报文信息。<br>而等待2MSL时间就是为了保证最后最后一次报文丢失时还能重新发送。</p>
<p>2MSL是报文一个往返的最长时间，假设小于这个时间会发生，ACK丢了，但是还没接收到对方重传的FIN我方就重新发送了ACK。</p>
<hr>
<p>TIME_WAIT 状态也成为 2MSL 等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的 MSL 值，处理的原则是：当 TCP 执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的FIN）。</p>
<p>这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的 IP 地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。</p>
<h4 id="SYN-攻击是什么"><a href="#SYN-攻击是什么" class="headerlink" title="SYN 攻击是什么"></a><strong>SYN 攻击是什么</strong></h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。</p>
<p>SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ol>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1647168988779212556">TCP&#x2F;IP面试：为什么要四次挥手，三次不行吗 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130475730">关于TCP三次握手和四次挥手问题，求你别再问了问了… - 知乎 (zhihu.com)</a></p>
<h2 id="TCP-x2F-UDP各自的缓冲区"><a href="#TCP-x2F-UDP各自的缓冲区" class="headerlink" title="TCP&#x2F;UDP各自的缓冲区"></a>TCP&#x2F;UDP各自的缓冲区</h2><p>TCP和UDP都拥有套接口接收缓冲区。</p>
<p><strong>TCP套接口接收缓冲区不可能溢出</strong>，因为TCP具有流量控制(窗口).然而对于TCP来说，当接收到的数据报装不进套接口接收缓冲区时，该数据报就丢弃。UDP是没有流量控制的：较快的发送端可以很容易淹没较慢的接收端，导致接收端的UDP丢弃数据报。</p>
<p><strong>UDP存在接收缓冲区，UDP没有发送缓冲区，</strong>在调用sendto时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作。为什么UDP不需要发送缓冲区？ 因为UDP不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而<strong>TCP不同，他必须具备发送缓冲区</strong>，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansionz/article/details/86435127">(51条消息) TCP和UDP详解(非常详细)_Hansionz的博客-CSDN博客_tcp udp</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39754631/article/details/90242887">(48条消息) TCP三次握手和四次挥手过程_wq0321的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinjiniao1/article/details/90698643">(48条消息) 运输层功能详解_lzcWHUT的博客-CSDN博客_运输层</a></p>
<p>待学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/OYMNCHR/article/details/119118383">(48条消息) 计算机网络总结——运输层_OYMN的博客-CSDN博客</a></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="1-HTTP和HTTPS的区别："><a href="#1-HTTP和HTTPS的区别：" class="headerlink" title="1. HTTP和HTTPS的区别："></a>1. HTTP和HTTPS的区别：</h2><p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:&#x2F;&#x2F; 打头的都是标准 HTTP 服务。</p>
<p><strong>HTTP 协议以明文方式发送内容</strong>，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。既使用<strong>SSL&#x2F;TLS+HTTP</strong>。</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9556fa61ac7262a18bc639db29362669_720w.jpg" class="" title="img">

<p>SSL（Secure Socket Layer，安全套接字层）TLS（Transport Layer Security，传输层安全）</p>
<h3 id="对称加密和非对称加密："><a href="#对称加密和非对称加密：" class="headerlink" title="对称加密和非对称加密："></a>对称加密和非对称加密：</h3><p><strong>对称加密：</strong>加密和解密的秘钥使用的是同一个.</p>
<p> <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AF%86%E9%92%A5&spm=1001.2101.3001.7020">密钥</a>较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，且对计算机性能要求也没有那么高.</p>
<p>缺点：  算法公开、计算量小、加密速度快、加密效率高</p>
<p>常见的对称加密算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES </p>
<p>在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<p><strong>非对称加密算法:</strong> 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<p>https使用的是非对称加密</p>
<p><img src="https://pic4.zhimg.com/80/v2-1ea0209a526f3527a713736fe7609fcf_720w.jpg" alt="img"></p>
<p>[你知道，HTTPS用的是对称加密还是非对称加密？ - 知乎 (zhihu.com)](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96494976#:~:text=%E5%A4%A7%E5%AE%B6%E5%8F%AF%E8%83%BD%E9%83%BD%E5%90%AC%E8%AF%B4%E8%BF%87">https://zhuanlan.zhihu.com/p/96494976#:~:text=大家可能都听说过</a> HTTPS,协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227873816610">非对称加密算法 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h2 id="2-一个URL的执行过程"><a href="#2-一个URL的执行过程" class="headerlink" title="2. 一个URL的执行过程"></a>2. 一个URL的执行过程</h2><p>总体来说分为以下六个步骤：</p>
<p><strong>1、DNS解析</strong></p>
<p>DNS是将便于记忆的<strong>域名转化为IP地址</strong>。（DNS分为俩个，一个是DNS服务器，另一个是DNS协议，存在于UDP之上，使用53端口）。</p>
<p>三个层级的DNS服务器：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202849848.png" class="" title="image-20220825202849848">

<p>具体的执行步骤（不经过DNS缓存）：</p>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220825202950751.png" class="" title="image-20220825202950751">

<p>当一个客户端主机(cse.nyu.edu)想要知道主机gaia.cs.umass.edu的IP地址。同时假设纽约大学的cse.nyu.edu主机的本地DNS服务器为dns.nyu.edu，并且gaia.cs.umass.edu的权威DNS服务器为dns.nyu.edu，主机cse.nyu.edu首先向它的本地DNS服务器dns.nyu.edu发送一个DNS查询报文。该查询报文含有被转化的主机名gaia.cs.umass.edu。本地DNS服务器将该报文转发到根DNS服务器。该根DNS服务器注意到其edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表。该本地DNS服务器则再次向这些TLD服务器之一发送查询报文。该TLD服务器注意到umass.edu的前缀，并用权威DNS服务器的IP地址进行响应，该权威DNS服务器是负责马萨诸塞大学的dns.umass.edu。最后，本地DNS服务器直接向dns.umass.edu重发查询报文，dns.umass.edu用gaia.cs.umass.edu的IP地址进行响应。注意到在本例中，为了获得一台主机名的映射，共发送了8份DNS报文：4份查询报文和4份回答报文。</p>
<p>DNS缓存</p>
<p>在一个请求链中，当某个DNS服务器接受一个DNS回答时，它能够将映射，缓存在本地存储器中。事实上，因为缓存，除了少数DNS查询以外，根服务器都被绕过了。（因为主机名和IP地址之间的映射并不是永久的，DNS服务器在一段时间后（通常为两天）将会丢弃缓存的信息）。</p>
<p>在这一步 我们通过DNS将一个url的域名转化为一个真实的IP地址。</p>
<p><strong>2、TCP连接</strong></p>
<p>我们知道IP地址之后，就可以与这个IP地址开始尝试建立连接，在运输层我们选用的是TCP协议。</p>
<p><strong>3、发送HTTP请求</strong></p>
<p>在运输层我们建立好连接以后，应用层的使用者们就会开始进行应用信息的传输，</p>
<p><strong>4、服务器处理请求并返回HTTP报文</strong></p>
<p>这些就是后端工程师眼中的HTTP，后端从固定的端口接收到TCP报文开始，这一部分对应编程语言中的socket。它对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用，这一部分工作一般是由WEB服务器去进行，我们使用过的Web服务器有Tomcat等。</p>
<p>http响应报文也是由三部分组成的状态码、响应报头、响应报文</p>
<p><strong>5、负载均衡</strong></p>
<p>什么是负载均衡？当一台服务器无法支持大量的用户访问时，将用户分摊到两个或多个服务器上的方法叫负载均衡。什么是Nginx？Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。</p>
<p>关于Nginx的负载均衡：</p>
<ol>
<li><p>一般，如果我们的平台配备了负载均衡的话，前一步DNS解析获得的IP地址应该是我们Nginx负载均衡服务器的IP地址。所以，我们的浏览器将我们的网页请求发送到了Nginx负载均衡服务器上。</p>
</li>
<li><p>Nginx根据我们设定的分配算法和规则，选择一台后端的真实Web服务器，与之建立TCP连接、并转发我们浏览器发出去的网页请求。</p>
</li>
</ol>
<p>Nginx默认支持 RR轮转法 和 ip_hash法 这2种分配算法。</p>
<p>前者会从头到尾一个个轮询所有Web服务器，而后者则对源IP使用hash函数确定应该转发到哪个Web服务器上，也能保证同一个IP的请求能发送到同一个Web服务器上实现会话粘连。</p>
<p>也有其他扩展分配算法，如：</p>
<p>fair：这种算法会选择相应时间最短的Web服务器</p>
<p>url_hash：这种算法会使得相同的url发送到同一个Web服务器</p>
<ol start="3">
<li><p>Web服务器收到请求，产生响应，并将网页发送给Nginx负载均衡服务器。</p>
</li>
<li><p>Nginx负载均衡服务器将网页传递给filters链处理，之后发回给我们的浏览器。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190402234727661.png" alt="在这里插入图片描述"></p>
<p><strong>6、浏览器解析渲染页面</strong></p>
<p>浏览器是一个边解析边渲染的过程。</p>
<ol>
<li><p>浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码。</p>
</li>
<li><p>根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)</p>
</li>
<li><p>根据Render Tree渲染网页</p>
</li>
</ol>
<img src="/2022/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190402234453381.png" class="" title="在这里插入图片描述">



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/g291976422/article/details/88984859">(51条消息) 访问一个URL经历了哪些过程_昵給硪鐙誒的博客-CSDN博客_url过程</a></p>
<h2 id="3-常见的HTTP状态码"><a href="#3-常见的HTTP状态码" class="headerlink" title="3. 常见的HTTP状态码"></a>3. 常见的HTTP状态码</h2><p>状态码作为HTTP响应报文中状态行的其中最重要的标识,每个状态码都代表不同的含义</p>
<p> <strong>HTTP Status Code</strong>。</p>
<ul>
<li><p>200 - 请求成功</p>
</li>
<li><p>206 - 部分内容。服务器成功处理了部分GET请求</p>
</li>
<li><p>301 - 资源（网页等）被永久转移到其它URL</p>
</li>
<li><p>304 - 实际服务器响应web缓存服务器的报文状态标识 ， 表示web服务器的资源是否需要更新。</p>
</li>
<li><p>305 - 使用代理,所请求的资源必须通过代理访问</p>
</li>
<li><p>403 - 服务器理解请求客户端的请求，但是拒绝执行此请求</p>
</li>
<li><p>404 - 请求的资源（网页等）不存在</p>
</li>
<li><p>413 - 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。</p>
</li>
<li><p>500 - 内部服务器错误</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76679642">413错误码——http请求实体太大 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/01/MQ/" rel="prev" title="MQ">
      <i class="fa fa-chevron-left"></i> MQ
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/05/JavaEE/" rel="next" title="JavaEE">
      JavaEE <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.</span> <span class="nav-text">什么是协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E8%B7%AF%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">网路核心：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">分组交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1"><span class="nav-number">1.2.2.</span> <span class="nav-text">排队时延和分组丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.3.</span> <span class="nav-text">电路交换和分组交换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%EF%BC%8C%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">分组交换中的时延，丢包和吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">节点时延</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1. 处理时延</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2. 排队时延</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A2%E5%8C%85"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">丢包</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.传输时延</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">4. 传播时延</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%97%B6%E5%BB%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">端到端时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">计算机网络中的吞吐量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">网络数据封装过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.5.</span> <span class="nav-text">数据解封装过程：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">应用协议的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client%E5%92%8CServer%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">Client和Server模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2P%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">P2P模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">进程通信（套接字，端口号）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8C%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A1%94%E6%8E%A5"><span class="nav-number">2.3.</span> <span class="nav-text">应用层和运输层的工作衔接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.</span> <span class="nav-text">应用层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. 远程登陆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Http%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.2.</span> <span class="nav-text">8.Http协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Http%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Http数据格式解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.2.1.1.</span> <span class="nav-text">HTTP请求报文格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.2.1.2.</span> <span class="nav-text">HTTP响应报文格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-cookie"><span class="nav-number">2.4.3.</span> <span class="nav-text">HTTP cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E7%BC%93%E5%AD%98"><span class="nav-number">2.4.4.</span> <span class="nav-text">Web缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC"><span class="nav-number">2.4.5.</span> <span class="nav-text">HTTP的不同版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.6.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">2.5.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%B5%81%E5%92%8C%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91"><span class="nav-number">2.6.</span> <span class="nav-text">视频流和内容分发网</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">UDP概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%A6%82%E8%BF%B0"><span class="nav-number">3.2.</span> <span class="nav-text">TCP概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">TCP报文段首部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">可靠传输的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-ARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.0.3.</span> <span class="nav-text">1.停止等待协议(ARQ协议)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%EF%BC%88%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">3.2.0.4.</span> <span class="nav-text">2. 滑动窗口协议（连续ARQ协议）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E6%AF%94%E8%BE%83"><span class="nav-number">3.3.</span> <span class="nav-text">TCP和UDP比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">TCP三次握手和四次挥手过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.4.1.</span> <span class="nav-text">TCP三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">TCP四次挥手过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E8%80%85%E5%9B%9B%E6%AC%A1%E5%91%A2"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">为什么是三次握手 而不是两次或者四次呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8D%E8%83%BD%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E5%91%A2"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">为什么三次挥手不能释放连接呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C2MSL-%E7%9A%84%E7%AD%89%E5%BE%85"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">最后为什么要进行2MSL 的等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN-%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">SYN 攻击是什么</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-x2F-UDP%E5%90%84%E8%87%AA%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.5.</span> <span class="nav-text">TCP&#x2F;UDP各自的缓冲区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">4.1.</span> <span class="nav-text">1. HTTP和HTTPS的区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">对称加密和非对称加密：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%80%E4%B8%AAURL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">2. 一个URL的执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">4.3.</span> <span class="nav-text">3. 常见的HTTP状态码</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zh-CN</p>
  <div class="site-description" itemprop="description">The Blog Which Owned Shuaiqiwudi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zh-CN</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">228k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">3:27</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'hV6HQva8xks9UIucjaqQJ5uK-gzGzoHsz',
      appKey     : 'cDwVC10P19xDSP3q0QVRoFif',
      placeholder: "期待您的精彩评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
