<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IOStream</title>
    <url>/2022/05/18/IOStream/</url>
    <content><![CDATA[<h1 id="IO流的继承关系和分类"><a href="#IO流的继承关系和分类" class="headerlink" title="IO流的继承关系和分类"></a>IO流的继承关系和分类</h1><img src="/2022/05/18/IOStream/image-20220518162023270.png" class="" title="image-20220518162023270">

<span id="more"></span>

<img src="/2022/05/18/IOStream/image-20220518162100236.png" class="" title="image-20220518162100236">

<img src="/2022/05/18/IOStream/image-20220518162120508.png" class="" title="image-20220518162120508">

<img src="/2022/05/18/IOStream/image-20220518162134464.png" class="" title="image-20220518162134464">
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/05/16/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>什么是JVM？</p>
<p><strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此</p>
<p>Java语言可以实现跨平台。</p>
<p>提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE</p>
<p>JRE</p>
<p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang</p>
<p>包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异</p>
<p>常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK</p>
<p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以</p>
<p>安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>从包含关系来讲：JDK&gt;JRE&gt;JVM</p>
<img src="/2022/05/16/JVM/image-20220516150612535.png" class="" title="image-20220516150612535">

<span id="more"></span>

<p>既然谈到了JVM 众所周知 JVM是java语言的灵魂 那么JVM给java带来了什么？</p>
<p>跨平台性：</p>
<p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，</p>
<p>该系统就可以运行java程序。</p>
<p>又众所周知 java运行的流程如下：</p>
<p>.java文件 由开发人员编写 经过编译后 生成.class文件 ——即字节码文件</p>
<p>该.class文件不面向任何机器 只面向虚拟机</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解</p>
<p>释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，</p>
<p>因此，Java程序无须重新编译便可 在多种不同的计算机上运行。<strong>一次编译 到处运行</strong></p>
<p>作为高级语言 就得有解释 编译 将语言转化为二进制 这两个步骤 Java是怎么实现的呢？</p>
<p><strong>java中的编译器和解释器：</strong></p>
<p>也可以直接看下面</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在</p>
<p>任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的</p>
<p>代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代</p>
<p>码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚</p>
<p>拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，</p>
<p>然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java源代码(.java文件)----&gt;编译器----&gt;jvm可执行的Java字节码(.class文件)----&gt;jvm----&gt;jvm中的解释器-----&gt; 机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<p>接下来看一下JVM内部结构：</p>
<img src="/2022/05/16/JVM/image-20220516154322660.png" class="" title="image-20220516154322660">

<p>可以分为两组件 两子系统：</p>
<p>两个子系统：1.Class loader(类装载)  2. Execution engine(执行引擎)</p>
<p>两个组件：1.Runtime data area(运行时数据区）2.Native Interface(本地接口)。</p>
<blockquote>
<p>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</blockquote>
<blockquote>
<p>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。</p>
</blockquote>
<blockquote>
<p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内 存。</p>
</blockquote>
<blockquote>
<p>Execution engine（执行引擎）：执行classes中的指令。</p>
</blockquote>
<h5 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h5><p>运行时数据区存在于内存 又称jvm内存模型 分别有五个部分</p>
<blockquote>
<p><strong>程序计数器</strong>:当前线程所执行的字节码的行号 指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的 字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个 计数器来完成；</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>:类似虚拟机栈，是为虚拟机使用native本地方法而准备的。具体实现由虚拟机厂商来实现。HotSpot虚拟机中实现与虚拟机栈一致，同时超出大小抛StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>:每个线程私有的空间，由多个栈帧组成，一个方法对应一个栈帧，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大1M，超出跑出StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>:所有线程都可以访问修改，存放的是对象实例，是数据区中占用空间最大的部分，在HotSpot虚拟机中分为新生代和老年代，新生代又分为Eden区和Survivor0区、Survivor1区。</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>:JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。不同虚拟机有不同的实现，oracle的HotSpot在Java7中方法区放在永久代，Java8中方法区放在元空间，并通过GC机制来管理。</p>
</blockquote>
<p>在线程共享的角度来分类 		方法区,堆 属于线程共享的 | 虚拟机栈, 本地方法栈, 程序计数器不是线程共享的</p>
<p>**而程序计数器是唯一一个不会出现OOM的区域(Out Of Memory) ** error(java.lang.OutOfMemoryError)</p>
<p>首先聊一聊堆和方法区这两个最重要的区域:</p>
<p>堆:从上面的定义来讲,存放对象实例,就是java中经常操作的对象,堆的物理地址分配对对象是不连续的。</p>
<p>因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩）。 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性 能快。</p>
<p>方法区:存放类的相关信息</p>
<ol>
<li><p>静态变量放在方法区</p>
</li>
<li><p>静态的对象还是放在堆。</p>
</li>
</ol>
<p>既然创建的实例对象都在堆中,那堆中创建的对象多了怎么办,难道堆是一个无穷无尽的空间什么时期的实例对象都收纳吗?</p>
<p>堆空间是怎么决定哪些对象应该保存,哪些对象应该消失呢?难道要java程序员自己去决定吗?这就涉及到了java的垃圾回收机制</p>
<p><strong>什么是垃圾回收机制</strong></p>
<p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行 执行。在JVM中，有一</p>
<p>个垃圾回收线程，它是低优先级的，在正常情况下是不会 执行的，只有在虚拟机空闲或者当前堆内存不</p>
<p>足时，才会触发执行，扫面那些没 有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<p><strong>什么是GC</strong></p>
<p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误</p>
<p>的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而</p>
<p>达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<p><strong>垃圾回收的基本原理是什么?有社么办法可以通知垃圾回收器马上开始GC吗?</strong></p>
<p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达</p>
<p>的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<p><strong>如何判断对象是否可以被回收</strong></p>
<p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」</p>
<p>的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<blockquote>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，</p>
<p>当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</p>
</blockquote>
<blockquote>
<p>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC</p>
<p>Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 </p>
</blockquote>
<p>&#x2F;&#x2F;TODO 可达性算法详解</p>
<p>对于堆空间,java不同版本的虚拟机会有不同的垃圾回收算法,目前最主流的有:</p>
<p>1.<strong>标记-清除算法</strong>：标记无用对象，然后进行清除回收。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<p>2.<strong>标记-复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<p>3.<strong>标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>4.<strong>分代算法</strong>：根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是新生代和老年 代，新生代分为Eden区和Survior区。<img src="/2022/05/16/JVM/image-20220521095627681.png" class="" title="image-20220521095627681"></p>
<p><strong>分代算法的对象迁移</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对</p>
<p>象应该放在老年代。因此虚拟机给每个对象定义了一个对 象年龄的计数器，如果对象在 Eden 区出生，</p>
<p>并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区</p>
<p>中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升 到老年代。</p>
<h4 id="JVM都有哪些垃圾回收器？"><a href="#JVM都有哪些垃圾回收器？" class="headerlink" title="JVM都有哪些垃圾回收器？"></a>JVM都有哪些垃圾回收器？</h4><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种</p>
<p>作用于不同分代的收集器，其中用于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回</p>
<p>收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收</p>
<p>集器 之间的连线表示它们可以搭配使用。</p>
<img src="/2022/05/16/JVM/image-20220520140939077.png" class="" title="image-20220520140939077">



<details>
<summary>点击查看垃圾回收器详细内容</summary>
Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU
环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不 高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器
的老年代版本；<br>
<b>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</b>： 老年代并行收集 器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。<br>
<b>G1(Garbage First)收集器 (标记-整理算法)</b>： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新
收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同
于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代 或老年代。<br>
</details>

<p><strong>各垃圾回收器的使用位置</strong></p>
<p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<p><strong>各代适合的垃圾回收算法</strong></p>
<p>年轻代的堆空间，因为经常生成对象，并且对象的消亡和创建都很频繁，所以该区域需要高效率，能更好利用cpu的垃圾回收算法以保证内存空间的充足，<strong>新生代常常使用标记-复制算法。</strong></p>
<p>老年代的堆空间常常存放不易回收的对象，所以该区域不需要频繁的进行GC，需要考虑的是内存空间的利用，需要足够的空间存放不易回收的老年代对象，<strong>老年代常常使用标记整理算法，CMS的标记清除算法。</strong></p>
<p><strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></p>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾</p>
<p>回收器。对于要求服务器响应速度的应用上，这种垃圾 回收器非常适合。在启动 JVM 的参数加上“-</p>
<p>XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，</p>
<p>所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现</p>
<p>Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h5 id="创建对象的内存分配"><a href="#创建对象的内存分配" class="headerlink" title="创建对象的内存分配"></a>创建对象的内存分配</h5><p>多数情况下，对象都在Eden区被创建，但是当Eden区内存空间不足的时候，虚拟机会进行一次<strong>年轻代的MinorGC</strong>，</p>
<p>如果本次GC以后，依然没有足够的空间，则将启用分配担保机制，在老年代中分配内存。</p>
<p><strong>如果对象太大怎么办？</strong></p>
<p>大对象是指需要大连的连续的内存空间的对象，而大对象如果存放在年轻代，而年轻代使用的是标记复制算法，大对象</p>
<p>在两个幸存区之间不断复制，占用了其他对象的空间，并且影响了效率。假设大对象是“朝生夕死”的（从GC次数上来讲</p>
<p>不会进入老年代），那它占用了年轻代的空间，其他对象进入的时候因为大对象的存在会提前触发GC，而大对象在幸存区</p>
<p>的空间占比又过大，导致新创建的对象只能添加到老年代，这就加快了老年代GC的时间，对老年代的性能进行了很大的负面</p>
<p>影响。<strong>（毕竟老年代的GC效率大概要比年轻代的GC效率低10倍左右）</strong>。如果确定大对象是“朝生夕死”的，可以通过设置JVM</p>
<p>对大对象的参数阈值【-XX:PretenureSizeThreshold】，使大对象相对JVM来讲是不再那么大，从而在年轻代就GC（当然会</p>
<p>这样影响性能）。</p>
<h5 id="发生在不同区域的GC"><a href="#发生在不同区域的GC" class="headerlink" title="发生在不同区域的GC"></a>发生在不同区域的GC</h5><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</p>
<p><strong>Major GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。</p>
<p><strong>FullGC</strong> 是指发生在整个堆内存的GC ，老年代和年轻代一起GC，应该避免FullGC的发生，会影响JVM的性能。</p>
<p>触发条件：1）System.gc() 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。</p>
<p>​					2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>​					3）通过Minor GC后进入年轻代的平均大小大于老年代的可用内存</p>
<p>FullGC详解</p>
<blockquote>
<p><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC | Plumbr – User Experience &amp; Application Performance Monitoring</a></p>
</blockquote>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h3 id="对象从创建到消亡的历史过程"><a href="#对象从创建到消亡的历史过程" class="headerlink" title="对象从创建到消亡的历史过程"></a>对象从创建到消亡的历史过程</h3><h3 id="User-user-x3D-new-User-做了什么操作，申请了哪些内存？"><a href="#User-user-x3D-new-User-做了什么操作，申请了哪些内存？" class="headerlink" title="User user &#x3D; new User() 做了什么操作，申请了哪些内存？"></a><strong>User user &#x3D; new User()</strong> <strong>做了什么操作，申请了哪些内存？</strong></h3><h3 id="对象的内存分配位置"><a href="#对象的内存分配位置" class="headerlink" title="对象的内存分配位置"></a>对象的内存分配位置</h3><h3 id="JVM的性能调优"><a href="#JVM的性能调优" class="headerlink" title="JVM的性能调优"></a>JVM的性能调优</h3><h3 id="为什么jdk8用metaspace数据结构用来替代perm？"><a href="#为什么jdk8用metaspace数据结构用来替代perm？" class="headerlink" title="为什么jdk8用metaspace数据结构用来替代perm？"></a>为什么jdk8用metaspace数据结构用来替代perm？</h3><h3 id="GC算法，永久代对象如何GC，GC有环怎么处理"><a href="#GC算法，永久代对象如何GC，GC有环怎么处理" class="headerlink" title="GC算法，永久代对象如何GC，GC有环怎么处理"></a><strong>GC</strong>算法，永久代对象如何GC，GC有环怎么处理</h3><img src="/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>在讨论深拷贝和浅拷贝之前 首先要了解一下java的赋值机制——值传递</p>
<p>什么是值传递 什么是引用传递?</p>
<p>首先要了解一下 什么是实际参数 什么是形式参数?</p>
<p>形式参数 最先想到的就是java方法中的方法参数值了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123; <span class="comment">//word就是形式参数 简称形参</span></span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际参数 就是传给这个函数的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.speak(<span class="string">&quot;hello,java&quot;</span>);<span class="comment">//hello,java是实际参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 我传给这个函数的 到底是这个”hello,java”本身 还是”hello,java”这个对象在内存中的引用呢? 于是 就有了值传递和引用传递</p>
<p><strong>值传递</strong>: 把这个参数的值给函数,调用函数的时候只对传给这个函数的值进行修改等操作(就是说 在这个函数里你怎么折腾这个值都可以 但就是不会影响这个值本身) </p>
<p>将一个变量的值传给另一个变量。不管这个变量基本数据类型还是引用数据类型。引用数据类型的话传的还是值。不过这个值是指向对象的地址。</p>
<p><strong>引用传递</strong>: 直接传给函数这个参数的内存地址,直接在这个参数上面进行修改。</p>
<p>地址传递，传的是另一个变量的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>地址。java中没有引用传递。</p>
<hr>
<p><strong>深拷贝</strong></p>
<p>是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内</p>
<p>存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p><strong>浅拷贝</strong></p>
<p>只是增加了一个指针指向已存在的内存地址。</p>
<hr>
<p>那么这两个传递类型和深拷贝浅拷贝有什么关系呢?</p>
<p>深拷贝和浅拷贝在拷贝值的时候 都是值传递 并没有使用引用传递 而深拷贝的效果之所以有时候和引用传递相同,是因为引用传递是将对象的内存地址直接传给一个函数,而深拷贝是直接复制了一个内存值 在这个复制的内存值上进行操作.</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2022/05/29/Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><img src="/2022/05/29/Mybatis/1502093784622523.png" class="" title="img">

<h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis?"></a>什么是Mybatis?</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<span id="more"></span>

<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>首先在pom.xml文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 <a href="https://www.w3cschool.cn/xml/">XML</a> 中构建 SqlSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 <code>file:// URL</code> 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（<a href="https://www.w3cschool.cn/kzsow/kzsow-frbn2grj.html">mapper</a>），这些映射器的 XML 映射文件包含了 <a href="https://www.w3cschool.cn/sql/">SQL</a> 代码和映射定义信息。</p>
<h1 id="MyBatis-XML配置"><a href="#MyBatis-XML配置" class="headerlink" title="MyBatis XML配置"></a>MyBatis XML配置</h1><p>mybatis-config.xml配置文件  <configuration> 标签中 各个标签的配置顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--    此处易报错 注意错误返回的标签规则 将下面的标签顺序重新排列--&gt;</span><br><span class="line">&lt;!--    (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt;--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h2><p>MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h2><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
<p>属性也可以被传递到 SqlSessionBuilder.build()方法中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment, props);</span><br></pre></td></tr></table></figure>

<p>如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的<strong>顺序来加载</strong>：</p>
<ul>
<li>在 properties 元素体内指定的属性首先被读取。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。</li>
</ul>
<h2 id="配置环境（environments）"><a href="#配置环境（environments）" class="headerlink" title="配置环境（environments）"></a>配置环境（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p>
<p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p>
<ul>
<li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment,properties);</span><br></pre></td></tr></table></figure>

<p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader,properties);</span><br></pre></td></tr></table></figure>

<p>环境元素定义了如何配置环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用的是第一个环境变量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 另一个环境 在&lt;environments default=&quot; &quot;&gt; 设置应该加载哪个--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username2&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password2&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的关键点:</p>
<ul>
<li>默认的环境 ID（比如:default&#x3D;”development”）。</li>
<li>每个 environment 元素定义的环境 ID（比如:id&#x3D;”development”）。</li>
<li>事务管理器的配置（比如:type&#x3D;”JDBC”）。</li>
<li>数据源的配置（比如:type&#x3D;”POOLED”）。</li>
</ul>
<p>默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。</p>
<h3 id="数据源（dataSource）"><a href="#数据源（dataSource）" class="headerlink" title="数据源（dataSource）"></a><strong>数据源（dataSource）</strong></h3><p>数据源<dataSource> 标签 属于  <environment> 在其中配置数据源</p>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<ul>
<li>许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</li>
</ul>
<p>有三种内建的数据源类型（也就是 type&#x3D;”[   UNPOOLED     |    POOLED    |    JNDI    ]”）：</p>
<p><strong>UNPOOLED</strong>– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p>
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
</ul>
<p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为”driver.”，例如：</p>
<ul>
<li><code>driver.encoding=UTF8</code></li>
</ul>
<p>这将通过DriverManager.getConnection(url,driverProperties)方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</p>
<p><strong>POOLED</strong>– 这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p>
<p>除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是”NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 <code>poolPingQuery</code> 属性（最好是一个非常快的 SQL），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
<p><strong>JNDI</strong>– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p>
<ul>
<li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。</li>
<li><code>data_source</code> – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</li>
</ul>
<h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h2><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="编写XML映射文件"><a href="#编写XML映射文件" class="headerlink" title="编写XML映射文件"></a>编写XML映射文件</h1><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p>
<ul>
<li><code>cache</code> – 给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。</p>
<p>select 标签有很多属性允许你配置，来决定每条语句的作用细节。</p>
<p><strong>Select Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">resultType</td>
<td align="left">从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td>
</tr>
<tr>
<td align="left">resultMap</td>
<td align="left">外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</td>
</tr>
<tr>
<td align="left">useCache</td>
<td align="left">将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">fetchSize</td>
<td align="left">这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">resultSetType</td>
<td align="left">FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
<tr>
<td align="left">resultOrdered</td>
<td align="left">这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。</td>
</tr>
<tr>
<td align="left">resultSets</td>
<td align="left">这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。</td>
</tr>
</tbody></table>
<p>类似的 insert update delete 标签的属性</p>
<p><strong>Insert Update Delete Attributes</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">命名空间中的唯一标识符，可被用来代表这条语句。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="left">（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td align="left">keyProperty</td>
<td align="left">（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">keyColumn</td>
<td align="left">（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<p>&#x2F;&#x2F;TODO 一些其他的构造方法和参数</p>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>根据条件进行判断：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<p>还是上面的例子，但是这次变为提供了”title”就按”title”查找，提供了”author”就按”author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><p>首先看一个动态SQL：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>乍一看没什么问题 但是当每个条件都匹配不到时,这条SQL会变成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure>

<p>如何解决这种条件不匹配的sql？MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>where 元素知道只有在一个以上的if条件有值的情况下才去插入”WHERE”子句。而且，若最后的内容是”AND”或”OR”开头的，where 元素也知道如何将他们去除。</p>
<p>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。</p>
<p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。</p>
<p>若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。</p>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p>
<h1 id="Mybatis-日志"><a href="#Mybatis-日志" class="headerlink" title="Mybatis 日志"></a>Mybatis 日志</h1><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>将用户经常查询的数据的结果的一个保存，保存到一个内存中（缓存就是内存中的一个对象），用户在查询的时候就不用到数据库文件中查询（磁盘），从而减少与数据库的交付次数提高了响应速度，解决了并发系统的性能问题。</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>MyBatis提供了一级缓存和二级缓存</p>
<ul>
<li>一级缓存：也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。</li>
<li>二级缓存：也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>在应用运行过程中，在一次数据库会话中，执行多次查询条件完全相同的SQL，会优先命中一级缓存，避免直接对数据库中直接查询。</p>
<img src="/2022/05/29/Mybatis/webp.webp" class="" title="img">

<p>每个SqlSession中都持有Excutor，每个Excutor中有一个LocalCache。当用户发起询问时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。</p>
<img src="/2022/05/29/Mybatis/webp-16538306997353.webp" class="" title="img">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>SqlSession：</strong> 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是DefaultSqlSession。<br> <strong>Executor：</strong> SqlSession向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。Executor有两个实现类，和一级缓存关联的是BaseExecutor。<br> <strong>BaseExecutor：</strong> BaseExecutor是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。<br> <strong>PerpetualCache：</strong>对Cache接口最基本实现，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。</p>
<p>SqlSession初始化时会创建Executor的实例，Mybatis默认使用的是SimpleExecutor，初始化代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如果启用二级缓存，使用CahingExecutor装饰类</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession在提交的时候会清空本地缓存，因为commit操作一般对应插入、更新或者删除操作，清空缓存防止读取脏数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Cannot commit, transaction is already closed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  flushStatements();</span><br><span class="line">  <span class="keyword">if</span> (required) &#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SqlSession的insert方法和delete方法，都会统一走update的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>update方法也是委托给了Executor执行。BaseExecutor的执行方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一级缓存失效的原因"><a href="#一级缓存失效的原因" class="headerlink" title="一级缓存失效的原因"></a>一级缓存失效的原因</h3><ul>
<li>同一个用户使用不同的SqlSession对象导致无法看到一级缓存工作。</li>
<li>在一个SqlSession中使用条件查询不同一级缓存也会失效。</li>
<li>在一个SqlSession使用相同条件，但是，此时在查询之间进行数据修改操作会导致一级缓存失效。</li>
<li>在一个SqlSession使用相同查询条件此时手动刷新缓存时导致一级缓存失败。</li>
</ul>
<h3 id="一级缓存注意"><a href="#一级缓存注意" class="headerlink" title="一级缓存注意"></a>一级缓存注意</h3><p>MyBatis一级缓存的生命周期和SqlSession一致。</p>
<p>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</p>
<p>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据。</p>
<p>mybatis和spring整合后进行mapper代理开发，不支持一级缓存。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><img src="/2022/05/29/Mybatis/webp-16538311623015.webp" class="" title="img">

<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。<br> 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="如何开启二级缓存"><a href="#如何开启二级缓存" class="headerlink" title="如何开启二级缓存"></a>如何开启二级缓存</h3><ol>
<li>需要在MyBatis核心配置文件,通过settings标签开发二级缓存。<br> <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></li>
<li>在对应的Mapper文件中添加cache标签</li>
<li>cache标签属性</li>
</ol>
<ul>
<li><p>type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。</p>
</li>
<li><p>eviction： 定义回收的策略，常见的有FIFO，LRU。</p>
</li>
<li><p>flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</p>
</li>
<li><p>size： 最多缓存对象的个数。</p>
</li>
<li><p>readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</p>
</li>
<li><p>blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存4</p>
<p>4.cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
</li>
</ul>
<p> <code>&lt;cache-ref namespace=&quot;mapper.StudentMapper&quot;/&gt;</code></p>
<h3 id="核心接口和实现类"><a href="#核心接口和实现类" class="headerlink" title="核心接口和实现类"></a>核心接口和实现类</h3><img src="/2022/05/29/Mybatis/webp-16538313584837.webp" class="" title="img">

<p>CachingExecutor的query方法，首先会从MappedStatement中获得在配置初始化时赋予的Cache。</p>
<p>以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。</p>
<ul>
<li>SynchronizedCache： 同步Cache，实现比较简单，直接使用synchronized修饰方法。</li>
<li>LoggingCache： 日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。</li>
<li>SerializedCache： 序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li>LruCache： 采用了Lru算法的Cache实现，移除最近最少使用的key&#x2F;value。</li>
<li>PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<p>可以为每条Mapper语句设置是否要刷新缓存,可以指定select语句是否使用缓存,如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>判断是否刷新缓存</p>
<p> <code>flushCacheIfRequired(ms);</code></p>
<p> 在默认的设置的select语句是不会刷新缓存的，insert&#x2F;update&#x2F;delte会刷新缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>&#x2F;&#x2F;TODO</p>
<h3 id="二级缓存失效的原因"><a href="#二级缓存失效的原因" class="headerlink" title="二级缓存失效的原因"></a>二级缓存失效的原因</h3><ul>
<li>flushCache属性在查询中作用针对二级缓存导致失效</li>
<li>flushCache属性在查询中作用针对一级缓存导致失效</li>
<li>flushCache属性在更新中作用导致两次查询结果完全一样</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</p>
<p>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p>
<p>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis,Memcached等分布式缓存可能成本更低，安全性也更高。</p>
<p>原文链接：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制 - 美团技术团队 (meituan.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/b4522c9212fb">https://www.jianshu.com/p/b4522c9212fb</a></p>
<p>原文链接：<a href="https://www.w3cschool.cn/mybatis/mybatis-dyr53b5w.html">MyBatis 入门_w3cschool</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Server</title>
    <url>/2022/05/18/Server/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>作为后端开发，数据传输到前端界面，或者浏览器运行，如果出现问题，那么就会让人崩溃，各种错误代码扑面而来，让头发焦急。</p>
<p>提到Tomcat 就必须提到Server。</p>
<p>每当一个项目开始运行（启动）那么，支撑浏览器到达指定端口的位置，并且显示界面的，显示数据的，一定是服务器的工作，在本地的项目开始运行，tomcat就充当这个服务器的角色，所以tomcat是web应用服务器,是用来处理java程序的一个应用服务器。</p>
<p>扒开Tomcat 看看真面目：</p>
<img src="/2022/05/18/Server/20160816205332380.png" class="" title="Tomcat总体架构">

<span id="more"></span>



<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>Server是Tomcat最顶层的容器，代表着整个服务器，即一个Tomcat只有一个Server，Server中包含至少一个Service组件，用于提供具体服务。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2022/05/26/Spring/</url>
    <content><![CDATA[<p>[Spring官网]<a href="https://spring.io/">Spring | Home</a></p>
<img src="/2022/05/26/Spring/v2-f35943a6d87c5f9f10f45eee4941deb3_720w-16536637221882.jpg" class="" title="v2-f35943a6d87c5f9f10f45eee4941deb3_720w">

<h1 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring?"></a>什么是Spring?</h1><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring同时也是开源轻量级框架，其核心包在文件容量上只有不到1MB 的大小。	然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>​	<strong>简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。</strong></p>
<span id="more"></span>

<h1 id="Spring的核心组件"><a href="#Spring的核心组件" class="headerlink" title="Spring的核心组件"></a>Spring的核心组件</h1><img src="/2022/05/26/Spring/image-20220526175028291-16536637559683.png" class="" title="image-20220526175028291">

<h1 id="Spring大致加载流程"><a href="#Spring大致加载流程" class="headerlink" title="Spring大致加载流程"></a>Spring大致加载流程</h1><img src="/2022/05/26/Spring/wps1.jpg" class="" title="img">

<p>BeanFactoryPostProcesser：</p>
<p>BeanPostProcesser：</p>
<p><strong>执行的过程如下:</strong></p>
<p>1.ResouceLoader加载配置信息<br>2.解析配置信息，生成一个一个的BeanDefintion<br>3.BeanDefintion由BeanDefintionRegistry管理起来<br>4.BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)<br>5.实例化Bean<br>6.如果该Bean配置&#x2F;实现了InstantiationAwareBean，则调用对应的方法<br>7.使用BeanWarpper来完成对象之间的属性配置(依赖)<br>8.如果该Bean配置&#x2F;实现了Aware接口，则调用对应的方法<br>9.如果该Bean配置了BeanPostProcessor的before方法，则调用<br>10.如果该Bean配置了init-method或者实现InstantiationBean，则调用对应的方法<br>11.如果该Bean配置了BeanPostProcessor的after方法，则调用<br>12.将对象放入到HashMap中<br>13.最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</p>
<h1 id="Spring浅看"><a href="#Spring浅看" class="headerlink" title="Spring浅看"></a>Spring浅看</h1><img src="/2022/05/26/Spring/image-20220526175017424-16536637765225-16536638098216.png" class="" title="image-20220526175017424-16536637765225">

<img src="/2022/05/26/Spring/image-20220526174932412-16536638610858.png" class="" title="image-20220526174932412">

<img src="/2022/05/26/Spring/image-20220526175457607-16536638760849.png" class="" title="image-20220526175457607">

<p>bean注入与装配的的方式有很多种，可以通过xml，getset方式，构造函数或者注解等。简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式，让项目阅读和开发起来更加方便。</p>
<img src="/2022/05/26/Spring/image-20220526175600355-165366388819310.png" class="" title="image-20220526175600355">

<img src="/2022/05/26/Spring/image-20220526175612242-165366391229911.png" class="" title="image-20220526175612242">

<p>它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。</p>
<p>Spring框架的开发不是为了替代现有的优秀第三方框架，而是通过集成的方式把它们都连接起来。下面总结了一些常集成的优秀框架。</p>
<img src="/2022/05/26/Spring/image-20220526175650919-165366393348713.png" class="" title="image-20220526175650919">

<h1 id="SpringIOC-和-Spring-AOP"><a href="#SpringIOC-和-Spring-AOP" class="headerlink" title="SpringIOC 和 Spring AOP"></a>SpringIOC 和 Spring AOP</h1><p>作为Spring框架最核心的两个“功能” ，需要完全理解IOC和AOP，才能真正灵活正确的使用Spring框架 ，而Spring框架作为Spring全家桶系列的最基础的使用框架，它的最核心功能就是—拓展， 让这个框架的功能越来越丰富，在基石上创建最实用的功能。</p>
<p>spring的IoC容器是spring的核心，spring AOP是spring框架的重要组成部分。</p>
<h2 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h2><p>在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。</p>
<p>IOC:控制反转也叫依赖注入。利用了工厂模式<br>将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p>
<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p>面向切面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使IoC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。</p>
<p>AOP:面向切面编程。（Aspect-Oriented Programming）<br>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br><strong>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面</strong>，然后注入到目标对象（具体业务逻辑）中去。</p>
<h2 id="Spring中beanFactory和ApplicationContext的联系和区别"><a href="#Spring中beanFactory和ApplicationContext的联系和区别" class="headerlink" title="Spring中beanFactory和ApplicationContext的联系和区别"></a><strong>Spring中beanFactory和ApplicationContext的联系和区别</strong></h2><p><strong>一、 BeanFactory</strong></p>
<p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例</p>
<p>化、配置和管理 Bean。</p>
<p>BeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方</p>
<p>法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的</p>
<p>Bean。</p>
<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。注意，BeanFactory 只能管理</p>
<p>单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为</p>
<p>原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。</p>
<p>BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。来看一下BeanFactory的基本类体</p>
<p>系结构（接口为主）：</p>
<img src="/2022/05/26/Spring/image-20220528103213112.png" class="" title="image-20220528103213112">

<p>1、BeanFactory作为一个主接口不继承任何接口，暂且称为<strong>一级接口</strong>。<br>2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为<strong>二级接口</strong>。<br>3、ConfigurableBeanFactory可以被称为<strong>三级接口</strong>，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为<strong>四级接口</strong>。<br>　　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。</p>
<p>BeanFactory接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111158974.png" class="" title="image-20220528111158974">

<details> 
    <summary><font color=blue>点击查看BeanFactory接口源码</font></summary> 
    <pre><code>   
/**
 *The root interface for accessing a Spring bean container.
 * This is the basic client view of a bean container;
 * further interfaces such as &#123;@link ListableBeanFactory&#125; and
 * &#123;@link org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;
 * are available for specific purposes.
 *
 * This interface is implemented by objects that hold a number of bean definitions,
 * each uniquely identified by a String name. Depending on the bean definition,
 * the factory will return either an independent instance of a contained object
 * (the Prototype design pattern), or a single shared instance (a superior
 * alternative to the Singleton design pattern, in which the instance is a
 * singleton in the scope of the factory). Which type of instance will be returned
 * depends on the bean factory configuration: the API is the same. Since Spring
 * 2.0, further scopes are available depending on the concrete application
 * context (e.g. "request" and "session" scopes in a web environment).
 *
 * Bean factory implementations should support the standard bean lifecycle interfaces
 * as far as possible. The full set of initialization methods and their standard order is:
 * <ol>
 * <li>BeanNameAware's &#123;@code setBeanName&#125;
 * <li>BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;
 * <li>BeanFactoryAware's &#123;@code setBeanFactory&#125;
 * <li>EnvironmentAware's &#123;@code setEnvironment&#125;
 * <li>EmbeddedValueResolverAware's &#123;@code setEmbeddedValueResolver&#125;
 * <li>ResourceLoaderAware's &#123;@code setResourceLoader&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125;
 * (only applicable when running in an application context)
 * <li>MessageSourceAware's &#123;@code setMessageSource&#125;
 * (only applicable when running in an application context)
 * <li>ApplicationContextAware's &#123;@code setApplicationContext&#125;
 * (only applicable when running in an application context)
 * <li>ServletContextAware's &#123;@code setServletContext&#125;
 * (only applicable when running in a web application context)
 * <li>&#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors
 * <li>InitializingBean's &#123;@code afterPropertiesSet&#125;
 * <li>a custom init-method definition
 * <li>&#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors
 * </ol>
 *
 * On shutdown of a bean factory, the following lifecycle methods apply:
 * <ol>
 * <li>&#123;@code postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors
 * <li>DisposableBean's &#123;@code destroy&#125;
 * <li>a custom destroy-method definition
 * </ol>
 */
public interface BeanFactory &#123;
   /**
    * Used to dereference a &#123;@link FactoryBean&#125; instance and distinguish it from
        * beans <i>created</i> by the FactoryBean. For example, if the bean named
        * &#123;@code myJndiObject&#125; is a FactoryBean, getting &#123;@code &myJndiObject&#125;
        * will return the factory, not the instance returned by the factory.
        */
      String FACTORY_BEAN_PREFIX = "&";
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
        * This method allows a Spring BeanFactory to be used as a replacement for the
        * Singleton or Prototype design pattern. Callers may retain references to
        * returned objects in the case of Singleton beans.
        * Translates aliases back to the corresponding canonical bean name.
        * Will ask the parent factory if the bean cannot be found in this factory instance.
        * @param name the name of the bean to retrieve
        * @return an instance of the bean
        * @throws NoSuchBeanDefinitionException if there is no bean definition
        * with the specified name
        * @throws BeansException if the bean could not be obtained
        */
      Object getBean(String name) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Behaves the same as &#123;@link #getBean(String)&#125;, but provides a measure of type
    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the
    * required type. This means that ClassCastException can't be thrown on casting
    * the result correctly, as can happen with &#123;@link #getBean(String)&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to retrieve
    * @param requiredType type the bean must match. Can be an interface or superclass
    * of the actual class, or &#123;@code null&#125; for any match. For example, if the value
    * is &#123;@code Object.class&#125;, this method will succeed whatever the class of the
    * returned instance.
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanNotOfRequiredTypeException if the bean is not of the required type
    * @throws BeansException if the bean could not be created
    */
   <T> T getBean(String name, Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * @param name the name of the bean to retrieve
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 2.5
    */
   Object getBean(String name, Object... args) throws BeansException;
   /**
    * Return the bean instance that uniquely matches the given object type, if any.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @return an instance of the single bean matching the required type
    * @throws NoSuchBeanDefinitionException if no bean of the given type was found
    * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
    * @throws BeansException if the bean could not be created
    * @since 3.0
    * @see ListableBeanFactory
    */
   <T> T getBean(Class<T> requiredType) throws BeansException;
   /**
    * Return an instance, which may be shared or independent, of the specified bean.
    * Allows for specifying explicit constructor arguments / factory method arguments,
    * overriding the specified default arguments (if any) in the bean definition.
    * This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory
    * but may also be translated into a conventional by-name lookup based on the name
    * of the given type. For more extensive retrieval operations across sets of beans,
    * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;.
    * @param requiredType type the bean must match; can be an interface or superclass.
    * &#123;@code null&#125; is disallowed.
    * @param args arguments to use when creating a bean instance using explicit arguments
    * (only applied when creating a new instance as opposed to retrieving an existing one)
    * @return an instance of the bean
    * @throws NoSuchBeanDefinitionException if there is no such bean definition
    * @throws BeanDefinitionStoreException if arguments have been given but
    * the affected bean isn't a prototype
    * @throws BeansException if the bean could not be created
    * @since 4.1
    */
   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
   /**
    * Does this bean factory contain a bean definition or externally registered singleton
    * instance with the given name?
    * If the given name is an alias, it will be translated back to the corresponding
    * canonical bean name.
    * If this factory is hierarchical, will ask any parent factory if the bean cannot
    * be found in this factory instance.
    * If a bean definition or singleton instance matching the given name is found,
    * this method will return &#123;@code true&#125; whether the named bean definition is concrete
    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;@code true&#125;
    * return value from this method does not necessarily indicate that &#123;@link #getBean&#125;
    * will be able to obtain an instance for the same name.
    * @param name the name of the bean to query
    * @return whether a bean with the given name is present
    */
   boolean containsBean(String name);
   /**
    * Is this bean a shared singleton? That is, will &#123;@link #getBean&#125; always
    * return the same instance?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * independent instances. It indicates non-singleton instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isPrototype&#125; operation to explicitly
    * check for independent instances.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean corresponds to a singleton instance
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @see #getBean
    * @see #isPrototype
    */
   boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
   /**
    * Is this bean a prototype? That is, will &#123;@link #getBean&#125; always return
    * independent instances?
    * Note: This method returning &#123;@code false&#125; does not clearly indicate
    * a singleton object. It indicates non-independent instances, which may correspond
    * to a scoped bean as well. Use the &#123;@link #isSingleton&#125; operation to explicitly
    * check for a shared singleton instance.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return whether this bean will always deliver independent instances
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.3
    * @see #getBean
    * @see #isSingleton
    */
   boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code ResolvableType&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 4.2
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Check whether the bean with the given name matches the specified type.
    * More specifically, check whether a &#123;@link #getBean&#125; call for the given name
    * would return an object that is assignable to the specified target type.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @param typeToMatch the type to match against (as a &#123;@code Class&#125;)
    * @return &#123;@code true&#125; if the bean type matches,
    * &#123;@code false&#125; if it doesn't match or cannot be determined yet
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 2.0.1
    * @see #getBean
    * @see #getType
    */
   boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
   /**
    * Determine the type of the bean with the given name. More specifically,
    * determine the type of object that &#123;@link #getBean&#125; would return for the given name.
    * For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates,
    * as exposed by &#123;@link FactoryBean#getObjectType()&#125;.
    * Translates aliases back to the corresponding canonical bean name.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the name of the bean to query
    * @return the type of the bean, or &#123;@code null&#125; if not determinable
    * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    * @since 1.1.2
    * @see #getBean
    * @see #isTypeMatch
    */
   Class<?> getType(String name) throws NoSuchBeanDefinitionException;
   /**
    * Return the aliases for the given bean name, if any.
    * All of those aliases point to the same bean when used in a &#123;@link #getBean&#125; call.
    * If the given name is an alias, the corresponding original bean name
    * and other aliases (if any) will be returned, with the original bean name
    * being the first element in the array.
    * Will ask the parent factory if the bean cannot be found in this factory instance.
    * @param name the bean name to check for aliases
    * @return the aliases, or an empty array if none
    * @see #getBean
    */
   String[] getAliases(String name);
&#125;
    </code></pre> 
</details>

<p>总结：</p>
<p>1、4个获取实例的方法。getBean的重载方法。<br>2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<p>BeanFactory最常见的实现类为XmlBeanFactory，可以从classpath或文件系统等获取资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;classpath.xml&quot;</span>); </span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>



<p><strong>二、 ApplicationContext</strong></p>
<p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</p>
<p>BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： </p>
<p>（1）MessageSource, 提供国际化的消息访问<br>（2）资源访问，如URL和文件<br>（3）事件传播特性，即支持aop特性<br>（4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 </p>
<p>ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。</p>
<p><strong>ApplicationContext的继承关系图:</strong></p>
<img src="/2022/05/26/Spring/70.png" class="" title="img">

<p>ApplicationContext接口方法</p>
<img src="/2022/05/26/Spring/image-20220528111124796.png" class="" title="image-20220528111124796">

<details> 
    <summary>
        <font color=blue>点击查看ApplicationContext源码</font>
    </summary> 
    <pre><code>  
 /**
 * Central interface to provide configuration for an application.
 * This is read-only while the application is running, but may be
 * reloaded if the implementation supports this.
 *
 *  An ApplicationContext provides:
 * <ul>
 * <li>Bean factory methods for accessing application components.
 * Inherited from &#123;@link org.springframework.beans.factory.ListableBeanFactory&#125;.
 * <li>The ability to load file resources in a generic fashion.
 * Inherited from the &#123;@link org.springframework.core.io.ResourceLoader&#125; interface.
 * <li>The ability to publish events to registered listeners.
 * Inherited from the &#123;@link ApplicationEventPublisher&#125; interface.
 * <li>The ability to resolve messages, supporting internationalization.
 * Inherited from the &#123;@link MessageSource&#125; interface.
 * <li>Inheritance from a parent context. Definitions in a descendant context
 * will always take priority. This means, for example, that a single parent
 * context can be used by an entire web application, while each servlet has
 * its own child context that is independent of that of any other servlet.
 * </ul>
 *
 *  In addition to standard &#123;@link org.springframework.beans.factory.BeanFactory&#125;
 * lifecycle capabilities, ApplicationContext implementations detect and invoke
 * &#123;@link ApplicationContextAware&#125; beans as well as &#123;@link ResourceLoaderAware&#125;,
 * &#123;@link ApplicationEventPublisherAware&#125; and &#123;@link MessageSourceAware&#125; beans.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see ConfigurableApplicationContext
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.core.io.ResourceLoader
 */
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;
/**
     * Return the unique id of this application context.
     * @return the unique id of the context, or &#123;@code null&#125; if none
     */
    String getId();
    /**
     * Return a name for the deployed application that this context belongs to.
     * @return a name for the deployed application, or the empty String by default
     */
    String getApplicationName();
    /**
     * Return a friendly name for this context.
     * @return a display name for this context (never &#123;@code null&#125;)
     */
    String getDisplayName();
    /**
     * Return the timestamp when this context was first loaded.
     * @return the timestamp (ms) when this context was first loaded
     */
    long getStartupDate();
    /**
     * Return the parent context, or &#123;@code null&#125; if there is no parent
     * and this is the root of the context hierarchy.
     * @return the parent context, or &#123;@code null&#125; if there is no parent
     */
    ApplicationContext getParent();
    /**
     * Expose AutowireCapableBeanFactory functionality for this context.
     *  This is not typically used by application code, except for the purpose of
     * initializing bean instances that live outside of the application context,
     * applying the Spring bean lifecycle (fully or partly) to them.
     *  Alternatively, the internal BeanFactory exposed by the
     * &#123;@link ConfigurableApplicationContext&#125; interface offers access to the
     * &#123;@link AutowireCapableBeanFactory&#125; interface too. The present method mainly
     * serves as a convenient, specific facility on the ApplicationContext interface.
     *  <b>NOTE: As of 4.2, this method will consistently throw IllegalStateException
     * after the application context has been closed.</b> In current Spring Framework
     * versions, only refreshable application contexts behave that way; as of 4.2,
     * all application context implementations will be required to comply.
     * @return the AutowireCapableBeanFactory for this context
     * @throws IllegalStateException if the context does not support the
     * &#123;@link AutowireCapableBeanFactory&#125; interface, or does not hold an
     * autowire-capable bean factory yet (e.g. if &#123;@code refresh()&#125; has
     * never been called), or if the context has been closed already
     * @see ConfigurableApplicationContext#refresh()
     * @see ConfigurableApplicationContext#getBeanFactory()
     */
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
&#125;
    </code></pre> 
</details>

<p><strong>三、二者区别</strong></p>
<p>不同点：Bean的加载时机</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。<br>应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相同点：</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）</p>
<h2 id="Spring用到的设计模式"><a href="#Spring用到的设计模式" class="headerlink" title="Spring用到的设计模式"></a>Spring用到的设计模式</h2><p>Spring作为一款及其优秀的框架，其代码的编写非常优秀，里面采用了大量的设计模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 这两个接口 来创建 bean 对象。<br>两者对比：</p>
<ul>
<li><p>BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li><p>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，</p>
<p>ApplicationContext 由 BeanFactory 派生而来 ，提供了更多面向实际应用的功能 ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</p>
<h5 id="设置延迟加载的方式："><a href="#设置延迟加载的方式：" class="headerlink" title="设置延迟加载的方式："></a>设置延迟加载的方式：</h5><p>方式1：对单个Bean对象进行延迟加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 例如连接池的延时加载设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;cPool&quot;</span> class=<span class="string">&quot;com.beans.ConnectionPool&quot;</span></span><br><span class="line">      scope=<span class="string">&quot;singleton&quot;</span></span><br><span class="line">      init-method=<span class="string">&quot;init&quot;</span></span><br><span class="line">      destroy-method=<span class="string">&quot;close&quot;</span></span><br><span class="line">      lazy-init=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>通过数据库连接池给我们提供的init方法和 close方法进行设置 指定初始化（类似构造器）到销毁的具体方法。</p>
<p>方式2：对Bean标签集中的所有bean对象都进行延迟加载设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans <span class="keyword">default</span>-lazy-init=<span class="string">&quot;true&quot;</span></span><br><span class="line">    xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;  </span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans   </span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span><br><span class="line">       </span><br><span class="line">    &lt;bean id=<span class="string">&quot;cPool&quot;</span> </span><br><span class="line">			class=<span class="string">&quot;com.beans.ConnectionPool&quot;</span> </span><br><span class="line">			scope=<span class="string">&quot;singleton&quot;</span> </span><br><span class="line">			init-method=<span class="string">&quot;init&quot;</span> </span><br><span class="line">			destroy-method=<span class="string">&quot;destroy&quot;</span>&gt;</span><br><span class="line">	 &lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h5 id="Bean对象的作用域"><a href="#Bean对象的作用域" class="headerlink" title="Bean对象的作用域"></a>Bean对象的作用域</h5><p>Spring中bean对象的默认作用域就是singleton ，创建以后一直存在，除了singleton的作用域，还有其他的作用域。</p>
<ul>
<li>singleton：对于延迟加载，只有在第一次获取bean的时候才会加载这个bean对象，否则直接生成，但都是IOC容器的唯一对象</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>globalSession 用于分布式web开发中，创建的实例绑定全局session对象</li>
</ul>
<p>对于<strong>prototype作用域的bean对象</strong>：</p>
<p>作用域为 prototype 的 bean ，其destroy方法并没有被调用。如果 bean 的 scope 设为prototype时，<strong>当容器关闭时，destroy 方法不会被调用</strong>。对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring不能对一个 prototype bean 的整个生命周期负责：<strong>容器在初&#x2F;始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。</strong> 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。<strong>清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责</strong>（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用）。<br>谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new操作的替代者，任何迟于该时间点的生命周期事宜都得交由<strong>客户端</strong>来处理。<br>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，<strong>Spring只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<p>​																<strong>（Spring容器对prototype作用域的bean对象 ——只管生，不管养）</strong></p>
<p>Spring通过<strong>ConcurrentHashMap</strong>实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;  </span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例    </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//...省略了很多代码  </span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。  </span></span><br><span class="line">                addSingleton(beanName, singletonObject);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将对象添加到单例注册表  </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Spring的注册表</p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。策略模式实际就是一堆算法族的封装。</p>
<p>Spring中策略模式的应用</p>
<p>当bean需要访问资源配置文件时，Spring有两种方式</p>
<p>代码中获取Rescource实例<br>依赖注入<br>第一种方式需要获取rescource资源的位置，代码中耦合性太高，而今我们一直使用注解，依赖注入的方式去获取。这样的话就无需修改程序，只改配置文件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Test&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- 注入资源 --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tmp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:book.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>在依赖注入的过程中，Spring会调用ApplicationContext 来获取Resource的实例。然而，Resource 接口封装了各种可能的资源类型，包括了：UrlResource，ClassPathResource，FileSystemResource等，Spring需要针对不同的资源采取不同的访问策略。在这里，Spring让ApplicationContext成为了资源访问策略的“决策者”。在资源访问策略的选择上，Spring采用了策略模式。当 Spring 应用需要进行资源访问时，它并不需要直接使用 Resource 实现类，而是调用 ApplicationContext 实例的 getResource() 方法来获得资源，ApplicationContext 将会负责选择 Resource 的实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> PathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;book.xml&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>上面的代码中，Spring 将采用和 ApplicationContext 相同的策略来访问资源。即： ApplicationContext 是 ClassPathXmlApplicationContext，则res 就是 ClassPathResource 实例。若将代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>通过使用修饰模式，可以在运行时扩充一个类的功能。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//根据指定的bean使用对应的侧脸创建新的实例，如工厂方法，构造函数自动注入，简单初始化</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。如下图所示：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYW84MjE=,size_16,color_FFFFFF,t_70.jpeg" class="" title="img">

<p>当然你也可以使用AspectJ，Spring AOP已经继承了AspectJ,AspectJ应该算的上是java生态系统中最完整的AOP框架了。</p>
<p>Spring AOP和AspectJ AOP有什么区别？</p>
<p>Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作。</p>
<p>Spring AOP已经集成了AspectJ，AsectJ应该算的上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单，如果我们的切面比较少，那么两者的性能差异不大。但是当切面太多的话，最好选择AspectJ，它比Spring AOP快很多。</p>
<p><a href="https://blog.csdn.net/u012285269/article/details/122022182?spm=1001.2101.3001.6650.16&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-122022182-blog-107554411.pc_relevant_paycolumn_v3&utm_relevant_index=18">(20条消息) 关于Jdk的Proxy与CGLib的理解_臧馆长的博客-CSDN博客_jdk proxy 和cglib</a></p>
<p><a href="https://www.cnblogs.com/resentment/p/5742661.html">CGLib与JDKProxy的区别 - resentment - 博客园 (cnblogs.com)</a></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变一个算法的结构即可重定义该算法的默写特定步骤的实现方式。</p>
<p>还有很多设计模式 就不详细写了 下面解析源码的时候将设计模式和spring的加载流程串联到一起。</p>
<h2 id="Bean对象的生命周期"><a href="#Bean对象的生命周期" class="headerlink" title="Bean对象的生命周期"></a>Bean对象的生命周期</h2><p>上面我们已经提到过Bean对象的作用域了，现在我们谈一谈Bean对象从被创建到消亡的过程。（就像一个人的一生一样，更应该着重看人的一生的意义，而不是出生和死亡。）</p>
<p>该位置也是从进入容器开始实例化 到bean对象被销毁的对应位置：</p>
<img src="/2022/05/26/Spring/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI0NjUxOA==,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p>再通过调用的方法名来进行区域的划分：</p>
<img src="/2022/05/26/Spring/bean%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16537349916045.png" class="" title="bean对象生命周期">

<p>主要分为四大阶段：</p>
<ul>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ul>
<p><strong>生命周期执行的过程如下:</strong></p>
<ol>
<li>spring对bean进行实例化,默认bean是单例<strong>singleton</strong>作用域</li>
<li>spring对bean进行依赖注入</li>
<li>如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来</li>
<li>如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入</li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法</li>
<li>如果bean实现了<strong>InitializingBean</strong>接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用</li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法</li>
<li>此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁</li>
<li>若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用</li>
</ol>
<p><strong>关于initializingbean</strong></p>
<p><a href="https://juejin.cn/post/6964604073223913509">Spring InitializingBean 接口都不知道，源码你还是缓缓吧… - 掘金 (juejin.cn)</a></p>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h3><p>spring依赖注入有三种方式</p>
<h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><h4 id="Spring事务分类"><a href="#Spring事务分类" class="headerlink" title="Spring事务分类"></a>Spring事务分类</h4><p><strong>编程式事务</strong>:允许用户在实现代码中使用显式的方式调用beginTransaction()开启事务、commit()提交事务、rollback()回滚事务，从而可以达到精确定义事务的边界。</p>
<p><strong>声明式事务管理</strong>:底层是建立在Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。声明式事务的最大优点就是不需要编程，将事务管理从复杂业务逻辑中抽离，只需要在配置文件中配置并在目标方法上添加**@Transactional**注解即可实现。</p>
<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager,关系图如下</p>
<img src="/2022/05/26/Spring/webp.webp" class="" title="img">

<h4 id="Spring事务的传播属性"><a href="#Spring事务的传播属性" class="headerlink" title="Spring事务的传播属性"></a>Spring事务的传播属性</h4><ol>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRED)</strong></p>
<p>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)</strong></p>
<p>容器不为这个方法开启事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)</strong></p>
<p>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行旧的事务</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.MANDATORY)</strong></p>
<p>必须在一个已有的事务中执行,否则抛出异常</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.NEVER)</strong></p>
<p>必须在一个没有的事务执行,否则抛出异常(与Propagation.MANDATORY相反)</p>
</li>
<li><p><strong>@Transactional(propagation&#x3D;Propagation.SUPPORTS)</strong></p>
<p>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他  bean没有声明事务,那就不用事务.</p>
</li>
</ol>
<h4 id="Spring事务注意事项"><a href="#Spring事务注意事项" class="headerlink" title="Spring事务注意事项"></a>Spring事务注意事项</h4><ol>
<li>在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。</li>
<li>@Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。</li>
<li>注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。</li>
<li>通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。</li>
<li>Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</li>
<li>@Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</li>
</ol>
<h4 id="Spring事务超时时间"><a href="#Spring事务超时时间" class="headerlink" title="Spring事务超时时间"></a>Spring事务超时时间</h4><ol>
<li>TransactionDefinition 接口中定义了1个表示超时时间的常量**TIMEOUT_DEFAULT **，使用getTimeout()方法可以获取到超时时间，单位是秒。Spring事务超时时间，是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在Spring程序中超时时间设置的注解方式是设置timeout的值表示这个事务，true只读取数据但不更新数据，false表示可正常读写数据</li>
<li>**@Transactional(timeout&#x3D;30)**默认是-1，不超时</li>
</ol>
<p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/5846416.html">Spring系列之beanFactory与ApplicationContext - 平凡希 - 博客园 (cnblogs.com)</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/9a5acbf54b91">Spring-事务机制 - 简书 (jianshu.com)</a></p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_38246518/article/details/106131083">https://blog.csdn.net/weixin_38246518/article/details/106131083</a></p>
<p>原文链接：<a href="https://blog.csdn.net/chao821/article/details/92400186">https://blog.csdn.net/chao821/article/details/92400186</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/139f813fca80">Spring源码(七)-IOC中的那些设计模式 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/05/28/SpringBoot/</url>
    <content><![CDATA[<p>官网：<a href="https://spring.io/projects/spring-boot">Spring Boot</a></p>
<img src="/2022/05/28/SpringBoot/v2-704d04346a5e35b9bd3a4923732a589d_180x120.jpg" class="" title="查看源图像">

<h1 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h1><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<p>Spring Boot 集成了大量常用的第三方库配置，Spring Boot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p>
<span id="more"></span>

<h1 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h1><p>Spring Boot 项目创建完成后，即使不进行任何的配置，也能够顺利地运行，这都要归功于 Spring Boot 的自动化配置。</p>
<p>Spring Boot 默认使用 application.properties 或 application.yml 作为其全局配置文件，我们可以在该配置文件中对各种自动配置属性（server.port、logging.level.* 、spring.config.active.no-profile 等等）进行修改，并使之生效，那么您有没有想过这些属性是否有据可依呢？答案是肯定的。</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#application-properties">Spring Boot 官方文档：常见应用属性</a>中对所有的配置属性都进行了列举和解释，我们可以根据官方文档对 Spring Boot 进行配置，但 Spring Boot 中的配置属性数量庞大，仅仅依靠官方文档进行配置也十分麻烦。我们只有了解了 Spring Boot 自动配置的原理，才能更加轻松熟练地对 Spirng Boot 进行配置。本节为你揭开 SpringBoot 自动配置的神秘面纱。</p>
<h2 id="Spring-Factories-机制"><a href="#Spring-Factories-机制" class="headerlink" title="Spring Factories 机制"></a>Spring Factories 机制</h2><p>Spring Boot 的自动配置是基于 Spring Factories 机制实现的。</p>
<p>Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。</p>
<p><a href="https://www.jianshu.com/p/00e49c607fa1">Spring Factories - 简书 (jianshu.com)</a></p>
<h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key&#x3D;vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Factories-实现原理"><a href="#Spring-Factories-实现原理" class="headerlink" title="Spring Factories 实现原理"></a>Spring Factories 实现原理</h3><p>spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF&#x2F;spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><T> List<T></td>
<td>loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)</td>
<td>静态方法； 根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。</td>
</tr>
<tr>
<td>List<String></td>
<td>loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</td>
<td>公共静态方法； 根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表</td>
</tr>
</tbody></table>
<p>以上两个方法的关键都是从指定的 ClassLoader 中获取 spring.factories 文件，并解析得到类名列表。</p>
<p>loadFactories() 方法能够获取指定接口的实现类对象</p>
<p>loadFactoryNames() 方法能够根据接口获取其实现类类名的集合。</p>
<h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h3><p>所有 Spring Boot 项目的主启动程序类上都使用了一个 @SpringBootApplication 注解，该注解是 Spring Boot 中最重要的注解之一 ，也是 Spring Boot 实现自动化配置的关键。 </p>
<p>@SpringBootApplication 是一个组合元注解，其主要包含两个注解：@SpringBootConfiguration 和 @EnableAutoConfiguration，其中 @EnableAutoConfiguration 注解是 SpringBoot 自动化配置的核心所在。</p>
<img src="/2022/05/28/SpringBoot/image-20220529152015019.png" class="" title="image-20220529152015019">

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@<strong>ComponentScan</strong></h3><p>@ComponentScan主要就是定义<strong>扫描的路径</strong>从中找出标识了<strong>需要装配</strong>的类自动装配到spring的bean容器中</p>
<p>@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个<strong>共同的注解@Component</strong></p>
<img src="/2022/05/28/SpringBoot/image-20220529153202827.png" class="" title="image-20220529153202827">



<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>@ConfigurationProperties 注解的作用，是将这个类的所有属性与配置文件中相关的配置进行绑定，以便于获取或修改配置，但是 @ConfigurationProperties 功能是由容器提供的，被它注解的类必须是容器中的一个组件，否则该功能就无法使用。而 @EnableConfigurationProperties 注解的作用正是将指定的类以组件的形式注入到 IOC 容器中，并开启其 @ConfigurationProperties 功能。因此，@ConfigurationProperties + @EnableConfigurationProperties 组合使用，便可以为 XxxProperties 类实现配置绑定功能。</p>
<h2 id="自动配置的生效和修改"><a href="#自动配置的生效和修改" class="headerlink" title="自动配置的生效和修改"></a>自动配置的生效和修改</h2><p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 Spring Boot 中以 @Conditional 派生注解的形式体现，如下表。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>生效条件</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>应用使用指定的 Java 版本时生效</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定的 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足指定的 SpEL 表达式时生效</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>不存在指定的类时生效</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定属性存在指定的值时生效</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下存在指定的资源文件时生效</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前应用是 web 应用时生效</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前应用不是 web 应用生效</td>
</tr>
</tbody></table>
<p><a href="http://c.biancheng.net/spring_boot/auto-config.html">Spring Boot自动配置原理 (biancheng.net)</a></p>
<h1 id="Spring-boot-starter-web（Web启动器）"><a href="#Spring-boot-starter-web（Web启动器）" class="headerlink" title="Spring-boot-starter-web（Web启动器）"></a>Spring-boot-starter-web（Web启动器）</h1><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。</p>
<p>Spring Boot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 Spring MVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。</p>
<p>只要我们在 Spring Boot 项目中的 pom.xml 中引入了 spring-boot-starter-web ，即使不进行任何配置，也可以直接使用 Spring MVC 进行 Web 开发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Spring-Boot拦截器"><a href="#Spring-Boot拦截器" class="headerlink" title="Spring Boot拦截器"></a>Spring Boot拦截器</h1><p>&#x2F;&#x2F;TODO</p>
<h1 id="Spring-Boot-中的监视器"><a href="#Spring-Boot-中的监视器" class="headerlink" title="Spring Boot 中的监视器"></a><strong>Spring Boot</strong> <strong>中的监视器</strong></h1><h1 id="Spring-Boot-热加载"><a href="#Spring-Boot-热加载" class="headerlink" title="Spring Boot 热加载"></a><strong>Spring Boot</strong> 热加载</h1>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/05/28/SpringMVC/</url>
    <content><![CDATA[<img src="/2022/05/28/SpringMVC/image-20220528102032212.png" class="" title="image-20220528102032212">

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>Write blog using markdown01</title>
    <url>/2022/05/07/Write-blog-using-markdown01/</url>
    <content><![CDATA[<h4 id="预览界面"><a href="#预览界面" class="headerlink" title="预览界面"></a>预览界面</h4><p><strong>hexo g</strong><br><strong>hexo s</strong></p>
<h4 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h4><p><em>hexo clean</em><br><em>hexo g</em><br><em>hexo d</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>[md文档教程]<a href="https://www.imooc.com/wiki/markdownlesson/markdownlink.html">14 Markdown 超链接丨慕课网教程 (imooc.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>equals()与HashCode()的爱恨情仇</title>
    <url>/2022/05/12/equals-%E4%B8%8EHashCode%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
    <content><![CDATA[<h4 id="‘-x3D-x3D-’和equals"><a href="#‘-x3D-x3D-’和equals" class="headerlink" title="‘&#x3D;&#x3D;’和equals"></a>‘&#x3D;&#x3D;’和equals</h4><p>“&#x3D;&#x3D;”运算符用来比较两个变量的值是否相等。也就是说，该运算符用于比较变量对应的内存中所存储的数值是否相同。</p>
<p>对于基本数据类而言，可以直接使用“&#x3D;&#x3D;”运算符来比较其对应的值是否相等。但是对于引用类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure>

<p>此时的两个引用变量所对应内存中存储的数值就是对象占用的那块内存的首地址。如果要比较两个对象的是否是同一个对象，</p>
<p>则可以使用”&#x3D;&#x3D;“，如果要比较两个对象的内容是否相同，则不可以使用”&#x3D;&#x3D;“实现了。</p>
<p>equals是Object类提供的方法之一。每一个Java类都集成自Object类，所以每一个对象都具有equals这个方法。</p>
<p>相比“&#x3D;&#x3D;”运算符，equals(Object)方法的特殊之处就在于它可以被覆盖，所以可以通过覆盖的方法让它不是比较引用而是比较数据内容。</p>
<p>那么equals()是如何比较引用类型的内容的？</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//		generate生成的equals和hashcode</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (Human) o;</span><br><span class="line">            <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= human.age &amp;&amp;</span><br><span class="line">                    Objects.equals(name, human.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashCode和equals"><a href="#HashCode和equals" class="headerlink" title="HashCode和equals"></a>HashCode和equals</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整 数。这个哈希码的作用是</p>
<p>确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何</p>
<p>类都包含有hashCode()函数.</p>
<h4 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals() 的相关规定"></a><strong>hashCode()<strong>与</strong>equals()</strong> <strong>的相关规定</strong></h4><p>如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返</p>
<p>回true 两个对象有相同的hashcode值，它们也不一定是相等的</p>
<h4 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h4><p>第一种 不会创建“类对应的散列表”<br> 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”没有关系。<br> 这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p>
<p>第二种 会创建“类对应的散列表”<br> 这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。<br> 在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：<br> 1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br> 这里的相等是指，通过equals()比较两个对象时返回true。<br> 2)、如果两个对象hashCode()相等，它们并不一定相等。<br> 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。<br> 此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/05/16/git/</url>
    <content><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><img src="/2022/05/16/git/image-20220516150930144.png" class="" title="image-20220516150930144">

<ul>
<li><p>workspace：工作区</p>
</li>
<li><p>staging area：暂存区&#x2F;缓存区</p>
</li>
<li><p>local repository：版本库或本地仓库</p>
</li>
<li><p>remote repository：远程仓库</p>
<span id="more"></span></li>
</ul>
<p>合作开发第一个项目的时候 就感觉到git的强大 同时也被git上了一课 多版本的来回混合 以及多个操作 搞得有点乱 从空间和操作命令上来结合了解以下git到底如何使用 执行命令后哪里的代码跑到哪里了？</p>
<p>首先要初始化一个仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git add .    </span><br><span class="line">$ git commit  </span><br></pre></td></tr></table></figure>

<p>创建分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch (branchname) //不加名字 为查看分支</span><br></pre></td></tr></table></figure>

<p>切换分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure>

<p>合并分支：</p>
<p>需要先切换到主分支下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge (想要合并的分支)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/05/20/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="数据库逻辑架构"><a href="#数据库逻辑架构" class="headerlink" title="数据库逻辑架构"></a>数据库逻辑架构</h3><img src="/2022/05/20/mysql/image-20220522131409069.png" class="" title="image-20220522140130072">

<p>1）连接层 Connection Pool</p>
<p>系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证</p>
<p><strong>TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池</strong></p>
<h4 id="连接池（线程池）"><a href="#连接池（线程池）" class="headerlink" title="连接池（线程池）"></a>连接池（线程池）</h4><p>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。</p>
<span id="more"></span>

<details>
<summary>点击查看线程池详细内容</summary>
<b>为什么使用连接池？</b><br>
对于数据库建立连接对象，对应一个实际的物理连接，每次使用都打开一个连接，再关闭一个连接，这样会造成书库的性能低下。解决方案是，应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池**(简单说：在一个“池”里放了好多半成品的数据库联接对象)**，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。这样一来，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率。<br>
<b>不使用连接池 执行一条sql的过程：</b><br><br>
<img src="mysql/image-20220522133151857.png" alt="image-20220522133151857" style="zoom:80%;" />
<br>
1. TCP建立连接的三次握手<br>
2. MySQL认证的三次握手<br>
3. 真正的SQL执行<br>
4. MySQL的关闭<br>
5. TCP的四次握手关闭<br>
<b>使用连接池 执行一条sql的过程：</b><br>
<img src="/2022/05/20/mysql/image-20220522133456976.png" class="" title="image-20220522133456976"><br>
第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。<br>
<b>线程池工作的原理</b><br>
建立连接 管理链接 删除连接 
第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。<br>
第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：<br>
当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>
当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。<br>
第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。
<b>主流的几个连接池</b>
数据库连接池有三种：</b>
1、DBCP:</b>
DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。</b>
2、C3P0:</b>
c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。</b>
3、Druid:</b>
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个 SQL Parser。</b>
支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。</b>
Druid针对Oracle和MySql做了特别优化，比如Oracle的PS Cache内存占用优化，MySql的ping检测优化。</b>
Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。</b>
简单SQL语句用时10微秒以内，复杂SQL用时30微秒。通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。</b>
Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析语义实现的。</b>
<img src="/2022/05/20/mysql/image-20220522134845235.png" class="" title="image-20220522134845235"></b>
参考链接
原文链接：https://blog.csdn.net/weixin_43871678/article/details/116571499</b>
原文链接：https://blog.csdn.net/CrankZ/article/details/82874158</b>
</details>
2）服务层 

<p><strong>SQL Interface: SQL</strong> <strong>接口</strong></p>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL </p>
<p>Interface </p>
<p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定</p>
<p>义函数等多种SQL语言接口</p>
<p><strong>Parser:</strong> <strong>解析器</strong></p>
<p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构</p>
<p>传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错</p>
<p>误，那么就说明这个SQL语句是不合理的。</p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字</p>
<p>典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还</p>
<p>会对SQl查询进行语法上的优化，进行查询重写。 </p>
<p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行</p>
<p>计划 。<strong>这个执行计划表明应该 使用哪些索引 进行查询</strong>（全表检索还是使用索引检索），表之间的连</p>
<p>接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将</p>
<p>查询结果返回给用户。</p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过</p>
<p>滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过</p>
<p>滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
<p><strong>Caches &amp; Buffers</strong> <strong>： 查询缓存组件</strong></p>
<p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结</p>
<p>果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过</p>
<p>程了，直接将结果反馈给客户端。</p>
<p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p>
<p>这个查询缓存可以在 不同客户端之间共享 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </p>
<p>3）引擎层 </p>
<p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了<strong><strong>MySQL</strong></strong>中数据的存储和提取，对物理服务器级别</strong></p>
<p><strong>维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样</p>
<p>我们可以根据自己的实际需要进行选取。</p>
<img src="/2022/05/20/mysql/image-20220522140130072.png" class="" title="image-20220522140130072">

<p>4 )存储层</p>
<p>作为数据真正的物理存储位置，所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存</p>
<p>在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。</p>
<p>特别注意MyISAM存储文件后缀为—– .myd(数据) 和.myi (索引) </p>
<p>Innodb的索引和数据是集中存储的 —– .ibd</p>
<p><strong>整个执行流程</strong></p>
<img src="/2022/05/20/mysql/image-20220522141658938.png" class="" title="image-20220522141658938">


<p><strong>数据库三大范式是什么</strong></p>
<p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我</p>
<p>们经常会为了性能而妥协数据库的设计。</p>
<h3 id="两大存储引擎"><a href="#两大存储引擎" class="headerlink" title="两大存储引擎"></a>两大存储引擎</h3><img src="/2022/05/20/mysql/image-20220520170817159.png" class="" title="image-20220520170817159">

<img src="/2022/05/20/mysql/image-20220520170840162.png" class="" title="image-20220520170840162">

<h3 id="数据库中索引的存储结构"><a href="#数据库中索引的存储结构" class="headerlink" title="数据库中索引的存储结构"></a>数据库中索引的存储结构</h3><p>索引的存在 就是为了减少磁盘的IO次数 增加读取的效率 </p>
<p><strong>什么是索引</strong>：MySQL官方对索引的定义为：<strong>索引（</strong>Index<strong>）是帮助</strong>MySQL<strong>高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。</p>
<p>这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<p><strong>优点</strong>：1 ）提高数据检索的效率，降低 数据库的IO成本</p>
<p>​			2 ）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</p>
<p>​			3）在实现数据的参考完整性方面，可以 加速表和表之间的连接 。</p>
<p>​			4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</p>
<p><strong>缺点</strong>：</p>
<p><strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会</p>
<p>占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<p><strong>时间上的代价</strong>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每</p>
<p>层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还</p>
<p>是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序</p>
<p>而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需</p>
<p>要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果</p>
<p>我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿</p>
<h3 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h3><h3 id="设计索引和数据的存储形式"><a href="#设计索引和数据的存储形式" class="headerlink" title="设计索引和数据的存储形式"></a>设计索引和数据的存储形式</h3><p>当我们使用命令创建一个表的时候 数据会以特定的形式存在于表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test(</span><br><span class="line">	number int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">)ROW_FORMAT = Compact;//指定行格式</span><br></pre></td></tr></table></figure>

<p>行数据究竟怎么存储的？Compact的行格式:</p>
<img src="/2022/05/20/mysql/1097754-20210719234605417-2013635397.png" class="" title="img">

<p>DB_ROW_ID(row_id)  如果表中没有显式定义主键列，mysql会默认生成一个row_id作为隐式主键，且row_id是全局概念，每一次有一行新数据insert，都会获取Max Row ID再加1就形成了一个新的row_id<br>DB_TRX_ID    事务有关，跟回滚指针有关，6个字节<br>DB_ROLL_PTR  事务有关，跟回滚指针有关， 7个字节</p>
<p>delete mask : 标记为是否被delete语句commit，也就是mysql不会真正物理删除一行记录，在页面上重新组装一个新链表，称为垃圾链表，如果垃圾链表占用空间可重用的话就会重用。</p>
<p>record type：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过。</p>
<p>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>
<img src="/2022/05/20/mysql/image-20220523095656639.jpg" class="" title="image-20220523095656639">

<p>从数据的连接角度来简略展示行数据 每一行数据如此 那么把多数的数据连接起来呢？</p>
<img src="/2022/05/20/mysql/image-20220523095757181.jpg" class="" title="image-20220523095757181">

<p>多行数据进行连接 形成一个页 每一页存放多行数据 页的第一个位置和最后一个位置不存放数据 用来表示该页的最小记录和最大记录。</p>
<p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<img src="/2022/05/20/mysql/image-20220523100525991.jpg" class="" title="image-20220523100525991">

<p>在根据该页的最小记录和最大记录 将每一页的位置进行定位</p>
<p><strong>InnoDB中的索引方案</strong> </p>
<p><strong>① 迭代1次：目录项纪录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101301936.jpg" class="" title="image-20220523101301936">



<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101831703.jpg" class="" title="image-20220523101831703">



<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<img src="/2022/05/20/mysql/image-20220523101951740.jpg" class="" title="image-20220523101951740">

<p><strong>④</strong> <strong>B+Tree</strong></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。</p>
<p>之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页最多存放4条记录 。其实</p>
<p>真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，</p>
<p>所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：</p>
<ul>
<li><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</p>
</li>
<li><p>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</p>
</li>
<li><p>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</p>
</li>
<li><p>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！！！</p>
</li>
</ul>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值</p>
<p>查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 </p>
<p>Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</p>
<h3 id="索引的类型和特点"><a href="#索引的类型和特点" class="headerlink" title="索引的类型和特点"></a>索引的类型和特点</h3><p><strong>1.聚簇索引</strong></p>
<p>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据；</p>
<p>主键索引是聚簇索引的一种</p>
<p>通常情况下 我们使用主键作为自增的唯一id 但是如果没有主键 那么会默认使用row_id作为主键 </p>
<p>1）使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<p><strong>页内的记录</strong>是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</p>
<p>各个 <strong>存放用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个<strong>双向链表</strong> 。</p>
<p><strong>存放目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。 </p>
<p>2）B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p><strong>2.非聚簇索引</strong></p>
<p>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。简单理解：在聚簇索引上建立的索引就是非聚簇索引。</p>
<p>在innodb中，在聚簇索引上建立的都是辅助索引，即非聚簇索引也叫辅助索引。一张表中只能有一个聚簇索引。其余索引都是非聚簇索引。辅助索引叶子节点存储的是主键值，访问数据总是要先查到主键值，再通过主键值访问到数据。即辅助索引访问数据总是需要二次查找 通常也成为回表</p>
<p><strong>回表：</strong></p>
<p>我们根据某个列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据该列的值查找到完整的用户记录的话，</p>
<p>仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据非聚簇索引列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方想让books的书籍编号字段和价格字段索引联合创建</p>
<p>索引的索引：首先按照书籍编号进行排序 然后在书籍编号的基础上按照价格进行排序。</p>
<p>InnoDB和MyISAM</p>
<p>InnoDB的B+树索引的注意事项</p>
<p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>
<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><h4 id="哪些字段适合创建索引"><a href="#哪些字段适合创建索引" class="headerlink" title="哪些字段适合创建索引"></a>哪些字段适合创建索引</h4><p><strong>1.字段的数值具有唯一性的限制</strong></p>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
<p><strong>2.频繁作为Where查询字段的字段</strong></p>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在</p>
<p>数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p><strong>3.经常GroupBy和Order BY的字段</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者</p>
<p>使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多</p>
<p>个，那么可以在这些列上建立 组合索引 。 </p>
<p><strong>4.UPDATE,DELETE 的WHERE条件列</strong></p>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就</p>
<p>能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或</p>
<p>删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更</strong></p>
<p><strong>新不需要对索引进行维护。</strong></p>
<p><strong>在实际情况中 还有多种情景适合创建索引 凡是需要重复在聚簇索引中查找某一个列的字段 都可以创建索引</strong></p>
<h4 id="哪些字段不适合创建索引"><a href="#哪些字段不适合创建索引" class="headerlink" title="哪些字段不适合创建索引"></a>哪些字段不适合创建索引</h4><p>1.在where中使用不到的字段，不要设置索引</p>
<p>2.数据量小的表最好不要使用索引</p>
<p>3.有大量重复数据的列上不要建立索引  比如男性女性这种很高几率重复的字段</p>
<p>4.避免对经常更新的表进行索引的创建</p>
<p>5.不建议使用无序的列作为索引</p>
<p>6.不要定义重复和冗余的索引</p>
<h2 id="数据库的调优策略"><a href="#数据库的调优策略" class="headerlink" title="数据库的调优策略"></a>数据库的调优策略</h2><p>&#x2F;&#x2F;TODO</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在数据库中事务是什么</p>
<p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务处理原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><strong>原子性（atomicity）：</strong></p>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
<p><strong>一致性（</strong>consistency<strong>）：</strong></p>
<p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<strong>Consistency</strong>的阐述）</p>
<p>根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态</p>
<p>是 语义上 的而不是语法上的，跟具体的业务有关。</p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己</p>
<p>来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就</p>
<p>是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作</p>
<p>之前的状态。</p>
<p><strong>隔离型（</strong>isolation<strong>）：</strong>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的</p>
<p>其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p><strong>持久性（</strong>durability<strong>）：</strong>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h4 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h4><p>显示事务：手动开启事务 begin 或 start transaction</p>
<p>隐式事务：MySql中有一个系统变量autocommit </p>
<img src="/2022/05/20/mysql/image-20220523195028484.jpg" class="" title="image-20220523195028484">

<p>该变量设置数据库执行语句是否自动提交 可以将该变量设置为不自动提交 </p>
<img src="/2022/05/20/mysql/image-20220523195555772.png" class="" title="image-20220523195555772">

<h4 id="数据库并发和隔离级别"><a href="#数据库并发和隔离级别" class="headerlink" title="数据库并发和隔离级别"></a>数据库并发和隔离级别</h4><p>事务的四种并发问题：</p>
<p><strong>1.脏写（ Dirty Write ）</strong>：</p>
<p>对于SessionA和SessionB 如果SessionA修改了另一个未提交事务SessionB修改过的数据 ，那就意味着脏写</p>
<p><strong>2.脏读（ Dirty Read）：</strong></p>
<p>SessionA已经读取了SessionB更新但还没有被提交到的字段，之后若SessionB回滚，SessionA读到的数据并不是真实数据，该数据就是临时且无效的脏读数据。</p>
<p><strong>3.不可重复读（Non</strong>-<strong>Repeatable Read）：</strong></p>
<p>SessionA开启事务并读取数据，但是此时SessionB将数据修改并提交，SessionA再查看数据值不同了，就意味着出现了不可重复读。</p>
<p><strong>4.幻读（Phantom）</strong>：</p>
<p>两个事务SessionA，SessionB SessionA从表中读取了一个字段后，SessionB向表中插入了一些新的行，之后，如果SessionA再次读取同一个表，就会出现几条新的数据（幻影记录），我们称之为幻读。</p>
<p>对于这四种现象 按照严重程度：</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>分别对应四种隔离级别：</p>
<p><strong>1.READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</p>
<p>不能避免脏读、不可重复读、幻读。</p>
<p><strong>2.READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>3.REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，</p>
<p>读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</p>
<p>4.<strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、</p>
<p>更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
<p>一张图：</p>
<img src="/2022/05/20/mysql/image-20220523201143065.jpg" class="" title="image-20220523201143065">

<p>8.0.29的隔离级别</p>
<img src="/2022/05/20/mysql/image-20220523201736656.jpg" class="" title="image-20220523201736656">

<h3 id="数据库事务日志"><a href="#数据库事务日志" class="headerlink" title="数据库事务日志"></a>数据库事务日志</h3><p>事务的四种特性是基于什么实现的？ </p>
<p><strong>隔离性</strong>根据<strong>锁机制</strong>实现</p>
<p>事务的<strong>原子性，一致性和持久性</strong>由事务的<strong>redo日志和undo日志</strong>保证</p>
<p>REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</p>
<p>UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p>
<h4 id="为什么使用日志？"><a href="#为什么使用日志？" class="headerlink" title="为什么使用日志？"></a>为什么使用日志？</h4><h4 id="REDO日志"><a href="#REDO日志" class="headerlink" title="REDO日志"></a>REDO日志</h4><p>一方面 缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然</p>
<p>而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情</p>
<p>况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面 由于数据库具有持久性的特点 就是说 对于一个已经提交的事务，再提交事务后即使发生了宕机或其他</p>
<p>突发意外而奔溃，这个数据库所修改的数据也不会丢失。就使用到了日志，因为在每次提交事务的时候，我们都没必要去刷新一下磁盘，</p>
<p>只需要记录一下哪些数据修改了就好。这就是redo日志。</p>
<img src="/2022/05/20/mysql/image-20220524201029477.jpg" class="" title="image-20220524201029477">

<h4 id="REDO日志的优点和特点"><a href="#REDO日志的优点和特点" class="headerlink" title="REDO日志的优点和特点"></a>REDO日志的优点和特点</h4><p>优点																											特点</p>
<p>降低了磁盘的刷新次数																			redo日志是顺序写入磁盘的			</p>
<p>redo日志占用空间小																				事务执行的过程中 redo log 不断记录</p>
<p>redolog分为以下两个部分</p>
<p>1.重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</p>
<p>2.重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</p>
<p>redo log buffer 和 redo log file</p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p>
<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p>
<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 </p>
<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<img src="/2022/05/20/mysql/image-20220524212211626.png" class="" title="image-20220524212211626">

<h4 id="REDO日志的刷盘策略"><a href="#REDO日志的刷盘策略" class="headerlink" title="REDO日志的刷盘策略"></a>REDO日志的刷盘策略</h4><p>redolog不是直接写入到磁盘当中的 而是先写入到redologbuffer  然后再以一定频率 写入到redologfile 这里的频率就涉及到了刷盘策略：</p>
<p>redologbuffer 刷盘到 redologfile 中并不是真正的写入到磁盘 只是刷入到 文件系统缓存（page cache） 中 （操作系统对写入文件的一个</p>
<p>优化策略）真正的写入时机会交给系统去操作 这里就涉及到了如果系统出现宕机等问题 那么数据库则没有保证持久性 。</p>
<p>此处可以设置刷盘策略的参数 innodb_flush_log_at_trx_commit ：</p>
<p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p>
<p>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </p>
<p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p>
<h4 id="UNDO日志"><a href="#UNDO日志" class="headerlink" title="UNDO日志"></a>UNDO日志</h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 更新数据 的 前置操作 其实是要先写入一个 undo log 。 </p>
<h5 id="UNDO日志的理解"><a href="#UNDO日志的理解" class="headerlink" title="UNDO日志的理解"></a>UNDO日志的理解</h5><p>为了保证数据可以回滚到出现问题或执行事务失败之前的数据状态 使用undo日志记录事务开始前的一个数据状态</p>
<h5 id="UNDO日志的作用"><a href="#UNDO日志的作用" class="headerlink" title="UNDO日志的作用"></a>UNDO日志的作用</h5><p> 1.回滚 2.MVCC</p>
<h5 id="回滚段和undo页"><a href="#回滚段和undo页" class="headerlink" title="回滚段和undo页"></a>回滚段和undo页</h5><p>InnoDB对undo log的管理采用段的方式，也就是 回滚段（rollback segment） 。每个回滚段记录了1024 个 undo log segment ，而在</p>
<p>每个undo log segment段中进行 undo页 的申请。</p>
<p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用</p>
<p>来说都已经够用。从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 。</p>
<p>回滚段中的数据分类：</p>
<ol>
<li><p>未提交的回滚数据(uncommitted undo information) </p>
</li>
<li><p>已经提交但未过期的回滚数据(committed undo information) </p>
</li>
<li><p>事务已经提交并过期的数据(expired undo information)</p>
</li>
</ol>
<p>查看undo日志参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_undo%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525100351318.png" class="" title="image-20220525100351318">

<p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<p>将undo log放入列表中，以供之后的purge操作</p>
<p>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</p>
<p><strong>undo日志的类型</strong></p>
<p>1.insert undo log</p>
<p>2.update undo log</p>
<p>redolog 和 undolog 在数据库中的使用：</p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</p>
<img src="/2022/05/20/mysql/image-20220525101151835.png" class="" title="image-20220525101151835">



<p>undolog 回滚或回复数据库状态 并不是根据一开始的状态 把新数据进行update覆盖操作 而是生成一个undolog链表</p>
<p><strong>undo日志从对数据进行修改到回滚到事务执行之前的状态的过程：</strong></p>
<p>看一下compact数据行格式</p>
<img src="/2022/05/20/mysql/image-20220525101954686.png" class="" title="image-20220525101954686">

<ol>
<li><p>row_id:如果没有主键,unique的列,那么就会自动添加一个row_id行号.</p>
</li>
<li><p>trx_id:谁对该条记录最近一次修改就会记录某个事务的ID.</p>
</li>
<li><p>roll_pointer:一个指向该条记录修改对应的undo日志的指针.</p>
<p>开始修改事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into user(name) values (&#x27;tom&#x27;);</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102303992.jpg" class="" title="image-20220525102303992">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set name=&#x27;Sun&#x27; where id=1;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102439823.jpg" class="" title="image-20220525102439823"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set id=2 where id=1;//设置删除参数deletemark</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/mysql/image-20220525102725176.png" class="" title="image-20220525102725176">

<p>对于这个例子 如果回滚则rollback的流程如下:</p>
<ol>
<li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p>
</li>
<li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p>
</li>
<li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p>
</li>
<li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p>
</li>
</ol>
<p>针对于insert undo log</p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>针对于update undo log </p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>事物的隔离性 通过锁来进行体现</p>
<h3 id="多用户访问数据操作"><a href="#多用户访问数据操作" class="headerlink" title="多用户访问数据操作"></a>多用户访问数据操作</h3><p>1.读-读操作</p>
<p>即并发事务相继读取相同位置数据内容，读数据本身对数据库不会有什么影响</p>
<p>2.写-写操作</p>
<p>在这种情况下可能会出现<strong>脏写</strong>的情况，任何隔离级别都不允许脏写的发生，所以在多个未提交事务相继对一条数据进行改动的时候，</p>
<p>首先会看看内存中有没有与这条记录相关联的锁结构，当没有的时候，就会在内存中生成一个锁结构与之关联。即一个事务对应一个锁结构。</p>
<p>事务T1对这条记录进行修改</p>
<img src="/2022/05/20/mysql/image-20220525144131876.png" class="" title="image-20220525144131876">

<p>事务T2同时想要修改这条记录</p>
<img src="/2022/05/20/mysql/image-20220525144355014.png" class="" title="image-20220525144355014">

<p>3.读-写 或 写-读</p>
<p>当一个事务进行数据读取操作，另一个事务进行改动操作，这种情况下可能发生<strong>脏读，不可重复读，幻读</strong>等问题</p>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>1.MVCC 性能更高</p>
<p>2.读写都进行加锁的方式 性能较低</p>
<h3 id="Mysql中锁的不同种类"><a href="#Mysql中锁的不同种类" class="headerlink" title="Mysql中锁的不同种类"></a>Mysql中锁的不同种类</h3><img src="/2022/05/20/mysql/image-20220525145305850.png" class="" title="image-20220525145305850">

<h3 id="从操作类型分-读锁和写锁"><a href="#从操作类型分-读锁和写锁" class="headerlink" title="从操作类型分 读锁和写锁"></a>从操作类型分 读锁和写锁</h3><p>读锁：又称为共享锁，使用S表示，针对一份数据，多个事务同时进行不会进行阻塞，互相之间不会影响。</p>
<p>写锁：又称为排他锁，使用X表示，当前写操作没有完成之前，会阻断其他事务的读取和写入，这样只要会由一个事务进行操作。</p>
<h3 id="从操作数据的粒度上划分-表级锁，页级锁，行锁"><a href="#从操作数据的粒度上划分-表级锁，页级锁，行锁" class="headerlink" title="从操作数据的粒度上划分 表级锁，页级锁，行锁"></a>从操作数据的粒度上划分 表级锁，页级锁，行锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>1.表级别的X，S锁 </p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 S锁 或者 X锁 的。</p>
<p>在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、</p>
<p>DELETE、UPDATE的语句会生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中</p>
<p>对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通在 server层 使用一种称之为 元数据锁 （英文名： Metadata Locks ，简称 MDL ）结构来实现的。</p>
<p>表锁的并发度太低 也分为表的写锁和读锁	：表共享读锁（Table Read Lock）                    表独占写锁（Table Write Lock） </p>
<img src="/2022/05/20/mysql/image-20220525151404962.png" class="" title="image-20220525151404962">

<p>2.意向锁</p>
<p>InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁 与 表级锁 共存，而<strong>意向锁</strong>就是其中的一种 表锁 。</p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 </span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>EX：开启一个事务 并向其中添加一条数据，在事务中查看意向锁：</p>
<img src="/2022/05/20/mysql/image-20220525152611363.png" class="" title="image-20220525152611363">



<p>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。</p>
<p>3.自增锁</p>
<p>4.元数据锁</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>1.记录锁（Record Locks）</p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。</p>
<p>仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<img src="/2022/05/20/mysql/image-20220525153413146.png" class="" title="image-20220525153413146">

<img src="/2022/05/20/mysql/image-20220525154333587.png" class="" title="image-20220525154333587">

<p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。</p>
<ul>
<li><p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</p>
</li>
<li><p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</p>
</li>
</ul>
<p>2.<strong>间隙锁（Locks）</strong> </p>
<p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方</p>
<p>案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读</p>
<p>取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为</p>
<p>Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条</p>
<p>记录加一个gap锁的示意图如下。</p>
<img src="/2022/05/20/mysql/image-20220525155754456.png" class="" title="image-20220525155754456">

<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是</p>
<p>id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新</p>
<p>记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入</p>
<p>操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<ul>
<li><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。</li>
</ul>
<p>&#x2F;&#x2F;TODO</p>
<h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><img src="/2022/05/20/mysql/image-20220525160130933.png" class="" title="image-20220525160130933">

<ol>
<li>锁所在的事务信息 ：</li>
</ol>
<p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个</p>
<p>事务的信息。</p>
<p>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比</p>
<p>方说事务id等。</p>
<ol start="2">
<li>索引信息 ：</li>
</ol>
<p>对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<ol start="3">
<li>表锁／行锁信息 ：</li>
</ol>
<p>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
<p>行锁：</p>
<p>记载了三个重要的信息：</p>
<p>Space ID ：记录所在表空间。</p>
<p>Page Number ：记录所在页号。</p>
<p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同</p>
<p>的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</p>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
<ol start="4">
<li>type_mode ：</li>
</ol>
<p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</p>
<img src="/2022/05/20/mysql/image-20220525160724571.png" class="" title="image-20220525160724571">

<p><strong>锁的模式（ lock_mode ）</strong>，占用低4位，可选的值如下：</p>
<p>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </p>
<p>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。 </p>
<p>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </p>
<p>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </p>
<p>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。 </p>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<p><strong>锁的类型（ lock_type ）</strong>，占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<p>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</p>
<p>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</p>
<p><strong>行锁的具体类型（ rec_lock_type ）</strong>，使用其余的位来表示。只有在 lock_type 的值为</p>
<p>   LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p>
<ul>
<li><p>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</p>
</li>
<li><p>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </p>
</li>
<li><p>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。</p>
</li>
<li><p>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。</p>
</li>
</ul>
<p>​      其他的类型：还有一些不常用的类型我们就不多说了。</p>
<p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：</p>
<p>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也就是当前事务尚未获取到锁，处在等待状态；</p>
<p>当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>mvcc（Multiversion Concurrency Control）是多版本并发控制，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术</p>
<p>使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们</p>
<p>被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，</p>
<p>也能做到 不加锁 ，非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前读实际上是一种加锁的操作，</p>
<p>是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<p>查看引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<p>查看默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<p>修改默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>创建表时指定存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>修改表的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名 \G;</span><br></pre></td></tr></table></figure>

<p>开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">#或</span><br><span class="line">START transaction 添加的修饰符;（ READ ONLY） （ READ WRITE）</span><br></pre></td></tr></table></figure>

<p>查看数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>修改数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>查看正在等待的锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<p>根据查询到的锁 进行详情的查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>乐观锁和悲观锁</title>
    <url>/2022/05/17/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p><a href="https://zhuanlan.zhihu.com/p/95296289">摘自文章1</a></p>
<p>[摘自文章2](<a href="https://zhuanlan.zhihu.com/p/34556594">面试必问的CAS，你懂了吗？ - 知乎 (zhihu.com)</a>)</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<span id="more"></span>

<p><strong>乐观锁测试</strong></p>
<p>不使用乐观锁的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个例子很简单：我们定义了一个变量a，初始值是0，然后使用5个线程去增加，每个线程增加10，</span></span><br><span class="line"><span class="comment">    按道理来说5个线程一共增加了50，但是运行一下就知道答案不到50，原因就在于里面那个加一操作：</span></span><br><span class="line"><span class="comment">    a++;</span></span><br><span class="line"><span class="comment">    对于a++的操作，其实可以分解为3个步骤。</span></span><br><span class="line"><span class="comment">    （1）从主存中读取a的值</span></span><br><span class="line"><span class="comment">    （2）对a进行加1操作</span></span><br><span class="line"><span class="comment">    （3）把a重新刷新到主存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//一个变量a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//定义5个线程，每个线程加10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(a++);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。<br>​    AtomicInteger的作用就是为了保证原子性。如何保证原子性呢？我们使用案例说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="comment">//使用AtomicInteger定义a</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//使用getAndIncrement函数进行自增操作</span></span><br><span class="line">                        System.out.println(a.incrementAndGet());</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="comment">//CAS</span></span><br><span class="line">    <span class="comment">//getAndIncrement()实现的自增操作是自旋CAS操作：在循环中进行compareAndSet，如果执行成功则退出，否则一直执行。</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；</p>
<p>除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类。</p>
<p>下面看一下AtomicInteger的源码，了解下它的自增操作getAndIncrement()是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe是用来帮助Java访问操作系统底层资源的类（如可以分配内存、释放内存,在netty中大量用到它,属于C++层面的native方法,我们一般使用反射获取），通过Unsafe，Java具有了底层操作能力，可以提升运行效率；</p>
<p>valueOffset可以理解为value在内存中的偏移量，对应了CAS三个操作数(V&#x2F;A&#x2F;B)中的V；偏移量的获得也是通过Unsafe实现的。</p>
<h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><p>CAS操作包括了3个操作数：</p>
<ul>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(A)</li>
<li>拟写入的新值(B)</li>
</ul>
<p>CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p>
<p>这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？</p>
<p>答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p>
<p>但是虽然保证将A值比较 然后转化为B值这一系列操作是原子性的 但是不能确定这个A值就是预期的A值 这就是ABA问题</p>
<p>ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</p>
<p>这时候就需要一个版本号来进行限制。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，</p>
<p>它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>其实大多是的乐观锁是由CAS+版本号进行实现的 但是通过版本号也可以实现乐观锁</p>
<p>和CAS大致思想相同 将想要更改的信息添加一个版本号 在对数据进行修改的时候 首先查询版本号 如果版本号相同 则</p>
<p>继续操作 修改数据 之后再将版本号加1（或者加其他数值，总之是修改版本号）</p>
<p><strong>乐观锁加锁了吗？</strong></p>
<p>1.乐观锁本身是不加锁的，只是在修改数据的时候，判断一下是不是已经被其他线程更新了。</p>
<p>2.有一些乐观锁是加锁合作的，为了保证整个查看版本修改数据然后修改版本的原子性操作，</p>
<p>但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。</p>
<p><strong>乐观锁带来的问题</strong></p>
<p>1.首当其冲的是性能问题，当CAS操作自旋访问的时候，执行getAndAddInt方法时，如果CAS失败，会一直进行尝试。</p>
<p>如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<p>2.安全问题，就是上述的ABA问题，”你以为身边的那么她还是她，其实她早变心了，已经不是以前的那个她了“。</p>
<p>3.共享，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，</p>
<p>循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修</p>
<p>改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲</p>
<p>观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观</p>
<p>锁，如 RetreenLock。</p>
<p>数据库中就经常使用悲观锁以保证数据的安全，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h3 id="悲观锁和乐观锁的使用场景"><a href="#悲观锁和乐观锁的使用场景" class="headerlink" title="悲观锁和乐观锁的使用场景"></a>悲观锁和乐观锁的使用场景</h3><p>乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。</p>
<ul>
<li><strong>功能限制 与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</strong></li>
</ul>
<p>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。</p>
<p>再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p>
<ul>
<li><strong>竞争激烈程度 如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</strong></li>
</ul>
<p>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</p>
<p>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>双重检验锁</title>
    <url>/2022/05/08/%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81/</url>
    <content><![CDATA[<h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> TheClass theclass;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TheClass</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Track <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(TheClass.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(theclass==<span class="literal">null</span>)&#123;</span><br><span class="line">                    theclass=<span class="keyword">new</span> <span class="title class_">TheClass</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theclass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java的多线程和并发"><a href="#Java的多线程和并发" class="headerlink" title="Java的多线程和并发"></a>Java的多线程和并发</h1><p>java的尽头是服务端开发，既然是服务端开发，就需要为多个用户同时进行服务，那么如何保证资源的正常分配或每个用户正常的体验呢？</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>程序（program）</strong></p>
<p>程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码（还没有运行起来），静态对象</p>
<p><strong>进程（process）</strong></p>
<p>进程是程序的一次执行过程，也就是说程序运行起来了，加载到了内存中，并占用了cpu的资源。这是一个动态的过程：有自身的产生、存在和消亡的过程，这也是进程的生命周期。</p>
<p>进程是系统资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</p>
<p><strong>线程（thread）</strong></p>
<p>进程可进一步细化为线程，是一个程序内部的执行路径。</p>
<p>若一个进程同一时间并行执行多个线程，那么这个进程就是支持多线程的。</p>
<p>线程是cpu调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。</p>
<p>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间——&gt; 他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得相互间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全隐患（隐患为到底哪个线程操作这个数据，可能一个线程正在操作这个数据，有一个线程也来操作了这个数据）。</p>
<p><strong>CPU单核和多核的理解</strong></p>
<p><strong>单核</strong>的CPU是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。同时间段内有多个线程需要CPU去运行时，CPU也只能交替去执行多个线程中的一个线程，但是由于其执行速度特别快，因此感觉不出来。</p>
<p><strong>多核</strong>的CPU才能更好的发挥多线程的效率。</p>
<p>对于<strong>Java</strong>应用程序java.exe来讲，至少会存在三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。如过发生异常时会影响主线程。</p>
<p><strong>并行</strong>：多个cpu同时执行多个任务。比如，多个人做不同的事。</p>
<p><strong>并发</strong>：一个cpu（采用时间片）同时执行多个任务。比如，多个人做同一件事。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220530172524328.png" class="" title="image-20220530172524328">

<img src="/2022/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220517082401082.png" class="" title="img">

<h1 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h1><h2 id="1-多线程实现的原理"><a href="#1-多线程实现的原理" class="headerlink" title="1. 多线程实现的原理"></a>1. 多线程实现的原理</h2><ul>
<li>Java语言的JVM允许程序运行多个线程，多线程可以通过Java中的java.lang.Thread类来体现。</li>
<li>Thread类的特性<ul>
<li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。</li>
<li>通过Thread方法的start()方法来启动这个线程，而非直接调用run()。</li>
</ul>
</li>
</ul>
<h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h2><p>​		线程的创建有很多种方式：</p>
<p>1.继承Thread类 重写run()方法</p>
<p>2.实现Runnable接口 重写run()方法</p>
<p>3.使用Callable和Future创建线程</p>
<p>4.使用线程池例如用Executor框架</p>
<h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1) 继承Thread类"></a>1) 继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">//继承Thread类 重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何开启</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread1</span>.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在方法中定义一个匿名线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;<span class="comment">//调用该方法即可启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="2）实现Runnable接口"><a href="#2）实现Runnable接口" class="headerlink" title="2）实现Runnable接口"></a>2）实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现接口 实现run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3) 线程池"></a>3) 线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        指定创建的线程池数</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//代表线程总个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//代表线程执行次数</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的本质：</p>
<p>通过调用方法，实际上调用线程工厂，实际上也是使用第一种方式创建线程，指定创建的线程数，这里首先在方法中设定静态属性值，然后 Executors.defaultThreadFactory()创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//核心池大小</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,//最大池大小 ；两者相等</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">       DefaultThreadFactory() &#123;</span><br><span class="line">           <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">           group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                 Thread.currentThread().getThreadGroup();</span><br><span class="line">           namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                         poolNumber.getAndIncrement() +</span><br><span class="line">                        <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                 namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                 <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">               t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">               t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过源码发现，我们通过 <code>DefaultThreadFactory</code> 线程工厂来创建的。它可以设置线程的一些属性，比如：是否守护线程、优先级、线程名、等等，而创建线程使用newThread()方法，实际上也是new Thread()构造方法创建线程。</p>
<h3 id="4）实现Callable-接口"><a href="#4）实现Callable-接口" class="headerlink" title="4）实现Callable 接口"></a>4）实现Callable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这是就需要用到 Callable 接口。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Thread4</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//重写call()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">        <span class="comment">//方法一：使用线程池</span></span><br><span class="line">        <span class="comment">//1.创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    	<span class="comment">// 2、提交任务，并用 Future提交返回结果</span></span><br><span class="line">    	Future&lt; Integer &gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法二：使用FutureTask 实现类的支持</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Thread4</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread4</span>();</span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(td);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();  <span class="comment">//FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Callable和Runnable类似，区别在于Runnable是没有返回值的，<strong>它们的本质都是定义线程要做的任务（call 或 run 方法里面的逻辑），而不是说他们本身就是线程</strong>。但无论有无返回值，它们都是需要被线程执行。</p>
<p>Callable可以提交到线程池执行，通过 sumbit 方法提交。</p>
<h3 id="创建线程方式总结："><a href="#创建线程方式总结：" class="headerlink" title="创建线程方式总结："></a>创建线程方式总结：</h3><p>这么多创建线程方式，实际上的创建线程只有一种方式，就是继承Thread类，而<strong>Runnable接口，实际上是定义了一个线程的任务阶段的执行内容，并不是创建了一个完整的线程的生命周期（从新建到死亡）</strong>，而</p>
<h1 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h1><p>当多个线程进行并发执行时，为了资源相互之间的抢占和确保资源分配的可靠，就衍生出了很多解决问题的办法。那么如果想解决问题，就得知道问题是如何出现的，这样问题就解决了一半，那么并发问题是如何产生的呢？下面一个实例</p>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全 - 如果线程执行过程中不会产生共享资源的冲突，则线程安全。</p>
<p>线程不安全 - 如果有多个线程同时在操作主内存中的变量，则线程不安全。</p>
<h2 id="实现线程安全的几种方式"><a href="#实现线程安全的几种方式" class="headerlink" title="实现线程安全的几种方式"></a>实现线程安全的几种方式</h2><p><strong>1.互斥同步锁（悲观锁）</strong></p>
<p>1）Synchorized</p>
<p>2）ReentrantLock</p>
<p>互斥同步锁也叫做阻塞同步锁，特征是会对没有获取锁的线程进行阻塞。要理解互斥同步锁，首选要明白什么是互斥什么是同步。简单的说互斥就是非你即我，同步就是顺序访问。互斥同步锁就是以互斥的手段达到顺序访问的目的。操作系统提供了很多互斥机制比如信号量，互斥量，临界区资源等来控制在某一个时刻只能有一个或者一组线程访问同一个资源。Java里面的互斥同步锁就是Synchorized和ReentrantLock，前者是由语言级别实现的互斥同步锁，理解和写法简单但是机制笨拙，在JDK6之后性能优化大幅提升，即使在竞争激烈的情况下也能保持一个和ReentrantLock相差不多的性能，所以JDK6之后的程序选择不应该再因为性能问题而放弃synchorized。</p>
<p>ReentrantLock是API层面的互斥同步锁，需要程序自己打开并在finally中关闭锁，和synchorized相比更加的灵活，体现在三个方面：等待可中断，公平锁以及绑定多个条件。但是如果程序猿对ReentrantLock理解不够深刻，或者忘记释放lock，那么不仅不会提升性能反而会带来额外的问题。另外synchorized是JVM实现的，可以通过监控工具来监控锁的状态，遇到异常JVM会自动释放掉锁。而ReentrantLock必须由程序主动的释放锁。</p>
<p>互斥同步锁都是可重入锁，好处是可以保证不会死锁。但是因为涉及到核心态和用户态的切换，因此比较消耗性能。JVM开发团队在JDK5-JDK6升级过程中采用很多锁优化机制来优化同步无竞争情况下锁的性能。比如：<strong>自旋锁和适应性自旋锁，轻量级锁，偏向锁，锁粗化和锁消除。</strong></p>
<p><strong>2.非阻塞同步锁</strong></p>
<ol>
<li>原子类（CAS）</li>
</ol>
<p>非阻塞同步锁也叫乐观锁，相比悲观锁来说，它会先进行资源在工作内存中的更新，然后根据与主存中旧值的对比来确定在此期间是否有其他线程对共享资源进行了更新，如果旧值与期望值相同，就认为没有更新，可以把新值写回内存，否则就一直重试直到成功。它的实现方式依赖于处理器的机器指令：</p>
<p>CAS（Compare And Swap）</p>
<p>JUC中提供了几个Automic类以及每个类上的原子操作就是乐观锁机制不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p>
<p>非阻塞锁是不可重入的，否则会造成死锁。</p>
<p><strong>3.无同步方案</strong></p>
<p>1）可重入代码</p>
<p>在执行的任何时刻都可以中断-重入执行而不会产生冲突。特点就是不会依赖堆上的共享资源</p>
<p>2）ThreadLocal&#x2F;Volaitile</p>
<p>线程本地的变量，每个线程获取一份共享变量的拷贝，单独进行处理。</p>
<p>3）线程本地存储</p>
<p>如果一个共享资源一定要被多线程共享，可以尽量让一个线程完成所有的处理操作，比如生产者消费者模式中，一般会让一个消费者完成对队列上资源的消费。典型的应用是基于请求-应答模式的web服务器的设计。</p>
<h1 id="volatile、ThreadLocal的使用场景和原理"><a href="#volatile、ThreadLocal的使用场景和原理" class="headerlink" title="volatile、ThreadLocal的使用场景和原理"></a>volatile、ThreadLocal的使用场景和原理</h1><p>原文链接：<a href="https://cloud.tencent.com/developer/article/1684031">创建线程到底有多少种方式？ - 云+社区 - 腾讯云 (tencent.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2022/06/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>创建线程池有哪几个核心参数？ 如何合理配置线程池的大</strong></p>
<p><strong>小？</strong></p>
<ol>
<li>核心参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数量大小 </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 线程池最大容纳线程数 </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, // 线程空闲后的存活时长 </span></span><br><span class="line"><span class="params">                          TimeUnit unit, //缓存异步任务的队列 //用来构造线程池里的worker线程 </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程池任务满载后采取的任务拒绝策略 </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>核心说明</li>
</ol>
<ol>
<li>当线程池中线程数量小于 corePoolSize 则创建线程，并处理请求。</li>
<li>当线程池中线程数量大于等于 corePoolSize 时，则把请求放入 workQueue 中,随着线程池 中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从 workQueue 中取 任务并处理。</li>
<li>当 workQueue 已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目 达到maximumPoolSize（最大线程数量设置值）。</li>
<li>如果线程池中线程数大于 maximumPoolSize 则使用 RejectedExecutionHandler 来进行任 务拒绝处理。</li>
</ol>
<ol start="3">
<li>线程池大小分配</li>
</ol>
<p>线程池究竟设置多大要看你的线程池执行的什么任务了，CPU密集型、IO密集型、混合型，任 务类型不同，设置的方式也不一样。 </p>
<p>任务一般分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线 程池。</p>
<p>3.1）CPU密集型 </p>
<p>尽量使用较小的线程池，一般Cpu核心数+1</p>
<p>3.2）IO密集型 </p>
<p>方法一：可以使用较大的线程池，一般CPU核心数 * 2 </p>
<p>方法二：（线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
<p>3.3）混合型 可以将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，按情况而定</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2022/05/16/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>Innodb存储引擎的实现原理 索引的原理：</p>
<p>内存泄露怎么解决：</p>
<p>线程的生命周期：</p>
<img src="/2022/05/16/%E9%9D%A2%E8%AF%95/image-20220517082401082.png" class="" title="image-20220517082401082">

<p>缓存穿透、缓存击穿、缓存雪崩：</p>
<p>回文子串：</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/05/11/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<img src="/2022/05/11/%E9%9B%86%E5%90%88/1166662.jpg" class="" width="1166662">

<h2 id="Collection："><a href="#Collection：" class="headerlink" title="Collection："></a>Collection：</h2><img src="/2022/05/11/%E9%9B%86%E5%90%88/20180803184706534.png" class="" width="20180803184706534">

<span id="more"></span>

<p>1.List:  元素可重复 可以多个元素为null </p>
<p>2.Set:  添加的元素不可重复</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="1-ArrayList："><a href="#1-ArrayList：" class="headerlink" title="1.ArrayList："></a>1.ArrayList：</h3><p>​	底层使用数组实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//首先了解一下几个属性</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		ArrayList的空参构造器 构建一个空间大小为10的空链表</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		ArrayList的指定列表大小的构造方法</span></span><br><span class="line"><span class="comment">		当传入的参数为0的时候 会自动使用ArrayList的static数组EMPTY_ELEMENTDATA  这是一个空的对象数组</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		转化集合为ArrayList的构造方法 首先将集合使用Collection的toArray()方法 转化为数组</span></span><br><span class="line"><span class="comment">		然后进行判断 如果该集合的内容大小为0 则直接等效于上一个构造方法的指定长度为0的情况</span></span><br><span class="line"><span class="comment">					否则 则需要判断内容是否为Object类型</span></span><br><span class="line"><span class="comment">							如果为Object类型的 则直接将其赋值给ArrayList的Object[]数组</span></span><br><span class="line"><span class="comment">							否则 将其内容转化为Obejct类型</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1）扩容：1.空间扩容：先把原来数组内的元素复制到另一个空间大小更大的数组中：</p>
<p>​				2.添加元素：把新元素添加到扩容后的数组中</p>
<p>​			</p>
<p>​	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加方法 首先ensureCapacityInternal确定大小</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*如果 当前数组和默认的初始数组相同 那么就选择10和size+1的更大值 为10</span></span><br><span class="line"><span class="comment">	*也验证了 ArrayList使用无参构造函数的时候第一次添加元素时 数组初始化为10</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//扩容机制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	*最大容量 2^18-8</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *	新数组的大小=（原数组大小&gt;&gt;1）+原数组大小 相当于1.5倍</span></span><br><span class="line"><span class="comment">     * 如果太小 则使用原数组大小 如果太大 则使用最大数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>2）安全：ArrayList是非线程安全的</p>
<p>​	3）效率：因为底层根据数组实现 所以对集合内元素的移动操作相对于链表是效率较慢的 适合快速随机存取</p>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList:"></a>2.LinkedList:</h3><p>​	底层使用双向链表实现 继承于AbstractSequentialList</p>
<p>​	1）扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	添加元素的方法 直接将元素添加到最后一个位置</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  2）效率：LinkedList是根据双向链表实现 在增删元素的效率 相对ArrayList略高 但是在存储空间方面 因为要存储指向上一个和下雨个元素位置的索引 所以元素的存储空间相对ArrayList较大</p>
<p> 3）安全：和ArrayList一样 LinkedList是非线程安全的</p>
<h3 id="3-Vertor"><a href="#3-Vertor" class="headerlink" title="3.Vertor"></a>3.Vertor</h3><p>vertor内部实现是类似于ArrayList</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>数据以键值对的形式进行存储</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/%E5%9B%BE%E7%89%871.png" class="" title="图片1">

<h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li><p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value 放入链表中</p>
</li>
<li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<h4 id="扩容："><a href="#扩容：" class="headerlink" title="扩容："></a>扩容：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Table数组的初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//Table数组的最大长度： 1&lt;&lt;302^30=1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//负载因子：默认值为0.75。 当元素的总个数 &gt; 当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>



<h4 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span></span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;　　　　　　</span><br><span class="line">        inflateTable(threshold);<span class="comment">//如果为空，则初始化</span></span><br><span class="line">    &#125;<span class="comment">//判断key是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)<span class="keyword">return</span> putForNullKey(value);<span class="comment">//hashmap允许key为空</span></span><br><span class="line">    <span class="comment">//计算当前key的哈希值　　　</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;　　　　　　</span><br><span class="line">        Object k;<span class="comment">//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);　　　　　　　</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;　　　</span><br><span class="line">    <span class="comment">//存放值的具体方法</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">　　　　<span class="comment">//1、判断当前个数是否大于等于阈值</span></span><br><span class="line">　　　　<span class="comment">//2、当前存放是否发生哈希碰撞</span></span><br><span class="line">　　　　<span class="comment">//如果上面两个条件否发生，如果发生，那么就扩容</span></span><br><span class="line">　　　　<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　<span class="comment">//扩容，并且把原来数组中的元素重新放到新数组中</span></span><br><span class="line">　　　　　　resize(<span class="number">2</span> * table.length);</span><br><span class="line">　　　　　　hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">　　　　Entry[] oldTable = table;</span><br><span class="line">　　　　<span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">　　　　<span class="comment">//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作</span></span><br><span class="line">　　　　<span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">　　　　　　threshold = Integer.MAX_VALUE;</span><br><span class="line">　　　　　　<span class="keyword">return</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">　　　　<span class="comment">// transfer()方法把原数组中的值放到新数组中</span></span><br><span class="line">　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容后为新的数组引用</span></span><br><span class="line">　　　　table = newTable;</span><br><span class="line">　　　　<span class="comment">//设置hashmap扩容新的阈值</span></span><br><span class="line">　　　　threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h4><p>在JDK7中，当new Hashmap()的时候会对对象进行初始化，而JDK8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。 .在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行</p>
<p>扩容:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Hash 这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出</p>
<p>所以 当散列值（Hash值）相同的时候 不可以判断为 两个输入就相同</p>
<p>哈希碰撞：两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。</p>
<p>将拥有相同哈希值的对象组织成一个链表放在hash值所对应的 bucket下，但相比</p>
<p>于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即</p>
<p>2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的</p>
<p>bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还</p>
<p>需要对hashCode作一定的优化 hash()函数</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，</p>
<p>高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低</p>
<p>hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123; </span><br><span class="line">     <span class="type">int</span> h; </span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将生成的hashcode值的高16位于低16位进行异或运算，这样得到的值再进行相与，一得到最散列的下标值。</span></span><br></pre></td></tr></table></figure>

<p>1.8新增红黑树</p>
<p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减</p>
<p>少，但是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍</p>
<p>历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使</p>
<p>得遍历复杂度降低至O(logn)。</p>
<p><strong>HashMap是如何解决哈希冲突的：</strong></p>
<ol>
<li><p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p>
</li>
<li><p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p>
</li>
<li><p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。（是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使</p>
<p>得遍历复杂度降低至O(logn)）。</p>
</li>
</ol>
<p><strong>HashMap</strong> <strong>的长度为什么是2的幂次方</strong></p>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大</p>
<p>致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p>那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组</p>
<p>存储下标位置的随机性&amp;均匀性， 终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p>
<p><strong>HashMap的添加元素的过程：</strong></p>
<p><strong>( 1.)第一种就是数组下标下内容为空：</strong><br>这种情况没什么好说的，为空据直接占有这个slot槽位就好了，然后把当前.put方法传进来的key和value包装成一个node对象,放到这个slot中就好了。</p>
<p><strong>( 2.)第二种情况就是数组下标下内容不为空，但它引用的node还没有链化：</strong><br>这种情况下先要对比一下这个node对象的key与当前put对象的key是否完全.相等，如果完全相等的情况下，就行进行replace操作，把之前的槽位中node.下的value替换成新的value就可以了，否则的话这个put操作就是一个正儿.八经的hash冲突,这种情况在slot槽位后面追加一个node就可以了,用尾插法 ( 前面讲过，jdk7是把新增元素添加到头部节点，而jdk8则添加到尾部节点)。</p>
<p><strong>( 3.)第三种就是该数组下标下内容已经被链化了：</strong><br>这种情况和第二种情况处理很相似，首先也是迭代查找node，看看链表上中元素的key，与当前传过来的key是否完全一致，如果完全一致的话还是repleace操作，用put过来的新value替换掉之前node中的value，否则的话就是一致迭代到链表尾节点也没有匹配到完全一致的node，就和之前的一样，把put进来数据包装成node追加到链表的尾部，再检查一下当前链表的长度，有没有达到树化阈值，如果达到了阈值就调用一个树化方法，树化操作都是在这个方法里完成的。</p>
<p><strong>( 4.)第四种情况就是冲突很严重的情况下，这个链表已经转化成红黑树了：</strong><br>红黑树就比较复杂 要将清楚这个红黑树还得从TreeNode说起 TreeNode继承了Node结构，在Node基础上加了几个字段，分别是指向父节点parent字段，指向左子节点left字段，指向右子节点right字段，还有一个表示颜色的red字段，这就是TreeNode的基本结构，然后红黑树的插入操作，首先找到一个合适的插入点，就是找到插入节点的父节点，然后红黑树它又满足二叉树的所有特性，所以找这个父节点的操作和二叉树排序是完全一致的，然后说一下这个二叉树排序，其实就是二分查找算法映射出来的结构，就是一个倒立的二叉树，然后每个节点都可以有自己的子节点，本且左节点小于但前节点，右节点大于当前节点，然后每次向下查找一层就能那个排除掉一半的数据，查找效率非常的高效，当查找的过程中也是分情况的</p>
<p><strong>HashMap的负载因子为什么是0.75？</strong></p>
<ol>
<li>阈值(threshold) &#x3D; 负载因子(loadFactor) x 容量(capacity) 根据HashMap的扩容机制，他会保证容量(capacity)的值永远都是2的幂 为了保证负载因子x容量的结果是一个整数，这个值是0.75(4&#x2F;3)比较合理，因为这个数和任何2的次幂乘积结果都是整数。</li>
<li>理论上来讲，负载因子越大，导致哈希冲突的概率也就越大，负载因子越小，费的空间也就越大,这是一个无法避免的利弊关系，所以通过一个简单的数学推理，可以测算出这个数值在0.75左右是比较合理的</li>
</ol>
<p><strong>HashMap使用String作为key  有什么好处</strong></p>
<p>String作为hashMap的key HashMap是使用hashCode值作为参数 存放key的位置 而String对象是不可变的 在创建的时候 就已经缓存Hash Code值 所以存储对象更快</p>
<p><strong>HashMap 链表转化为红黑树，以及红黑树转化为链表的条件</strong></p>
<p>链表转化为红黑树：hashMap并不是在链表元素个数大于8就一定会转换为红黑树，而是先考虑扩容，扩容达到默认限制后才转换。</p>
<p>红黑树转化为链表：hashMap的红黑树不一定小于6的时候才会转换为链表，而是只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。</p>
<h3 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2.ConcurrentHashMap"></a><strong>2.ConcurrentHashMap</strong></h3><p>ConcurrentHashMap的内部实现对整个桶分组进行了分段分割Segment 每一把锁值锁住一部分数据 不会出现资源的恶行竞争 提高效率</p>
<p>（默认分配16个Segment，从效率上来讲 比HashMap高16倍）。</p>
<p>**ConcurrentHashMap 和HashMap的不同 **</p>
<p>ConcurrentHashMap是实现线程安全的ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁行保护，相对于HashTable的synchronized 锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启了一种全新的方式实现,利用CAS算法。） </p>
<p>所以ConcurrentHashMap也分为1.7和1.8两个jdk版本的不同</p>
<p>1.7</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap类似，是一种数</p>
<p>组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每</p>
<p>个 Segment 守护着一个 HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先</p>
<p>获得对应的 Segment的锁。</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/image-20220516104703569.png" class="" title="image-20220516104703569">

<p>1.8</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用<strong>Node + CAS + Synchronized</strong>来保证并发</p>
<p>安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产</p>
<p>生并发，效率又提升N 倍。</p>
<p>每一个结点为node  而红黑树的结点为TreeNode</p>
<img src="/2022/05/11/%E9%9B%86%E5%90%88/image-20220516110334299.png" class="" title="image-20220516110334299">

<p>使用CAS的部分 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    tab = initTable();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3.TreeMap"></a>3.TreeMap</h3><p>根据保存的key进行排序（默认排序，可自己定义），默认是按照升序排序的 ，并且不允许key的值为null <strong>非线程同步</strong></p>
<p>排序是SortedMap定义的方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回元素比较器。如果是自然顺序，则返回null；</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回从fromKey到toKey的集合：含头不含尾</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从头到toKey的集合：不包含toKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从fromKey到结尾的集合：包含fromKey</span></span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer,Integer&gt; map= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * int compare(Object o1, Object o2) 返回一个基本类型的整型，</span></span><br><span class="line"><span class="comment">     * 返回负数表示：o1 小于o2，</span></span><br><span class="line"><span class="comment">     * 返回0 表示：o1和o2相等，</span></span><br><span class="line"><span class="comment">     * 返回正数表示：o1大于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a,Integer b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b-a;<span class="comment">//倒序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong>TreeMap <strong>？</strong></p>
<p>对于在Map中插入、删除和查询元素这类操作，HashMap是 好的选择。</p>
<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，</p>
<p>也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h3 id="4-HashTable"><a href="#4-HashTable" class="headerlink" title="4.HashTable"></a>4.HashTable</h3><p>和hashmap类似 但不允许key或value为null 支持线程同步 只允许一条线程同时操作HashTable <strong>线程同步</strong></p>
<p>HashTable基本被淘汰</p>
<p><strong>与HashMap的区别</strong></p>
<p>1.线程安全; HashMap是非线程安全的 HashTable是线程安全的 HashTable的内部方法基本都经过synchronized修饰</p>
<p>（但是如果想要保证线程安全的话 请使用ConcurrentHashMap吧）</p>
<p>2.效率： 众所周知 鱼和熊掌不可兼得 保证了安全性 那一定会牺牲效率 </p>
<p>3.对null的支持： HashMap中 null可以作为键 但是只能有一个 对应的value可以多个为null </p>
<p>​								HashTable中 null如果添加 不论是key or value 则直接抛空指针异常NullPointerException。</p>
<p>4.初始容量大小的不同：</p>
<p>①如果不指定容量 HashTable的大小是11  每次扩容为2n+1</p>
<p>​	而hashMap的默认初始化大小是16	扩容为两倍（左移一位）</p>
<p>②HashTable如果指定了大小 则会初始化为指定大小 而HashMap则会在指定大小的基础上 扩充为2的幂次方</p>
<p>5.使用场景 ：HashTable如果是单线程使用 则推荐使用HashMap 如果是多线程使用 则推荐ConcurrentHashMap</p>
<p>​						因为HashTable是将整个表都锁 减少了并发的效率</p>
<h3 id="5-LinkedListMap"><a href="#5-LinkedListMap" class="headerlink" title="5.LinkedListMap"></a>5.LinkedListMap</h3><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>不允许重复的元素存在 </p>
<p>只允许一个元素为null </p>
<p> 非线程安全</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>元素是无序的</p>
<p>首先是构造方法 直接创建了一个HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>说明 Set是用Map的key存储内容 而map的value 是在set中创建的Object类对象PRESENT</p>
<p>PRESENT为了使用HashMap而创建的一个Object对象，用来占掉value的位置，无其他意义 。</p>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>因为结构就是根据Hashmap生成 添加元素的方法也是根据Hashmap的put方法，结构同上。</p>
<p>hashset为什么要重写hashcode和equals方法？<br>在Hashset种 为了保证元素的不重复性 首先计算添加元素的hash值 计算hash值后 在map的区域算法计算去应该添加的桶位置<br>如果该位置有没有元素 则直接 添加<br>如果该位置铀元素 则进行equals（）判断 如果这两个内容相同 则替换原来的元素<br>                    如果不同 则添加到该位置元素的后面 以链表的形式存储 之后就和Hashmap相同</p>
<p>但是如果不重写HashCode  那么对于一些引用类型的对象 即使两者的内容和属性完全相同 两者的Hashcode也不会相同 那么就会出现Set种存在两个相同应用类型的对象<br>所以 当重写HashCode 那么对于两个内容完全相同的元素 也会计算出相同的HashCode值 完全符合Set 元素不重复的特点<br>equals()比较的是 当出现Hash冲突的时候 判断两个元素是否是完全相同的元素 如果不是才会添加<br>使用hashcode进行判断 也大大的减少了equals()的比较次数 增加了效率。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>元素是有序的</p>
<p>元素是使用它们的自然顺序来排序的，或者通过在设置的创建时提供的比较器来排序的，这取决于使用的是哪个构造函数</p>
<p>构造方法：同样是借助Map 但是TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层结构：二叉树排序。 </p>
<h5 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h5><p>Comparable与Comparator实际上是TreeSet集合的两种实现方式，用来实现对象的排序。</p>
<ol>
<li>Comparable称为元素的自然顺序，或者叫做默认顺序。</li>
<li>Comparator称为元素定制排序。</li>
</ol>
<p>​	</p>
<p>​	</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
