<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-nextwechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MySQL数据库逻辑架构  1）连接层 Connection Pool 系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证 TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池 连接池（线程池）数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://example.com/2022/05/20/mysql/index.html">
<meta property="og:site_name" content="shuaiqiwudi blog">
<meta property="og:description" content="MySQL数据库逻辑架构  1）连接层 Connection Pool 系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证 TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池 连接池（线程池）数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/image-20220522131409069.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220522133151857.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/image-20220522133456976.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/image-20220522134845235.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/image-20220522140130072.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/image-20220522141658938.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220520170817159.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220520170840162.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1097754/202107/1097754-20210719234605417-2013635397.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523095656639.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523095757181.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523100525991.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523101301936.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523101831703.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523101951740.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523195028484.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523195555772.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523201143065.png">
<meta property="og:image" content="http://example.com/2022/05/20/mysql/mysql/image-20220523201736656.png">
<meta property="article:published_time" content="2022-05-20T09:03:25.000Z">
<meta property="article:modified_time" content="2022-05-23T12:37:59.895Z">
<meta property="article:author" content="zh-CN">
<meta property="article:tag" content="zsr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/20/mysql/image-20220522131409069.png">

<link rel="canonical" href="http://example.com/2022/05/20/mysql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>mysql | shuaiqiwudi blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shuaiqiwudi blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/20/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zh-CN">
      <meta itemprop="description" content="The Blog Which Owned Shuaiqiwudi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuaiqiwudi blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-20 17:03:25" itemprop="dateCreated datePublished" datetime="2022-05-20T17:03:25+08:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-23 20:37:59" itemprop="dateModified" datetime="2022-05-23T20:37:59+08:00">2022-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="数据库逻辑架构"><a href="#数据库逻辑架构" class="headerlink" title="数据库逻辑架构"></a>数据库逻辑架构</h3><img src="image-20220522131409069.png" alt="image-20220522131409069" style="zoom: 80%;" />

<p>1）连接层 Connection Pool</p>
<p>系统访问MySql之前 首先要做到的就是建立TCP的连接，经过三次握手建立连接之后，mysql会对密码和账号进行验证</p>
<p><strong>TCP创建连接之后，必须要分配一个线程专门与这个客户端进行交互。所以还会有一个线程池</strong></p>
<h4 id="连接池（线程池）"><a href="#连接池（线程池）" class="headerlink" title="连接池（线程池）"></a>连接池（线程池）</h4><p>数据库连接池负责分配、管理和释放数据库连接，允许应用程序重复使用一个现有的数据库的连接，而不是重新创建一个。</p>
<span id="more"></span>

<details>
<summary>点击查看线程池详细内容</summary>
<b>为什么使用连接池？</b><br>
对于数据库建立连接对象，对应一个实际的物理连接，每次使用都打开一个连接，再关闭一个连接，这样会造成书库的性能低下。解决方案是，应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池**(简单说：在一个“池”里放了好多半成品的数据库联接对象)**，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。这样一来，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率。<br>
<b>不使用连接池 执行一条sql的过程：</b><br><br>
<img src="mysql/image-20220522133151857.png" alt="image-20220522133151857" style="zoom:80%;" />
<br>
1. TCP建立连接的三次握手<br>
2. MySQL认证的三次握手<br>
3. 真正的SQL执行<br>
4. MySQL的关闭<br>
5. TCP的四次握手关闭<br>
<b>使用连接池 执行一条sql的过程：</b><br>
<img src="/2022/05/20/mysql/image-20220522133456976.png" class="" title="image-20220522133456976"><br>
第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。<br>
<b>线程池工作的原理</b><br>
建立连接 管理链接 删除连接 
第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。<br>
第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：<br>
当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>
当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。<br>
第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。
<b>主流的几个连接池</b>
数据库连接池有三种：</b>
1、DBCP:</b>
DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。</b>
2、C3P0:</b>
c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。</b>
3、Druid:</b>
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个 SQL Parser。</b>
支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。</b>
Druid针对Oracle和MySql做了特别优化，比如Oracle的PS Cache内存占用优化，MySql的ping检测优化。</b>
Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。</b>
简单SQL语句用时10微秒以内，复杂SQL用时30微秒。通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。</b>
Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析语义实现的。</b>
<img src="/2022/05/20/mysql/image-20220522134845235.png" class="" title="image-20220522134845235"></b>
参考链接
原文链接：https://blog.csdn.net/weixin_43871678/article/details/116571499</b>
原文链接：https://blog.csdn.net/CrankZ/article/details/82874158</b>
</details>
2）服务层 

<p><strong>SQL Interface: SQL</strong> <strong>接口</strong></p>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL </p>
<p>Interface </p>
<p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定</p>
<p>义函数等多种SQL语言接口</p>
<p><strong>Parser:</strong> <strong>解析器</strong></p>
<p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构</p>
<p>传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错</p>
<p>误，那么就说明这个SQL语句是不合理的。</p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字</p>
<p>典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还</p>
<p>会对SQl查询进行语法上的优化，进行查询重写。 </p>
<p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行</p>
<p>计划 。<strong>这个执行计划表明应该 使用哪些索引 进行查询</strong>（全表检索还是使用索引检索），表之间的连</p>
<p>接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将</p>
<p>查询结果返回给用户。</p>
<p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过</p>
<p>滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过</p>
<p>滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
<p><strong>Caches &amp; Buffers</strong> <strong>： 查询缓存组件</strong></p>
<p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结</p>
<p>果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过</p>
<p>程了，直接将结果反馈给客户端。</p>
<p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p>
<p>这个查询缓存可以在 不同客户端之间共享 。 </p>
<p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </p>
<p>3）引擎层 </p>
<p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了<strong><strong>MySQL</strong></strong>中数据的存储和提取，对物理服务器级别</strong></p>
<p><strong>维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样</p>
<p>我们可以根据自己的实际需要进行选取。</p>
<img src="/2022/05/20/mysql/image-20220522140130072.png" class="" title="image-20220522140130072">

<p>4 )存储层</p>
<p>作为数据真正的物理存储位置，所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存</p>
<p>在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。</p>
<p>特别注意MyISAM存储文件后缀为—– .myd(数据) 和.myi (索引) </p>
<p>Innodb的索引和数据是集中存储的 —– .ibd</p>
<p><strong>整个执行流程</strong></p>
<img src="/2022/05/20/mysql/image-20220522141658938.png" class="" title="image-20220522141658938">


<p><strong>数据库三大范式是什么</strong></p>
<p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我</p>
<p>们经常会为了性能而妥协数据库的设计。</p>
<h3 id="两大存储引擎"><a href="#两大存储引擎" class="headerlink" title="两大存储引擎"></a>两大存储引擎</h3><img src="mysql/image-20220520170817159.png" alt="image-20220520170817159" style="zoom:80%;" />

<img src="mysql/image-20220520170840162.png" alt="image-20220520170840162" style="zoom:80%;" />

<h3 id="数据库中索引的存储结构"><a href="#数据库中索引的存储结构" class="headerlink" title="数据库中索引的存储结构"></a>数据库中索引的存储结构</h3><p>索引的存在 就是为了减少磁盘的IO次数 增加读取的效率 </p>
<p><strong>什么是索引</strong>：MySQL官方对索引的定义为：<strong>索引（</strong>Index<strong>）是帮助</strong>MySQL<strong>高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。</p>
<p>这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<p><strong>优点</strong>：1 ）提高数据检索的效率，降低 数据库的IO成本</p>
<p>​			2 ）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</p>
<p>​			3）在实现数据的参考完整性方面，可以 加速表和表之间的连接 。</p>
<p>​			4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</p>
<p><strong>缺点</strong>：</p>
<p><strong>空间上的代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会</p>
<p>占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<p><strong>时间上的代价</strong>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每</p>
<p>层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还</p>
<p>是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序</p>
<p>而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需</p>
<p>要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果</p>
<p>我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿</p>
<h3 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h3><h3 id="设计索引和数据的存储形式"><a href="#设计索引和数据的存储形式" class="headerlink" title="设计索引和数据的存储形式"></a>设计索引和数据的存储形式</h3><p>当我们使用命令创建一个表的时候 数据会以特定的形式存在于表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">	number int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">)ROW_FORMAT = Compact;//指定行格式</span><br></pre></td></tr></table></figure>

<p>行数据究竟怎么存储的？Compact的行格式:</p>
<p><img src="https://img2020.cnblogs.com/blog/1097754/202107/1097754-20210719234605417-2013635397.png" alt="img"></p>
<p>DB_ROW_ID(row_id)  如果表中没有显式定义主键列，mysql会默认生成一个row_id作为隐式主键，且row_id是全局概念，每一次有一行新数据insert，都会获取Max Row ID再加1就形成了一个新的row_id<br>DB_TRX_ID    事务有关，跟回滚指针有关，6个字节<br>DB_ROLL_PTR  事务有关，跟回滚指针有关， 7个字节</p>
<p>delete mask : 标记为是否被delete语句commit，也就是mysql不会真正物理删除一行记录，在页面上重新组装一个新链表，称为垃圾链表，如果垃圾链表占用空间可重用的话就会重用。</p>
<p>record type：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过。</p>
<p>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>
<img src="mysql/image-20220523095656639.png" alt="image-20220523095656639" style="zoom: 33%;" />

<p>从数据的连接角度来简略展示行数据 每一行数据如此 那么把多数的数据连接起来呢？</p>
<img src="mysql/image-20220523095757181.png" alt="image-20220523095757181" style="zoom: 50%;" />

<p>多行数据进行连接 形成一个页 每一页存放多行数据 页的第一个位置和最后一个位置不存放数据 用来表示该页的最小记录和最大记录。</p>
<p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<img src="mysql/image-20220523100525991.png" alt="image-20220523100525991" style="zoom: 67%;" />

<p>在根据该页的最小记录和最大记录 将每一页的位置进行定位</p>
<p><strong>InnoDB中的索引方案</strong> </p>
<p><strong>① 迭代1次：目录项纪录的页</strong></p>
<img src="mysql/image-20220523101301936.png" alt="image-20220523101301936" style="zoom:67%;" />



<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>
<img src="mysql/image-20220523101831703.png" alt="image-20220523101831703" style="zoom:67%;" />



<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>
<img src="mysql/image-20220523101951740.png" alt="image-20220523101951740" style="zoom:67%;" />

<p><strong>④</strong> <strong>B+Tree</strong></p>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。</p>
<p>之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页最多存放4条记录 。其实</p>
<p>真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，</p>
<p>所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：</p>
<ul>
<li><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</p>
</li>
<li><p>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</p>
</li>
<li><p>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</p>
</li>
<li><p>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！！！</p>
</li>
</ul>
<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值</p>
<p>查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 </p>
<p>Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</p>
<h3 id="索引的类型和特点"><a href="#索引的类型和特点" class="headerlink" title="索引的类型和特点"></a>索引的类型和特点</h3><p><strong>1.聚簇索引</strong></p>
<p>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据；</p>
<p>主键索引是聚簇索引的一种</p>
<p>通常情况下 我们使用主键作为自增的唯一id 但是如果没有主键 那么会默认使用row_id作为主键 </p>
<p>1）使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<p><strong>页内的记录</strong>是按照主键的大小顺序排成一个 <strong>单向链表</strong> 。</p>
<p>各个 <strong>存放用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个<strong>双向链表</strong> 。</p>
<p><strong>存放目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <strong>双向链表</strong> 。 </p>
<p>2）B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
<p><strong>2.非聚簇索引</strong></p>
<p>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。简单理解：在聚簇索引上建立的索引就是非聚簇索引。</p>
<p>在innodb中，在聚簇索引上建立的都是辅助索引，即非聚簇索引也叫辅助索引。一张表中只能有一个聚簇索引。其余索引都是非聚簇索引。辅助索引叶子节点存储的是主键值，访问数据总是要先查到主键值，再通过主键值访问到数据。即辅助索引访问数据总是需要二次查找 通常也成为回表</p>
<p><strong>回表：</strong></p>
<p>我们根据某个列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据该列的值查找到完整的用户记录的话，</p>
<p>仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据非聚簇索引列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方想让books的书籍编号字段和价格字段索引联合创建</p>
<p>索引的索引：首先按照书籍编号进行排序 然后在书籍编号的基础上按照价格进行排序。</p>
<p>InnoDB和MyISAM</p>
<p>InnoDB的B+树索引的注意事项</p>
<p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>
<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><h4 id="哪些字段适合创建索引"><a href="#哪些字段适合创建索引" class="headerlink" title="哪些字段适合创建索引"></a>哪些字段适合创建索引</h4><p><strong>1.字段的数值具有唯一性的限制</strong></p>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
<p><strong>2.频繁作为Where查询字段的字段</strong></p>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在</p>
<p>数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p><strong>3.经常GroupBy和Order BY的字段</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者</p>
<p>使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多</p>
<p>个，那么可以在这些列上建立 组合索引 。 </p>
<p><strong>4.UPDATE,DELETE 的WHERE条件列</strong></p>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就</p>
<p>能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或</p>
<p>删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更</strong></p>
<p><strong>新不需要对索引进行维护。</strong></p>
<p><strong>在实际情况中 还有多种情景适合创建索引 凡是需要重复在聚簇索引中查找某一个列的字段 都可以创建索引</strong></p>
<h4 id="哪些字段不适合创建索引"><a href="#哪些字段不适合创建索引" class="headerlink" title="哪些字段不适合创建索引"></a>哪些字段不适合创建索引</h4><p>1.在where中使用不到的字段，不要设置索引</p>
<p>2.数据量小的表最好不要使用索引</p>
<p>3.有大量重复数据的列上不要建立索引  比如男性女性这种很高几率重复的字段</p>
<p>4.避免对经常更新的表进行索引的创建</p>
<p>5.不建议使用无序的列作为索引</p>
<p>6.不要定义重复和冗余的索引</p>
<h2 id="数据库的调优策略"><a href="#数据库的调优策略" class="headerlink" title="数据库的调优策略"></a>数据库的调优策略</h2><p>&#x2F;&#x2F;TODO</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在数据库中事务是什么</p>
<p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务处理原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><strong>原子性（atomicity）：</strong></p>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
<p><strong>一致性（</strong>consistency<strong>）：</strong></p>
<p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<strong>Consistency</strong>的阐述）</p>
<p>根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态</p>
<p>是 语义上 的而不是语法上的，跟具体的业务有关。</p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己</p>
<p>来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就</p>
<p>是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作</p>
<p>之前的状态。</p>
<p><strong>隔离型（</strong>isolation<strong>）：</strong>事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的</p>
<p>其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p><strong>持久性（</strong>durability<strong>）：</strong>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h4 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h4><p>显示事务：手动开启事务 begin 或 start transaction</p>
<p>隐式事务：MySql中有一个系统变量autocommit </p>
<img src="mysql/image-20220523195028484.png" alt="image-20220523195028484" style="zoom:67%;" />

<p>该变量设置数据库执行语句是否自动提交 可以将该变量设置为不自动提交 </p>
<img src="mysql/image-20220523195555772.png" alt="image-20220523195555772" style="zoom:67%;" />

<h4 id="数据库并发和隔离级别"><a href="#数据库并发和隔离级别" class="headerlink" title="数据库并发和隔离级别"></a>数据库并发和隔离级别</h4><p>事务的四种并发问题：</p>
<p><strong>1.脏写（ Dirty Write ）</strong>：</p>
<p>对于SessionA和SessionB 如果SessionA修改了另一个未提交事务SessionB修改过的数据 ，那就意味着脏写</p>
<p><strong>2.脏读（ Dirty Read）：</strong></p>
<p>SessionA已经读取了SessionB更新但还没有被提交到的字段，之后若SessionB回滚，SessionA读到的数据并不是真实数据，该数据就是临时且无效的脏读数据。</p>
<p><strong>3.不可重复读（Non</strong>-<strong>Repeatable Read）：</strong></p>
<p>SessionA开启事务并读取数据，但是此时SessionB将数据修改并提交，SessionA再查看数据值不同了，就意味着出现了不可重复读。</p>
<p><strong>4.幻读（Phantom）</strong>：</p>
<p>两个事务SessionA，SessionB SessionA从表中读取了一个字段后，SessionB向表中插入了一些新的行，之后，如果SessionA再次读取同一个表，就会出现几条新的数据（幻影记录），我们称之为幻读。</p>
<p>对于这四种现象 按照严重程度：</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>分别对应四种隔离级别：</p>
<p><strong>1.READ UNCOMMITTED ：</strong>读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。</p>
<p>不能避免脏读、不可重复读、幻读。</p>
<p><strong>2.READ COMMITTED ：</strong>读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
<p><strong>3.REPEATABLE READ ：</strong>可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，</p>
<p>读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是<strong>MySQL的默认隔离级别</strong>。</p>
<p>4.<strong>SERIALIZABLE ：</strong>可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、</p>
<p>更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
<p>一张图：</p>
<img src="mysql/image-20220523201143065.png" alt="image-20220523201143065" style="zoom:50%;" />

<p>8.0.29的隔离级别</p>
<img src="mysql/image-20220523201736656.png" alt="image-20220523201736656" style="zoom:67%;" />

<h3 id="数据库事务日志"><a href="#数据库事务日志" class="headerlink" title="数据库事务日志"></a>数据库事务日志</h3><p>事务的四种特性是基于什么实现的？ </p>
<p><strong>隔离性</strong>根据<strong>锁机制</strong>实现</p>
<p>事务的<strong>原子性，一致性和持久性</strong>由事务的<strong>redo日志和undo日志</strong>保证</p>
<p>REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</p>
<p>UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<p>查看引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<p>查看默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>

<p>修改默认的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>创建表时指定存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>修改表的存储引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名 \G;</span><br></pre></td></tr></table></figure>

<p>开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">#或</span><br><span class="line">START transaction 添加的修饰符;（ READ ONLY） （ READ WRITE）</span><br></pre></td></tr></table></figure>

<p>查看数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>修改数据库隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式： </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/18/IOStream/" rel="prev" title="IOStream">
      <i class="fa fa-chevron-left"></i> IOStream
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL"><span class="nav-number">1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">1.0.1.</span> <span class="nav-text">数据库逻辑架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">连接池（线程池）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E5%A4%A7%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.0.2.</span> <span class="nav-text">两大存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.3.</span> <span class="nav-text">数据库中索引的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="nav-number">1.0.4.</span> <span class="nav-text">索引的创建原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.0.5.</span> <span class="nav-text">设计索引和数据的存储形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">1.0.6.</span> <span class="nav-text">索引的类型和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.0.7.</span> <span class="nav-text">索引的设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">哪些字段适合创建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">哪些字段不适合创建索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.</span> <span class="nav-text">数据库的调优策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">事务的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">数据库并发和隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据库事务日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">常用命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zh-CN</p>
  <div class="site-description" itemprop="description">The Blog Which Owned Shuaiqiwudi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zh-CN</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
