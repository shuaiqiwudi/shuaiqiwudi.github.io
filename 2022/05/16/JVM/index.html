<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-nextwechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM什么是JVM？Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此 Java语言可以实现跨平台。 提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE JREJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/05/16/JVM/index.html">
<meta property="og:site_name" content="shuaiqiwudi blog">
<meta property="og:description" content="JVM什么是JVM？Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此 Java语言可以实现跨平台。 提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE JREJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220516150612535.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220711165236171.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220516154322660.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220521095627681.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220520140939077.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/2128165/202008/2128165-20200827223659712-1825753625.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220711174215771.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220711171336881.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220711173346887.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ec9158ddefc24b9a8c638d469729c542.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOO6KGM5rC05LiKX1pI,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="article:published_time" content="2022-05-16T06:46:22.000Z">
<meta property="article:modified_time" content="2022-07-12T06:50:54.450Z">
<meta property="article:author" content="zh-CN">
<meta property="article:tag" content="zsr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/16/JVM/image-20220516150612535.png">

<link rel="canonical" href="http://example.com/2022/05/16/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JVM | shuaiqiwudi blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shuaiqiwudi blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zh-CN">
      <meta itemprop="description" content="The Blog Which Owned Shuaiqiwudi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuaiqiwudi blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 14:46:22" itemprop="dateCreated datePublished" datetime="2022-05-16T14:46:22+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-12 14:50:54" itemprop="dateModified" datetime="2022-07-12T14:50:54+08:00">2022-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p><strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此</p>
<p>Java语言可以实现跨平台。</p>
<p>提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a><strong>JRE</strong></h2><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java序，计算机中只需要安装JRE即可。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h2><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以</p>
<p>安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>从包含关系来讲：JDK&gt;JRE&gt;JVM</p>
<img src="/2022/05/16/JVM/image-20220516150612535.png" class="" title="image-20220516150612535">

<span id="more"></span>

<p>既然谈到了JVM 众所周知 JVM是java语言的灵魂 那么JVM给java带来了什么？</p>
<p>1.跨平台性：所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。</p>
<p>2.实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，该系统就可以运行java程序。</p>
<p>众所周知 <strong>java文件运行的流程</strong>如下：</p>
<p>.java文件 由开发人员编写 经过编译后 生成.class文件 ——即字节码文件 该.class文件不面向任何机器 只面向虚拟机</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可 在多种不同的计算机上运行。<strong>一次编译 到处运行</strong>作为高级语言 就得有解释 编译 将语言转化为二进制 这两个步骤 Java是怎么实现的呢？</p>
<p><strong>java中的编译器和解释器：</strong></p>
<p>也可以直接看下面</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码行。在Java中，这种供虚拟机理解的代码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>执行顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码(.java文件)----&gt;编译器----&gt;jvm可执行的Java字节码(.class文件)----&gt;jvm----&gt;jvm中的解释器-----&gt; 机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/JVM/image-20220711165236171.png" class="" title="image-20220711165236171">

<p>接下来看一下JVM内部结构：</p>
<h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><img src="/2022/05/16/JVM/image-20220516154322660.png" class="" title="image-20220516154322660">

<p>可以分为两组件 两子系统：</p>
<h2 id="JVM总体结构"><a href="#JVM总体结构" class="headerlink" title="JVM总体结构"></a>JVM总体结构</h2><p><strong>两个子系统</strong>：1.Class loader(类装载)  </p>
<p>​					   2. Execution engine(执行引擎)</p>
<p><strong>两个组件</strong>： 1.Runtime data area(运行时数据区）</p>
<p>​					2.Native Interface(本地接口)。</p>
<blockquote>
<p>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</blockquote>
<blockquote>
<p>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。</p>
</blockquote>
<blockquote>
<p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</blockquote>
<blockquote>
<p>Execution engine（执行引擎）：执行classes中的指令。</p>
</blockquote>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>运行时数据区存在于内存 又称jvm内存模型 分别有五个部分</p>
<blockquote>
<p><strong>程序计数器</strong>:当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选<strong>取下一条需要执行的 字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>:类似虚拟机栈，是为虚拟机使用native本地方法而准备的。具体实现由虚拟机厂商来实现。HotSpot虚拟机中实现与虚拟机栈一致，同时超出大小抛StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>:每个线程私有的空间，由多个栈帧组成，一个方法对应一个栈帧，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大1M，超出跑出StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>:所有线程都可以访问修改，存放的是对象实例，是数据区中占用空间最大的部分，在HotSpot虚拟机中分为新生代和老年代，新生代又分为Eden区和Survivor0区、Survivor1区。</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>:JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。不同虚拟机有不同的实现，oracle的HotSpot在Java7中方法区放在永久代，Java8中方法区放在元空间，并通过GC机制来管理。</p>
</blockquote>
<p>在<strong>线程共享</strong>的角度来分类：</p>
<p>​									<font color=Red><em>方法区,堆 属于线程共享的 | 虚拟机栈, 本地方法栈, 程序计数器不是线程共享的</em></font></p>
<p>**而程序计数器是唯一一个不会出现OOM的区域(Out Of Memory) ** 具体error：(java.lang.OutOfMemoryError)</p>
<p>首先聊一聊<strong>堆</strong>和<strong>方法区</strong>这两个最重要的区域:</p>
<p><strong>堆</strong>:从上面的定义来讲,存放对象实例,就是java中经常操作的对象,堆的物理地址分配对对象是不连续的。</p>
<p>因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩）。 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p><strong>方法区</strong>:存放类的相关信息</p>
<ol>
<li><p>静态变量放在方法区</p>
</li>
<li><p>静态的对象还是放在堆。</p>
</li>
</ol>
<p>既然创建的实例对象都在堆中,那堆中创建的对象多了怎么办,难道堆是一个无穷无尽的空间什么时期的实例对象都收纳吗?</p>
<p>堆空间是怎么决定哪些对象应该保存,哪些对象应该消失呢?难道要java程序员自己去决定吗?这就涉及到了java的垃圾回收机制</p>
<h3 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a><strong>什么是垃圾回收机制</strong></h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h3 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a><strong>什么是GC</strong></h3><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h3 id="垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗"><a href="#垃圾回收的基本原理是什么-有什么办法可以通知垃圾回收器马上开始GC吗" class="headerlink" title="垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?"></a><strong>垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?</strong></h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<h3 id="如何判断对象是否可以被回收（两种垃圾位置分析算法）"><a href="#如何判断对象是否可以被回收（两种垃圾位置分析算法）" class="headerlink" title="如何判断对象是否可以被回收（两种垃圾位置分析算法）"></a><strong>如何判断对象是否可以被回收</strong>（两种垃圾位置分析算法）</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」</p>
<p>的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<blockquote>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，</p>
<p>当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</p>
</blockquote>
<blockquote>
<p>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC</p>
<p>Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 </p>
</blockquote>
<p>&#x2F;&#x2F;TODO 可达性算法详解</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对于堆空间,java不同版本的虚拟机会有不同的垃圾回收算法,目前最主流的有:</p>
<h4 id="1-标记-清除算法："><a href="#1-标记-清除算法：" class="headerlink" title="1.标记-清除算法："></a>1.标记-清除算法：</h4><p>标记无用对象，然后进行清除回收。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<h4 id="2-标记-复制算法："><a href="#2-标记-复制算法：" class="headerlink" title="2.标记-复制算法："></a>2.标记-复制算法：</h4><p>按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<h4 id="3-标记-整理算法："><a href="#3-标记-整理算法：" class="headerlink" title="3.标记-整理算法："></a>3.标记-整理算法：</h4><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<h4 id="4-分代算法："><a href="#4-分代算法：" class="headerlink" title="4.分代算法："></a>4.分代算法：</h4><p>根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是新生代和老年 代，新生代分为Eden区和Survior区。<img src="/2022/05/16/JVM/image-20220521095627681.png" class="" title="image-20220521095627681"></p>
<p><strong>分代算法的对象迁移</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到 老年代。</p>
<h3 id="JVM都有哪些垃圾回收器？"><a href="#JVM都有哪些垃圾回收器？" class="headerlink" title="JVM都有哪些垃圾回收器？"></a>JVM都有哪些垃圾回收器？</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种作用于不同分代的收集器，其中于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于收整个Java堆的G1收集器。不同收集器 之间的连线表示它们可以搭配使用。</p>
<img src="/2022/05/16/JVM/image-20220520140939077.png" class="" title="image-20220520140939077">



<details>
<summary>点击查看垃圾回收器详细内容</summary>
Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU
环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不 高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器
的老年代版本；<br>
<b>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</b>： 老年代并行收集 器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。<br>
<b>G1(Garbage First)收集器 (标记-整理算法)</b>： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新
收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同
于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代 或老年代。<br>
</details>

<h3 id="各垃圾回收器的使用位置"><a href="#各垃圾回收器的使用位置" class="headerlink" title="各垃圾回收器的使用位置"></a><strong>各垃圾回收器的使用位置</strong></h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<h3 id="各代适合的垃圾回收算法"><a href="#各代适合的垃圾回收算法" class="headerlink" title="各代适合的垃圾回收算法"></a><strong>各代适合的垃圾回收算法</strong></h3><p>年轻代的堆空间，因为经常生成对象，并且对象的消亡和创建都很频繁，所以该区域需要高效率，能更好利用cpu的垃圾回收算法以保证内存空间的充足，<strong>新生代常常使用标记-复制算法。</strong></p>
<p>老年代的堆空间常常存放不易回收的对象，所以该区域不需要频繁的进行GC，需要考虑的是内存空间的利用，需要足够的空间存放不易回收的老年代对象，<strong>老年代常常使用标记整理算法，CMS的标记清除算法。</strong></p>
<h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a><strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾 回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="创建对象的内存分配"><a href="#创建对象的内存分配" class="headerlink" title="创建对象的内存分配"></a>创建对象的内存分配</h3><p>多数情况下，对象都在Eden区被创建，但是当Eden区内存空间不足的时候，虚拟机会进行一次<strong>年轻代的MinorGC</strong>，</p>
<p>如果本次GC以后，依然没有足够的空间，则将启用分配担保机制，在老年代中分配内存。</p>
<h3 id="如果对象太大怎么办？"><a href="#如果对象太大怎么办？" class="headerlink" title="如果对象太大怎么办？"></a><strong>如果对象太大怎么办？</strong></h3><p>大对象是指需要大连的连续的内存空间的对象，而大对象如果存放在年轻代，而年轻代使用的是标记复制算法，大对象在两个幸存区之不断复制，占用了其他对象的空间，并且影响了效率。假设大对象是“朝生夕死”的（从GC次数上来讲不会进入老年代），那它占用了年轻的空间，其他对象进入的时候因为大对象的存在会提前触发GC，而大对象在幸存区的空间占比又过大，导致新创建的对象只能添加到老年代，这就加快了老年代GC的时间，对老年代的性能进行了很大的负面影响。<strong>（毕竟老年代的GC效率大概要比年轻代的GC效率低10倍左右）</strong>。如果确定大对象是“朝生夕死”的，可以通过设置JVM对大对象的参数阈值【-XX:PretenureSizeThreshold】，使大对象相对JVM来讲是不再那么大，从而在年轻代就GC（当然会这样影响性能）。</p>
<h3 id="发生在不同区域的GC"><a href="#发生在不同区域的GC" class="headerlink" title="发生在不同区域的GC"></a>发生在不同区域的GC</h3><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</p>
<p><strong>Major GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。</p>
<p><strong>FullGC</strong> 是指发生在整个堆内存的GC ，老年代和年轻代一起GC，应该避免FullGC的发生，会影响JVM的性能。</p>
<p>触发条件：1）System.gc() 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。</p>
<p>​					2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>​					3）通过Minor GC后进入年轻代的平均大小大于老年代的可用内存</p>
<p>FullGC详解</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC | Plumbr – User Experience &amp; Application Performance Monitoring</a></p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h4 id="方法区存放的具体内容："><a href="#方法区存放的具体内容：" class="headerlink" title="方法区存放的具体内容："></a>方法区存放的具体内容：</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等。</p>
<p><img src="https://img2020.cnblogs.com/blog/2128165/202008/2128165-20200827223659712-1825753625.png" alt="9.4.1_1"></p>
<h4 id="方法区的位置"><a href="#方法区的位置" class="headerlink" title="方法区的位置"></a>方法区的位置</h4><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或进行压缩。”但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于 Java 堆的内存空间。</strong></p>
<p>方法区在 JVM 启动的时候被创建，并且它在实际的物理内存空间中，和 Java 堆区一样都可以是不连续的。在 jdk7 及以前，习惯上把方法区称为永久代。jdk8 开始，使用元空间取代了永久代。本质上，方法区和永久代并不等价，等价仅是对 HotSpot 而言的。</p>
<p>到了 JDK8，永久代的概念被完全废除，改用了在本地内存中实现的元空间（Metaspace）来代替。</p>
<h4 id="运行时常量池和常量池"><a href="#运行时常量池和常量池" class="headerlink" title="运行时常量池和常量池"></a>运行时常量池和常量池</h4><ul>
<li>方法区内部包含了运行时常量池。</li>
<li>字节码文件包含了常量池。</li>
</ul>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p>常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用，此时不再是常量池中的符号地址了，这里换为真实地址。<ul>
<li>运行时常量池相对于 Class 文件常量池的另一重要特征是：具备动态性。</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li>
</ul>
<h4 id="字符串常量池的位置变化"><a href="#字符串常量池的位置变化" class="headerlink" title="字符串常量池的位置变化"></a>字符串常量池的位置变化</h4><p>运行时常量池存和字符串常量池的变化</p>
<p>JDK1.7之前 ：<br>运行时常量池(包含字符串常量池 )存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_1">





<p>JDK1.7 ：<br>字符串常量池被从方法区拿到了堆中；<br>运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_2">





<p>JDK1.8 ：<br>hotspot移除了永久代，用元空间(Metaspace) 取而代之。这时候，<br>字符串常量池还在堆,<br>运行时常量池还在方法区, 只不过方法区的实现从永久代变成元空间(Metaspace)。</p>
<img src="/2022/05/16/JVM/2128165-20200827223822891-1286299930-16575481393884.png" class="" title="9.5_3">



<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><h4 id="元空间的内存大小"><a href="#元空间的内存大小" class="headerlink" title="元空间的内存大小"></a>元空间的内存大小</h4><p>元空间是方法区的在HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过<strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</strong>理论上取决于32位&#x2F;64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数，元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定。</p>
<h4 id="为什么jdk8用metaspace数据结构用来替代perm？"><a href="#为什么jdk8用metaspace数据结构用来替代perm？" class="headerlink" title="为什么jdk8用metaspace数据结构用来替代perm？"></a>为什么jdk8用metaspace数据结构用来替代perm？</h4><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
<p>这项改动是很有必要的，原因有：</p>
<ol>
<li>永久代应该设置的空间大小很难确定。</li>
</ol>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<ol start="2">
<li>对永久代的调优是很困难的。</li>
</ol>
<h4 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h4><p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发，这就就导致 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代不足。放在堆里，能及时回收内存。</p>
<img src="/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><img src="/2022/05/16/JVM/image-20220711174215771.png" class="" title="image-20220711174215771">

<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="双亲委派类加载机制"><a href="#双亲委派类加载机制" class="headerlink" title="双亲委派类加载机制"></a>双亲委派类加载机制</h3><img src="/2022/05/16/JVM/image-20220711171336881.png" class="" title="image-20220711171336881">

<img src="/2022/05/16/JVM/image-20220711173346887.png" class="" title="image-20220711173346887">



<p><strong>双亲委派机制</strong>指的是，当某个特定的类加载器在收到类加载的请求时，会遵循下面的规则顺序：</p>
<p>1.首先判断被加载的类是否已经加载过，如果是则结束，否则会将加载任务委托给自己的父亲；<br>2.父类加载器在收到类加载的请求时，也会先判断被加载的类是否已经加载过，如果是则结束，否则同样将加载任务委托给自己的父亲<br>3.不断的循环进行步骤2，直到将加载任务委托给Bootstrap ClassLoader为止。此时，Bootstrap ClassLoader会先判断被加载的类是否已经加载过，如果是则结束；<br>请注意，到这里为止，都只是在转移加载任务的请求，下面将会进行类加载。</p>
<p>4.Bootstrap ClassLoader会判断能否完成加载任务，如果能则直接加载，否则会将加载任务交给儿子类加载器；<br>5.儿子类加载器也会判断能否完成加载任务，如果能则直接加载，否则会再一次将加载任务交给儿子类加载器；<br>6.不断的循环进行步骤5，直到最后一个类加载器，如果这个类加载器仍然不能够加载这个类，就会抛出一个异常：ClassNotFoundException。</p>
<pre><code>父加载器不是父类的关系 也不是类加载器的加载器 只是一种从属关系
</code></pre>
<h3 id="为什么要设计这种机制"><a href="#为什么要设计这种机制" class="headerlink" title="为什么要设计这种机制"></a>为什么要设计这种机制</h3><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入，既保证JVM的安全。</p>
<p>其次，还能保证同一个类不会被加载多次。</p>
<h2 id="对象从创建到消亡的历史过程"><a href="#对象从创建到消亡的历史过程" class="headerlink" title="对象从创建到消亡的历史过程"></a>对象从创建到消亡的历史过程</h2><h2 id="User-user-x3D-new-User-做了什么操作，申请了哪些内存？"><a href="#User-user-x3D-new-User-做了什么操作，申请了哪些内存？" class="headerlink" title="User user &#x3D; new User()  做了什么操作，申请了哪些内存？"></a>User user &#x3D; new User()  做了什么操作，申请了哪些内存？</h2><h3 id="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"><a href="#指针碰撞和空闲列表（堆内存分配对象空间的两种方式）" class="headerlink" title="指针碰撞和空闲列表（堆内存分配对象空间的两种方式）"></a>指针碰撞和空闲列表（堆内存分配对象空间的两种方式）</h3><p>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“ <em>指针碰撞</em> ”。</p>
<p> Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<em>空闲列表</em> ”。</p>
<p>具体分配方式由Jvm堆是否规整决定，Jvm堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效；如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<p>对象创建在虚拟机中是非常频繁的行为，因而产生大量的线程并发安全问题。Jvm通常采用CAS自旋和TLAB(本地线程缓冲)方案，来处理对象创建中线程安全问题。</p>
<pre><code>    CAS机制：对分配内存空间的动作进行同步处理，虚拟机采用CAS加失败重试的方式保证更新操作的原子性。通过自旋的方式不断尝试分配内存，直到分配成功。

    TALB机制：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。TLAB只是让每个线程有私有的分配指针，但是对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。（Jvm默认使用此方案）。
</code></pre>
<h2 id="对象的内存分配位置"><a href="#对象的内存分配位置" class="headerlink" title="对象的内存分配位置"></a>对象的内存分配位置</h2><p><img src="https://img-blog.csdnimg.cn/ec9158ddefc24b9a8c638d469729c542.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOO6KGM5rC05LiKX1pI,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="JVM的性能调优"><a href="#JVM的性能调优" class="headerlink" title="JVM的性能调优"></a>JVM的性能调优</h2><h2 id="GC算法，永久代对象如何GC，GC有环怎么处理"><a href="#GC算法，永久代对象如何GC，GC有环怎么处理" class="headerlink" title="GC算法，永久代对象如何GC，GC有环怎么处理"></a><strong>GC</strong>算法，永久代对象如何GC，GC有环怎么处理</h2><h2 id="Java7到Java8关于JVM的改变"><a href="#Java7到Java8关于JVM的改变" class="headerlink" title="Java7到Java8关于JVM的改变"></a>Java7到Java8关于JVM的改变</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>在讨论深拷贝和浅拷贝之前 首先要了解一下java的赋值机制——值传递</p>
<p>什么是值传递 什么是引用传递?</p>
<p>首先要了解一下 什么是实际参数 什么是形式参数?</p>
<p>形式参数 最先想到的就是java方法中的方法参数值了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123; <span class="comment">//word就是形式参数 简称形参</span></span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际参数 就是传给这个函数的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.speak(<span class="string">&quot;hello,java&quot;</span>);<span class="comment">//hello,java是实际参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 我传给这个函数的 到底是这个”hello,java”本身 还是”hello,java”这个对象在内存中的引用呢? 于是 就有了值传递和引用传递</p>
<p><strong>值传递</strong>: 把这个参数的值给函数,调用函数的时候只对传给这个函数的值进行修改等操作(就是说 在这个函数里你怎么折腾这个值都可以 但就是不会影响这个值本身) </p>
<p>将一个变量的值传给另一个变量。不管这个变量基本数据类型还是引用数据类型。引用数据类型的话传的还是值。不过这个值是指向对象的地址。</p>
<p><strong>引用传递</strong>: 直接传给函数这个参数的内存地址,直接在这个参数上面进行修改。</p>
<p>地址传递，传的是另一个变量的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>地址。<strong>java中没有引用传递</strong>。</p>
<hr>
<p><strong>深拷贝</strong></p>
<p>是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内</p>
<p>存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p><strong>浅拷贝</strong></p>
<p>只是增加了一个指针指向已存在的内存地址。</p>
<hr>
<p>那么这两个传递类型和深拷贝浅拷贝有什么关系呢?</p>
<p>深拷贝和浅拷贝在拷贝值的时候 都是值传递 并没有使用引用传递 而深拷贝的效果之所以有时候和引用传递相同,是因为引用传递是将对象的内存地址直接传给一个函数,而深拷贝是直接复制了一个内存值 在这个复制的内存值上进行操作.</p>
<p>巨人的肩膀：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/myfirstuser/article/details/98034911">(31条消息) 方法区和堆_csdn.user的博客-CSDN博客_堆和方法区</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pensieve/p/13574459.html">09_方法区 - 只是一名学徒 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/codeyanbao/article/details/82875064">(31条消息) 通俗易懂的双亲委派机制_IT烂笔头的博客-CSDN博客_双亲委派机制</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39517868/article/details/111390001">(31条消息) 双亲委派机制_面试官：双亲委派机制的原理和作用是什么？_weixin_39517868的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_69650487/article/details/124202086#:~:text=jvm%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%BB,%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%82">(31条消息) Jvm对象创建过程_风行水上_ZH的博客-CSDN博客_jvm初始化过程</a></p>
<p>更深入：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/3520829.html">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园 (cnblogs.com)</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/12/equals-%E4%B8%8EHashCode%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/" rel="prev" title="equals()与HashCode()的爱恨情仇">
      <i class="fa fa-chevron-left"></i> equals()与HashCode()的爱恨情仇
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/16/git/" rel="next" title="git">
      git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">什么是JVM？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JRE"><span class="nav-number">1.2.</span> <span class="nav-text">JRE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK"><span class="nav-number">1.3.</span> <span class="nav-text">JDK</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">JVM结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">JVM总体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">什么是垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGC"><span class="nav-number">2.2.2.</span> <span class="nav-text">什么是GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E7%9F%A5%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%A9%AC%E4%B8%8A%E5%BC%80%E5%A7%8BGC%E5%90%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">垃圾回收的基本原理是什么?有什么办法可以通知垃圾回收器马上开始GC吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%88%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E4%BD%8D%E7%BD%AE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">2.2.4.</span> <span class="nav-text">如何判断对象是否可以被回收（两种垃圾位置分析算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.5.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">1.标记-清除算法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">2.标记-复制算法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">3.标记-整理算法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%88%86%E4%BB%A3%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">2.2.5.4.</span> <span class="nav-text">4.分代算法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">2.2.6.</span> <span class="nav-text">JVM都有哪些垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.2.7.</span> <span class="nav-text">各垃圾回收器的使用位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E4%BB%A3%E9%80%82%E5%90%88%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.8.</span> <span class="nav-text">各代适合的垃圾回收算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">2.2.9.</span> <span class="nav-text">详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.2.10.</span> <span class="nav-text">创建对象的内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E5%A4%AA%E5%A4%A7%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.2.11.</span> <span class="nav-text">如果对象太大怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E7%9A%84GC"><span class="nav-number">2.2.12.</span> <span class="nav-text">发生在不同区域的GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">2.2.13.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E6%94%BE%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">方法区存放的具体内容：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">方法区的位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.13.3.</span> <span class="nav-text">运行时常量池和常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.13.3.1.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.13.3.2.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%98%E5%8C%96"><span class="nav-number">2.2.13.4.</span> <span class="nav-text">字符串常量池的位置变化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="nav-number">2.2.14.</span> <span class="nav-text">元空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.2.14.1.</span> <span class="nav-text">元空间的内存大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88jdk8%E7%94%A8metaspace%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%94%A8%E6%9D%A5%E6%9B%BF%E4%BB%A3perm%EF%BC%9F"><span class="nav-number">2.2.14.2.</span> <span class="nav-text">为什么jdk8用metaspace数据结构用来替代perm？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringTable-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%95%B4%EF%BC%9F"><span class="nav-number">2.2.14.3.</span> <span class="nav-text">StringTable 为什么要调整？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">类的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.2.</span> <span class="nav-text">双亲委派类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.3.</span> <span class="nav-text">为什么要设计这种机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">对象从创建到消亡的历史过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-user-x3D-new-User-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%8C%E7%94%B3%E8%AF%B7%E4%BA%86%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">User user &#x3D; new User()  做了什么操作，申请了哪些内存？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%88%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-number">2.5.1.</span> <span class="nav-text">指针碰撞和空闲列表（堆内存分配对象空间的两种方式）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.6.</span> <span class="nav-text">对象的内存分配位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">2.7.</span> <span class="nav-text">JVM的性能调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%AE%97%E6%B3%95%EF%BC%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95GC%EF%BC%8CGC%E6%9C%89%E7%8E%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">GC算法，永久代对象如何GC，GC有环怎么处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java7%E5%88%B0Java8%E5%85%B3%E4%BA%8EJVM%E7%9A%84%E6%94%B9%E5%8F%98"><span class="nav-number">2.9.</span> <span class="nav-text">Java7到Java8关于JVM的改变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.10.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zh-CN</p>
  <div class="site-description" itemprop="description">The Blog Which Owned Shuaiqiwudi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zh-CN</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">141k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">2:08</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
