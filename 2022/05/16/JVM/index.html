<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-nextwechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM什么是JVM？ Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此 Java语言可以实现跨平台。 提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE JRE Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang 包：包含了运行Java">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/05/16/JVM/index.html">
<meta property="og:site_name" content="shuaiqiwudi blog">
<meta property="og:description" content="JVM什么是JVM？ Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此 Java语言可以实现跨平台。 提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE JRE Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang 包：包含了运行Java">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220516150612535.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220516154322660.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220521095627681.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/image-20220520140939077.png">
<meta property="og:image" content="http://example.com/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png">
<meta property="article:published_time" content="2022-05-16T06:46:22.000Z">
<meta property="article:modified_time" content="2022-05-21T02:40:24.915Z">
<meta property="article:author" content="zh-CN">
<meta property="article:tag" content="zsr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/16/JVM/image-20220516150612535.png">

<link rel="canonical" href="http://example.com/2022/05/16/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JVM | shuaiqiwudi blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shuaiqiwudi blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zh-CN">
      <meta itemprop="description" content="The Blog Which Owned Shuaiqiwudi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuaiqiwudi blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 14:46:22" itemprop="dateCreated datePublished" datetime="2022-05-16T14:46:22+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-21 10:40:24" itemprop="dateModified" datetime="2022-05-21T10:40:24+08:00">2022-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>什么是JVM？</p>
<p><strong>J</strong>ava <strong>V</strong>irtual <strong>M</strong>achine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此</p>
<p>Java语言可以实现跨平台。</p>
<p>提到JVM 就不得不提到他的另两个兄弟 :JDK, JRE</p>
<p>JRE</p>
<p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang</p>
<p>包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异</p>
<p>常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK</p>
<p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以</p>
<p>安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>从包含关系来讲：JDK&gt;JRE&gt;JVM</p>
<img src="/2022/05/16/JVM/image-20220516150612535.png" class="" title="image-20220516150612535">

<span id="more"></span>

<p>既然谈到了JVM 众所周知 JVM是java语言的灵魂 那么JVM给java带来了什么？</p>
<p>跨平台性：</p>
<p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，</p>
<p>该系统就可以运行java程序。</p>
<p>又众所周知 java运行的流程如下：</p>
<p>.java文件 由开发人员编写 经过编译后 生成.class文件 ——即字节码文件</p>
<p>该.class文件不面向任何机器 只面向虚拟机</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解</p>
<p>释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，</p>
<p>因此，Java程序无须重新编译便可 在多种不同的计算机上运行。<strong>一次编译 到处运行</strong></p>
<p>作为高级语言 就得有解释 编译 将语言转化为二进制 这两个步骤 Java是怎么实现的呢？</p>
<p><strong>java中的编译器和解释器：</strong></p>
<p>也可以直接看下面</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在</p>
<p>任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的</p>
<p>代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代</p>
<p>码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚</p>
<p>拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，</p>
<p>然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码(.java文件)----&gt;编译器----&gt;jvm可执行的Java字节码(.class文件)----&gt;jvm----&gt;jvm中的解释器-----&gt; 机器可执行的二进制机器码----&gt;程序运行。</span><br></pre></td></tr></table></figure>

<p>接下来看一下JVM内部结构：</p>
<img src="/2022/05/16/JVM/image-20220516154322660.png" class="" title="image-20220516154322660">

<p>可以分为两组件 两子系统：</p>
<p>两个子系统：1.Class loader(类装载)  2. Execution engine(执行引擎)</p>
<p>两个组件：1.Runtime data area(运行时数据区）2.Native Interface(本地接口)。</p>
<blockquote>
<p>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</blockquote>
<blockquote>
<p>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。</p>
</blockquote>
<blockquote>
<p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内 存。</p>
</blockquote>
<blockquote>
<p>Execution engine（执行引擎）：执行classes中的指令。</p>
</blockquote>
<h5 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h5><p>运行时数据区存在于内存 又称jvm内存模型 分别有五个部分</p>
<blockquote>
<p><strong>程序计数器</strong>:当前线程所执行的字节码的行号 指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的 字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个 计数器来完成；</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>:类似虚拟机栈，是为虚拟机使用native本地方法而准备的。具体实现由虚拟机厂商来实现。HotSpot虚拟机中实现与虚拟机栈一致，同时超出大小抛StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>:每个线程私有的空间，由多个栈帧组成，一个方法对应一个栈帧，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大1M，超出跑出StackOverFlowError。</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>:所有线程都可以访问修改，存放的是对象实例，是数据区中占用空间最大的部分，在HotSpot虚拟机中分为新生代和老年代，新生代又分为Eden区和Survivor0区、Survivor1区。</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>:JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。不同虚拟机有不同的实现，oracle的HotSpot在Java7中方法区放在永久代，Java8中方法区放在元空间，并通过GC机制来管理。</p>
</blockquote>
<p>在线程共享的角度来分类 		方法区,堆 属于线程共享的 | 虚拟机栈, 本地方法栈, 程序计数器不是线程共享的</p>
<p>**而程序计数器是唯一一个不会出现OOM的区域(Out Of Memory) ** error(java.lang.OutOfMemoryError)</p>
<p>首先聊一聊堆和方法区这两个最重要的区域:</p>
<p>堆:从上面的定义来讲,存放对象实例,就是java中经常操作的对象,堆的物理地址分配对对象是不连续的。</p>
<p>因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩）。 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性 能快。</p>
<p>方法区:存放类的相关信息</p>
<ol>
<li><p>静态变量放在方法区</p>
</li>
<li><p>静态的对象还是放在堆。</p>
</li>
</ol>
<p>既然创建的实例对象都在堆中,那堆中创建的对象多了怎么办,难道堆是一个无穷无尽的空间什么时期的实例对象都收纳吗?</p>
<p>堆空间是怎么决定哪些对象应该保存,哪些对象应该消失呢?难道要java程序员自己去决定吗?这就涉及到了java的垃圾回收机制</p>
<p><strong>什么是垃圾回收机制</strong></p>
<p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行 执行。在JVM中，有一</p>
<p>个垃圾回收线程，它是低优先级的，在正常情况下是不会 执行的，只有在虚拟机空闲或者当前堆内存不</p>
<p>足时，才会触发执行，扫面那些没 有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<p><strong>什么是GC</strong></p>
<p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误</p>
<p>的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而</p>
<p>达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<p><strong>垃圾回收的基本原理是什么?有社么办法可以通知垃圾回收器马上开始GC吗?</strong></p>
<p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达</p>
<p>的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<p><strong>如何判断对象是否可以被回收</strong></p>
<p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」</p>
<p>的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<blockquote>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，</p>
<p>当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</p>
</blockquote>
<blockquote>
<p>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC</p>
<p>Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 </p>
</blockquote>
<p>&#x2F;&#x2F;TODO 可达性算法详解</p>
<p>对于堆空间,java不同版本的虚拟机会有不同的垃圾回收算法,目前最主流的有:</p>
<p>1.<strong>标记-清除算法</strong>：标记无用对象，然后进行清除回收。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<p>2.<strong>标记-复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<p>3.<strong>标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>4.<strong>分代算法</strong>：根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是新生代和老年 代，新生代分为Eden区和Survior区。<img src="/2022/05/16/JVM/image-20220521095627681.png" class="" title="image-20220521095627681"></p>
<p><strong>分代算法的对象迁移</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对</p>
<p>象应该放在老年代。因此虚拟机给每个对象定义了一个对 象年龄的计数器，如果对象在 Eden 区出生，</p>
<p>并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区</p>
<p>中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升 到老年代。</p>
<h4 id="JVM都有哪些垃圾回收器？"><a href="#JVM都有哪些垃圾回收器？" class="headerlink" title="JVM都有哪些垃圾回收器？"></a>JVM都有哪些垃圾回收器？</h4><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种</p>
<p>作用于不同分代的收集器，其中用于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回</p>
<p>收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收</p>
<p>集器 之间的连线表示它们可以搭配使用。</p>
<img src="/2022/05/16/JVM/image-20220520140939077.png" class="" title="image-20220520140939077">



<details>
<summary>点击查看垃圾回收器详细内容</summary>
Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；<br>
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU
环境下有着比Serial更好的表现；<br>
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量
= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程
序的运算任务，适合后台应用等对交互相应要求不 高的场景；<br>
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；<br>
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器
的老年代版本；<br>
<b>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</b>： 老年代并行收集 器，以获取最短回收
停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。<br>
<b>G1(Garbage First)收集器 (标记-整理算法)</b>： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新
收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同
于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种
收集器回收的范围仅限于新生代 或老年代。<br>
</details>

<p><strong>各垃圾回收器的使用位置</strong></p>
<p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<p><strong>各代适合的垃圾回收算法</strong></p>
<p>年轻代的堆空间，因为经常生成对象，并且对象的消亡和创建都很频繁，所以该区域需要高效率，能更好利用cpu的垃圾回收算法以保证内存空间的充足，<strong>新生代常常使用标记-复制算法。</strong></p>
<p>老年代的堆空间常常存放不易回收的对象，所以该区域不需要频繁的进行GC，需要考虑的是内存空间的利用，需要足够的空间存放不易回收的老年代对象，<strong>老年代常常使用标记整理算法，CMS的标记清除算法。</strong></p>
<p><strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></p>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾</p>
<p>回收器。对于要求服务器响应速度的应用上，这种垃圾 回收器非常适合。在启动 JVM 的参数加上“-</p>
<p>XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，</p>
<p>所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现</p>
<p>Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h5 id="创建对象的内存分配"><a href="#创建对象的内存分配" class="headerlink" title="创建对象的内存分配"></a>创建对象的内存分配</h5><p>多数情况下，对象都在Eden区被创建，但是当Eden区内存空间不足的时候，虚拟机会进行一次<strong>年轻代的MinorGC</strong>，</p>
<p>如果本次GC以后，依然没有足够的空间，则将启用分配担保机制，在老年代中分配内存。</p>
<p><strong>如果对象太大怎么办？</strong></p>
<p>大对象是指需要大连的连续的内存空间的对象，而大对象如果存放在年轻代，而年轻代使用的是标记复制算法，大对象</p>
<p>在两个幸存区之间不断复制，占用了其他对象的空间，并且影响了效率。假设大对象是“朝生夕死”的（从GC次数上来讲</p>
<p>不会进入老年代），那它占用了年轻代的空间，其他对象进入的时候因为大对象的存在会提前触发GC，而大对象在幸存区</p>
<p>的空间占比又过大，导致新创建的对象只能添加到老年代，这就加快了老年代GC的时间，对老年代的性能进行了很大的负面</p>
<p>影响。<strong>（毕竟老年代的GC效率大概要比年轻代的GC效率低10倍左右）</strong>。如果确定大对象是“朝生夕死”的，可以通过设置JVM</p>
<p>对大对象的参数阈值【-XX:PretenureSizeThreshold】，使大对象相对JVM来讲是不再那么大，从而在年轻代就GC（当然会</p>
<p>这样影响性能）。</p>
<h5 id="发生在不同区域的GC"><a href="#发生在不同区域的GC" class="headerlink" title="发生在不同区域的GC"></a>发生在不同区域的GC</h5><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</p>
<p><strong>Major GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。</p>
<p><strong>FullGC</strong> 是指发生在整个堆内存的GC ，老年代和年轻代一起GC，应该避免FullGC的发生，会影响JVM的性能。</p>
<p>触发条件：1）System.gc() 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存。</p>
<p>​					2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>​					3）通过Minor GC后进入年轻代的平均大小大于老年代的可用内存</p>
<p>FullGC详解</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC | Plumbr – User Experience &amp; Application Performance Monitoring</a></p>
</blockquote>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h3 id="对象从创建到消亡的历史过程"><a href="#对象从创建到消亡的历史过程" class="headerlink" title="对象从创建到消亡的历史过程"></a>对象从创建到消亡的历史过程</h3><h3 id="User-user-x3D-new-User-做了什么操作，申请了哪些内存？"><a href="#User-user-x3D-new-User-做了什么操作，申请了哪些内存？" class="headerlink" title="User user &#x3D; new User() 做了什么操作，申请了哪些内存？"></a><strong>User user &#x3D; new User()</strong> <strong>做了什么操作，申请了哪些内存？</strong></h3><h3 id="对象的内存分配位置"><a href="#对象的内存分配位置" class="headerlink" title="对象的内存分配位置"></a>对象的内存分配位置</h3><h3 id="JVM的性能调优"><a href="#JVM的性能调优" class="headerlink" title="JVM的性能调优"></a>JVM的性能调优</h3><h3 id="为什么jdk8用metaspace数据结构用来替代perm？"><a href="#为什么jdk8用metaspace数据结构用来替代perm？" class="headerlink" title="为什么jdk8用metaspace数据结构用来替代perm？"></a>为什么jdk8用metaspace数据结构用来替代perm？</h3><h3 id="GC算法，永久代对象如何GC，GC有环怎么处理"><a href="#GC算法，永久代对象如何GC，GC有环怎么处理" class="headerlink" title="GC算法，永久代对象如何GC，GC有环怎么处理"></a><strong>GC</strong>算法，永久代对象如何GC，GC有环怎么处理</h3><img src="/2022/05/16/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMwOTQwMg==,size_16,color_FFFFFF,t_70.png" class="" title="img">

<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>在讨论深拷贝和浅拷贝之前 首先要了解一下java的赋值机制——值传递</p>
<p>什么是值传递 什么是引用传递?</p>
<p>首先要了解一下 什么是实际参数 什么是形式参数?</p>
<p>形式参数 最先想到的就是java方法中的方法参数值了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String word)</span>&#123; <span class="comment">//word就是形式参数 简称形参</span></span><br><span class="line">    System.out.println(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际参数 就是传给这个函数的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.speak(<span class="string">&quot;hello,java&quot;</span>);<span class="comment">//hello,java是实际参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 我传给这个函数的 到底是这个”hello,java”本身 还是”hello,java”这个对象在内存中的引用呢? 于是 就有了值传递和引用传递</p>
<p><strong>值传递</strong>: 把这个参数的值给函数,调用函数的时候只对传给这个函数的值进行修改等操作(就是说 在这个函数里你怎么折腾这个值都可以 但就是不会影响这个值本身) </p>
<p>将一个变量的值传给另一个变量。不管这个变量基本数据类型还是引用数据类型。引用数据类型的话传的还是值。不过这个值是指向对象的地址。</p>
<p><strong>引用传递</strong>: 直接传给函数这个参数的内存地址,直接在这个参数上面进行修改。</p>
<p>地址传递，传的是另一个变量的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>地址。java中没有引用传递。</p>
<hr>
<p><strong>深拷贝</strong></p>
<p>是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内</p>
<p>存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p><strong>浅拷贝</strong></p>
<p>只是增加了一个指针指向已存在的内存地址。</p>
<hr>
<p>那么这两个传递类型和深拷贝浅拷贝有什么关系呢?</p>
<p>深拷贝和浅拷贝在拷贝值的时候 都是值传递 并没有使用引用传递 而深拷贝的效果之所以有时候和引用传递相同,是因为引用传递是将对象的内存地址直接传给一个函数,而深拷贝是直接复制了一个内存值 在这个复制的内存值上进行操作.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/12/equals-%E4%B8%8EHashCode%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/" rel="prev" title="equals()与HashCode()的爱恨情仇">
      <i class="fa fa-chevron-left"></i> equals()与HashCode()的爱恨情仇
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/16/git/" rel="next" title="git">
      git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">1.0.0.0.1.</span> <span class="nav-text">运行时数据区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">JVM都有哪些垃圾回收器？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.0.0.1.1.</span> <span class="nav-text">创建对象的内存分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E7%9A%84GC"><span class="nav-number">1.0.0.1.2.</span> <span class="nav-text">发生在不同区域的GC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.0.1.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B6%88%E4%BA%A1%E7%9A%84%E5%8E%86%E5%8F%B2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">对象从创建到消亡的历史过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#User-user-x3D-new-User-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%8C%E7%94%B3%E8%AF%B7%E4%BA%86%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.0.3.</span> <span class="nav-text">User user &#x3D; new User() 做了什么操作，申请了哪些内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.0.4.</span> <span class="nav-text">对象的内存分配位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">1.0.5.</span> <span class="nav-text">JVM的性能调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88jdk8%E7%94%A8metaspace%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%94%A8%E6%9D%A5%E6%9B%BF%E4%BB%A3perm%EF%BC%9F"><span class="nav-number">1.0.6.</span> <span class="nav-text">为什么jdk8用metaspace数据结构用来替代perm？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E7%AE%97%E6%B3%95%EF%BC%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95GC%EF%BC%8CGC%E6%9C%89%E7%8E%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.0.7.</span> <span class="nav-text">GC算法，永久代对象如何GC，GC有环怎么处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zh-CN</p>
  <div class="site-description" itemprop="description">The Blog Which Owned Shuaiqiwudi</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zh-CN</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
